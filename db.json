{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"source/images/search.jpeg","path":"images/search.jpeg","modified":0,"renderable":0},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"source/images/AOF-replication2.bmp","path":"images/AOF-replication2.bmp","modified":0,"renderable":0},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"source/images/redis-transcation2.bmp","path":"images/redis-transcation2.bmp","modified":0,"renderable":0},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"source/images/AOF-replication.bmp","path":"images/AOF-replication.bmp","modified":0,"renderable":0},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/redis-transaction1.bmp","path":"images/redis-transaction1.bmp","modified":0,"renderable":0}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1653013460563},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1653013460563},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1653013460563},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1653013460564},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1653013460564},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1653013460564},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1653013460564},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1653013460564},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1653013460564},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1653013460564},{"_id":"themes/next/README.cn.md","hash":"58ffe752bc4b7f0069fcd6304bbc2d5ff7b80f89","modified":1653013460565},{"_id":"themes/next/README.md","hash":"898213e66d34a46c3cf8446bf693bd50db0d3269","modified":1653013460565},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1653013460575},{"_id":"themes/next/_config.yml","hash":"dfe3e0d68a6851ed86ff6fd0ef398a8dc66dd40e","modified":1653013460565},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1653013460565},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1653013460565},{"_id":"source/baidu_verify_oqwNl9pESa.html","hash":"f856e506f6a6f5f833256004bd9dca47b3f698f6","modified":1653013460544},{"_id":"source/googleb84a398def4dfef1.html","hash":"81dddc5475ff9312f4a5ce1f20c44b9699ee3830","modified":1653013460545},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1653013460563},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1653013460563},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1653013460563},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1653013460564},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1653013460565},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1653013460565},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1653013460565},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1653013460566},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1653013460566},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1653013460566},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1653013460566},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1653013460566},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1653013460566},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1653013460566},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1653013460566},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1653013460566},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1653013460566},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1653013460567},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1653013460567},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1653013460567},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1653013460567},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1653013460574},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1653013460574},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1653013460574},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1653013460574},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1653013460575},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1653013460575},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1653013460575},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1653013460575},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1653013460575},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1653013460610},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1653013460610},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1653013460610},{"_id":"source/_posts/2018总结.md","hash":"f2a6a7869053ebf054408173e333bb9147539036","modified":1653013460540},{"_id":"source/_posts/Docker-CI-CD.md","hash":"e751b27d3532c8a43cb4386a86b84969b35b07bd","modified":1653013460540},{"_id":"source/_posts/Objects.mkd","hash":"ac10b46777e545a4c4cde32d0ab9497a740c1902","modified":1653013460540},{"_id":"source/_posts/apply.mkd","hash":"c01f25259b9e75bb41468a198ffd835d818f8d32","modified":1653013460540},{"_id":"source/_posts/array.mkd","hash":"e6c02030e8142051c2baf9d96ad87a3f4c833baa","modified":1653013460541},{"_id":"source/_posts/docker-compose的使用.md","hash":"684f2a7ba274294dfce0c05cfc015c4ae8a59bc6","modified":1653013460541},{"_id":"source/_posts/docker部署.mkd","hash":"fdd37d060fdba5e4050018dff19590aad49775ad","modified":1653013460541},{"_id":"source/_posts/docker和宿主机同时部署.md","hash":"3bd4873479a8c0e92253151ebbdf353ce09e7ac0","modified":1653013460541},{"_id":"source/_posts/docker部署记录文件.md","hash":"067809e74bd9837397300daa2f0b36cda5ac0d88","modified":1653013460541},{"_id":"source/_posts/hexo部署.md","hash":"9b365cba4554e5b69e80f261ef801a9a99b023f3","modified":1653026513695},{"_id":"source/_posts/es6-1.md","hash":"2d6b66202a5a7ccc99bb61b504938460feee50ba","modified":1653013460541},{"_id":"source/_posts/es6函数.mkd","hash":"e90959168bd7998cdc5a9163b2c1a75295915f25","modified":1653013460541},{"_id":"source/_posts/mysql学习.md","hash":"d1d8ba9b442c215e316d308b24d813221d6288ec","modified":1653013460541},{"_id":"source/_posts/promise.mkd","hash":"014190059ca89fff28f00d288bbfdfeb4a361bce","modified":1653013460542},{"_id":"source/_posts/python协程.md","hash":"4c30064a30f96e6812a55cab724bee772dc34694","modified":1653013460542},{"_id":"source/_posts/python线程.md","hash":"8a5ec1a34c6676dbf3357587dfdce6d380b07664","modified":1653013460542},{"_id":"source/_posts/python进程.md","hash":"a9114164adc6bfb7bccfd2eaba1a7a35c2ea3ec8","modified":1653013460542},{"_id":"source/_posts/python装饰器.md","hash":"fa2177c7ebc8d4f6ff6d39f6453f3348632b1e15","modified":1653013460542},{"_id":"source/_posts/redis.md","hash":"8b3f25e40a162618c3fd8e1dd89174dc3435a920","modified":1653013460542},{"_id":"source/_posts/redis事务.md","hash":"c9a9ce0da62768848a3e2c64a2426cde501949c8","modified":1653013460543},{"_id":"source/_posts/redis事务2.md","hash":"0f2bff89e080225abb7f81a68f41cbdadd6ce165","modified":1653013460543},{"_id":"source/_posts/redis持久化.md","hash":"682a9a9ddc53962e6cebba781f9f9d06348f256b","modified":1653013460543},{"_id":"source/_posts/socket.mkd","hash":"8760c4cbe4f46084e495666bb0e72aac070db81e","modified":1653013460543},{"_id":"source/_posts/tcp-ip-1.md","hash":"a1496fb5aa902cc9b4b93c0356c775bf8c0a248f","modified":1653013460543},{"_id":"source/_posts/vue.md","hash":"feacfb510bdf3b0ec8e756bcba6d320091f0d32d","modified":1653013460543},{"_id":"source/_posts/函数的防抖与节流.md","hash":"06129e5dad28978f8c72868fa59e4ca4459c8956","modified":1653013460543},{"_id":"source/_posts/前端跨域.md","hash":"36b9c5b91c81d63e16db5e13be650208f3f32f18","modified":1653013460543},{"_id":"source/_posts/双向绑定的实现.md","hash":"5ba80f17803b79c359f7fa7db0d63aea5827f2dc","modified":1653013460544},{"_id":"source/_posts/广度优先搜索.md","hash":"b882ebca91db3ef4aa621265b0408850058836e7","modified":1653013460544},{"_id":"source/_posts/散列表.md","hash":"1413dec4f4e934854f4ba1c8b871540d1eb09508","modified":1653013460544},{"_id":"source/_posts/记tomcat的部署与apache的反向代理.md","hash":"f80e2395fd044d8c2112773a4fe00967f2148987","modified":1653013460544},{"_id":"source/_posts/选择排序和快速排序.md","hash":"aeff2db89021433c608a9fa906a15fc0d60d192c","modified":1653013460544},{"_id":"source/about/index.md","hash":"355d571cf3ca7594932efcf2860817bc82aeee71","modified":1653013460544},{"_id":"source/categories/index.md","hash":"0185a4479a184c4c64ddc6424d717fdba6e397f6","modified":1653013460544},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1653013460588},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1653013460567},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1653013460567},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1653013460567},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1653013460567},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1653013460567},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1653013460568},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1653013460568},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1653013460568},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1653013460568},{"_id":"themes/next/layout/_partials/footer.swig","hash":"028bccd4cfdc9cc7b90a3e34382b980866bda357","modified":1653013460568},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1653013460568},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1653013460569},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1653013460568},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1653013460569},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1653013460569},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1653013460570},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1653013460570},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1653013460570},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1653013460573},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1653013460573},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1653013460573},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1653013460573},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1653013460573},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1653013460573},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1653013460573},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1653013460576},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1653013460576},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1653013460576},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1653013460576},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1653013460576},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1653013460576},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1653013460576},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1653013460576},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1653013460576},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1653013460588},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1653013460588},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1653013460588},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1653013460588},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1653013460589},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1653013460589},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1653013460589},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1653013460589},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1653013460590},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1653013460590},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1653013460590},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1653013460590},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1653013460590},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1653013460590},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1653013460590},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1653013460590},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1653013460590},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1653013460590},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1653013460591},{"_id":"source/images/search.jpeg","hash":"e81ccb2d9d04623a4e983769ffe6b90fc59df05e","modified":1653013460549},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1653013460570},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1653013460570},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1653013460584},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1653013460585},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1653013460585},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1653013460588},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1653013460588},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1653013460568},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1653013460568},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1653013460569},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1653013460569},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1653013460569},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1653013460569},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1653013460569},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1653013460570},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1653013460569},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1653013460570},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1653013460570},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1653013460570},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1653013460571},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1653013460571},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1653013460571},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1653013460571},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1653013460571},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1653013460571},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1653013460571},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1653013460571},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1653013460571},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1653013460572},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1653013460571},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1653013460572},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1653013460572},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1653013460572},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1653013460572},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1653013460572},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1653013460572},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1653013460572},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1653013460572},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1653013460572},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1653013460573},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1653013460573},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1653013460574},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1653013460574},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1653013460574},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1653013460574},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1653013460584},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1653013460584},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1653013460585},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1653013460585},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1653013460587},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1653013460587},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1653013460588},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1653013460588},{"_id":"themes/next/source/images/avatar.jpg","hash":"64538a29d72473b6cc10f0176e902caa608799bb","modified":1653013460589},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1653013460594},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1653013460595},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1653013460596},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1653013460598},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1653013460598},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1653013460599},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1653013460599},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1653013460598},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1653013460598},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1653013460599},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1653013460599},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1653013460602},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1653013460603},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1653013460603},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1653013460603},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1653013460603},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1653013460603},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1653013460603},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1653013460604},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1653013460604},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1653013460604},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1653013460599},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1653013460604},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1653013460604},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1653013460604},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1653013460605},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1653013460605},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1653013460605},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1653013460605},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1653013460605},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1653013460605},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1653013460605},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1653013460605},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1653013460605},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1653013460605},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1653013460606},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1653013460606},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1653013460606},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1653013460606},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1653013460608},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1653013460608},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1653013460610},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1653013460591},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1653013460591},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1653013460609},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1653013460609},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1653013460591},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1653013460591},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1653013460591},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1653013460591},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1653013460591},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1653013460591},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1653013460592},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1653013460592},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1653013460592},{"_id":"source/images/AOF-replication2.bmp","hash":"3d6049c996c123eba8a607edf85e4098ffcd97a1","modified":1653013460546},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1653013460603},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1653013460574},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1653013460573},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1653013460577},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1653013460577},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1653013460577},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1653013460577},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1653013460577},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1653013460579},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1653013460581},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1653013460583},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1653013460584},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1653013460584},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1653013460584},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1653013460584},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1653013460585},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1653013460584},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1653013460585},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1653013460585},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1653013460584},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1653013460585},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1653013460585},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1653013460586},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1653013460586},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1653013460586},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1653013460586},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1653013460586},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1653013460586},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1653013460586},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1653013460587},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1653013460587},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1653013460587},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1653013460587},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1653013460587},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1653013460587},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1653013460587},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1653013460596},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1653013460596},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1653013460596},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1653013460596},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1653013460596},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1653013460597},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1653013460597},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1653013460597},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1653013460598},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1653013460598},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1653013460593},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1653013460593},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1653013460594},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1653013460599},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1653013460599},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1653013460600},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1653013460608},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1653013460608},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1653013460592},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1653013460596},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1653013460593},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1653013460602},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1653013460602},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1653013460609},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1653013460577},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1653013460578},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1653013460578},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1653013460578},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1653013460577},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1653013460577},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1653013460578},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1653013460578},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1653013460578},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1653013460578},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1653013460578},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1653013460578},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1653013460579},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1653013460579},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1653013460579},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1653013460579},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1653013460579},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1653013460579},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1653013460579},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1653013460579},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1653013460579},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1653013460579},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1653013460580},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1653013460580},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1653013460580},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1653013460580},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1653013460580},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1653013460580},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1653013460580},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1653013460582},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1653013460582},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1653013460582},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1653013460582},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1653013460582},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1653013460582},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1653013460582},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1653013460582},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1653013460582},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1653013460580},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1653013460580},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1653013460581},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1653013460581},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1653013460581},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1653013460581},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1653013460581},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1653013460581},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1653013460581},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1653013460582},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1653013460583},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1653013460581},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1653013460583},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1653013460583},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1653013460583},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1653013460583},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1653013460583},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1653013460583},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1653013460583},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1653013460583},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1653013460586},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1653013460586},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1653013460587},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1653013460596},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1653013460597},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1653013460597},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1653013460597},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1653013460597},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1653013460597},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1653013460592},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1653013460592},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1653013460593},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1653013460592},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1653013460593},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1653013460600},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1653013460602},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1653013460601},{"_id":"source/images/redis-transcation2.bmp","hash":"7fd8be111187ce47920541c252ce7b931ee538bd","modified":1653013460549},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1653013460595},{"_id":"source/images/AOF-replication.bmp","hash":"5284e7c7bb8f470e1ba36867c802170901d57659","modified":1653013460545},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1653013460608},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1653013460601},{"_id":"source/images/redis-transaction1.bmp","hash":"3a8e5ba6485a43ba37e1b0593aa39cc18c146977","modified":1653013460548},{"_id":"public/baidu_verify_oqwNl9pESa.html","hash":"8390ab3b385b386f37327a91e569bbfcc3af7efa","modified":1653025789976},{"_id":"public/googleb84a398def4dfef1.html","hash":"1eab4884da4fab5d8deb8349d4249acc5309a647","modified":1653025789976},{"_id":"public/sitemap.xml","hash":"c9113c6cee3d24db8c02e5313bfb180ef9651c79","modified":1653026520349},{"_id":"public/baidusitemap.xml","hash":"5008a50b3b94e598cc2ac7a3a3221f45d8b72cdf","modified":1653025789987},{"_id":"public/about/index.html","hash":"81b9c36de809c436a7b8dc7fb91904e77d849520","modified":1653025790147},{"_id":"public/categories/index.html","hash":"92af1fef5dfcb19f287525853c16314f0812cfa6","modified":1653025790147},{"_id":"public/archives/page/5/index.html","hash":"675eb698dfbdc0c8270ed8fe7169ee86478955e0","modified":1653025790148},{"_id":"public/archives/2019/page/3/index.html","hash":"4be246da2b1444a16fe33283182db01837bf3c4a","modified":1653025790148},{"_id":"public/archives/2019/01/index.html","hash":"1a933e62742408c9c1285782bde423feffc4392d","modified":1653025790148},{"_id":"public/archives/2019/02/index.html","hash":"ccfafa66ca7f787c24311bcc0dde24db47144f17","modified":1653025790148},{"_id":"public/archives/2019/03/index.html","hash":"8394eaa1164a44aef2dffb51ec97293e81d6b4c3","modified":1653025790148},{"_id":"public/archives/2019/04/index.html","hash":"4314d3446cb730b73eb439a621729e036b25d355","modified":1653025790148},{"_id":"public/archives/2019/05/index.html","hash":"f6e3939c1c8d2a5651e0818b69b491460409616d","modified":1653025790148},{"_id":"public/categories/docker/index.html","hash":"e091b7cd8ba59f937af57209abd41dc8b40ba632","modified":1653025790148},{"_id":"public/categories/javascript/index.html","hash":"5547a947d0d0682f48f020f1e0058689eece05eb","modified":1653025790148},{"_id":"public/categories/生活/index.html","hash":"f966f0c1a3e34f4d3714dd3d1db59885abc6b0b2","modified":1653025790148},{"_id":"public/categories/python/index.html","hash":"c0cb33f86f831926a07d84e7b58101e681932f3e","modified":1653025790148},{"_id":"public/categories/mysql/index.html","hash":"979881eb2da759dc69833f1e4fb436e6bd596a55","modified":1653025790148},{"_id":"public/categories/redis/index.html","hash":"2dad16337c2c86c0372eaaa6265b9f7816808a49","modified":1653025790148},{"_id":"public/categories/Tcp/index.html","hash":"283ad6bbb44458bccd4029e656fd595e4c4459b3","modified":1653025790148},{"_id":"public/categories/socket/index.html","hash":"fdb742301b3bc87a94261eb687441e2a4a9a37b9","modified":1653025790148},{"_id":"public/categories/vue/index.html","hash":"0a598a009c7c2e5b07193619788dc89211d93f8d","modified":1653025790148},{"_id":"public/categories/ES6/index.html","hash":"073865ed13265a72a4f17f068f22e2eae6e485c7","modified":1653025790148},{"_id":"public/categories/前端/index.html","hash":"b1e27937bd5b002312bc6d9c2e0867553d7c42c5","modified":1653025790148},{"_id":"public/categories/服务器/index.html","hash":"0e08e16ed9e65df4733fc5e031172f7b8e8c35bb","modified":1653025790148},{"_id":"public/categories/算法/index.html","hash":"df87f7c26130be687ff2719fa07e8204adc9d0e2","modified":1653025790148},{"_id":"public/tags/javascript/index.html","hash":"f9c3eb89e4a688f8a555e1b6206b1e01a1e93f8b","modified":1653025790149},{"_id":"public/tags/docker/index.html","hash":"3367a5688eecb85dba6e45fcf0ef4386b70b0df0","modified":1653025790149},{"_id":"public/tags/ES6/index.html","hash":"848f42dd46e59b6ba3f9879930d3c00eeaa398db","modified":1653025790149},{"_id":"public/tags/生活/index.html","hash":"fba2d85d54d08e5e043320d4474f1be8595bbada","modified":1653025790149},{"_id":"public/tags/mysql/index.html","hash":"173b077dc005bdd373c61673aa393ca789a6299b","modified":1653025790149},{"_id":"public/tags/dcoker/index.html","hash":"5e52861f020242bec60be76ff98d54b03f6951c4","modified":1653025790149},{"_id":"public/tags/python/index.html","hash":"a229713e7777a16216bc8386c3b9e7431fc09865","modified":1653025790149},{"_id":"public/tags/redis/index.html","hash":"9325876c83ed138d889fe741454fcc1933d363c1","modified":1653025790149},{"_id":"public/tags/Tcp/index.html","hash":"761f2f418b98b416ff2b820176e9e012d93bdf31","modified":1653025790149},{"_id":"public/2019/05/22/双向绑定的实现/index.html","hash":"d446772165bf227b2938f5de322dbc04ca7f7ed2","modified":1653025790149},{"_id":"public/2019/05/17/函数的防抖与节流/index.html","hash":"426ed35fcace9e71ba595e30f466df32e27825a2","modified":1653025790149},{"_id":"public/2019/05/08/前端跨域/index.html","hash":"bb87f5decef99f1c53f78fc38909f09c1b975fc7","modified":1653025790149},{"_id":"public/2019/04/29/docker-compose的使用/index.html","hash":"73c55483160d56038c0995bdea7dab1f841fceff","modified":1653025790149},{"_id":"public/2019/04/22/tcp-ip-1/index.html","hash":"450525b40168ea2637ac70685d481ffe67e9e0d5","modified":1653025790149},{"_id":"public/2019/04/16/docker和宿主机同时部署/index.html","hash":"c34b71b67293405dceae2f3ebbf610e0ff2f7c57","modified":1653025790149},{"_id":"public/2019/05/15/Docker-CI-CD/index.html","hash":"2d13158a8f0109ad48efdaca8ad9e0f193568799","modified":1653025790149},{"_id":"public/2019/04/15/docker部署记录文件/index.html","hash":"0954c7f98640758c4ccca9d1a91232b0ba699df9","modified":1653025790149},{"_id":"public/2019/03/19/es6-1/index.html","hash":"57e3039ca030d1429b8a6266943f01ccffa1a6de","modified":1653025790149},{"_id":"public/2019/03/15/python装饰器/index.html","hash":"22fcf2aa234848d4d719311bd4aacb48ebd72574","modified":1653025790149},{"_id":"public/2019/02/25/redis事务2/index.html","hash":"8dc3109bdc40ca72ba6899dc4433e46c3a002d53","modified":1653025790149},{"_id":"public/2019/02/25/redis持久化/index.html","hash":"662e0f26c540696c62f5d8265157a39731436ea7","modified":1653025790149},{"_id":"public/2019/02/25/redis事务/index.html","hash":"f75763e6dd5fff08837a26262efef2e7b1caf8bb","modified":1653025790149},{"_id":"public/2019/01/16/python协程/index.html","hash":"4cdd93b8b6a81da1f87d48cf61f3c966cf6b066a","modified":1653025790149},{"_id":"public/2019/01/16/python进程/index.html","hash":"f840fbfc2fe5cfcd5f7b164f3c99830cf4cc9ade","modified":1653025790149},{"_id":"public/2019/01/16/python线程/index.html","hash":"16c770d2b3132395e663029f1d71b751e1a12c42","modified":1653025790149},{"_id":"public/2019/01/04/redis/index.html","hash":"e0bfeb26ab59bd39090035fa61119622864ee74f","modified":1653025790149},{"_id":"public/2018/12/29/2018总结/index.html","hash":"4661bbd87c035b881f679c44168beb04507ea793","modified":1653025790149},{"_id":"public/2018/12/24/广度优先搜索/index.html","hash":"b9c7c242e86c21dc0dd392ed05f347eb491646a5","modified":1653025790149},{"_id":"public/2018/12/27/记tomcat的部署与apache的反向代理/index.html","hash":"1418b07c70998194a89909144233fd46da89a260","modified":1653025790149},{"_id":"public/2018/12/20/vue/index.html","hash":"ce26cc59ff3d44e7680e1aebb3257408186f766c","modified":1653025790149},{"_id":"public/2018/12/20/mysql学习/index.html","hash":"fbd1ca46920d5f7d31ba25a3cffbc376a5f6ebe2","modified":1653025790149},{"_id":"public/2018/12/19/socket/index.html","hash":"40892195b2b626d0b555c08906dd2c675e412d04","modified":1653025790149},{"_id":"public/2018/12/21/选择排序和快速排序/index.html","hash":"8ba92e8f58d7574ec3ebfe05240191c3da7f3bcb","modified":1653025790149},{"_id":"public/2018/12/24/散列表/index.html","hash":"23bea4aee051d5da423428992bb58460d9e2d10a","modified":1653025790149},{"_id":"public/2018/12/18/promise/index.html","hash":"62230157ac3a4808c727fd0e69c7099b7d554f50","modified":1653025790149},{"_id":"public/2018/12/15/Objects/index.html","hash":"807a60e2a0c2bc2a0abe248ccb4803b54a4efdb5","modified":1653025790149},{"_id":"public/2018/12/12/es6函数/index.html","hash":"5c8fb707a6da8d9ce178cf6223718f4ad3e99a3e","modified":1653025790149},{"_id":"public/2018/12/09/docker部署/index.html","hash":"ee95acc051a2cf72798b0b4b37c77c2c20ee142c","modified":1653025790149},{"_id":"public/2018/12/06/array/index.html","hash":"690b31ebad341ba1267e981c66d1490f05a19aa5","modified":1653025790149},{"_id":"public/2018/12/01/apply/index.html","hash":"d869764b42d8060c0a86995322147ba9f08d7cb3","modified":1653025790149},{"_id":"public/archives/page/2/index.html","hash":"9001e18cc6850fba872c373acb3c6823ee825dd1","modified":1653025790149},{"_id":"public/archives/page/3/index.html","hash":"10444be7ad0d68d81ed870035946b9fa6dd19a07","modified":1653025790149},{"_id":"public/archives/page/4/index.html","hash":"ae440906b3543a95abc95c098dc193db05e05d31","modified":1653025790149},{"_id":"public/archives/2018/index.html","hash":"329eaa642e8f21f26e83bfbd41977e5edc28dcad","modified":1653025790149},{"_id":"public/archives/2018/page/2/index.html","hash":"45cdd0f3de1af8483d74494e0be49a98a71f5ffc","modified":1653025790149},{"_id":"public/archives/2018/12/index.html","hash":"c516187200274ab48e3d76cf393baae8bc3bb1a0","modified":1653025790149},{"_id":"public/archives/index.html","hash":"ba8ae9cf707d7b8d1c721d554676b0550ff54098","modified":1653025790149},{"_id":"public/archives/2018/12/page/2/index.html","hash":"c09347212b334895557c41e1929a4aab74169876","modified":1653025790149},{"_id":"public/archives/2019/index.html","hash":"3ba82c8f76b98333c013c127915661afbd75fe11","modified":1653025790149},{"_id":"public/archives/2019/page/2/index.html","hash":"58ae5d729aa9da60703bbbc45a7615d4bba43ab6","modified":1653025790149},{"_id":"public/index.html","hash":"bf59335d0dab2665a403f6dcdd071c4878ffbea1","modified":1653026520363},{"_id":"public/page/3/index.html","hash":"f1cb348b2d528c6e10300e03112810281f96ca38","modified":1653025790149},{"_id":"public/page/2/index.html","hash":"142eb655203124b8cbc68e6140c39c154baab869","modified":1653025790149},{"_id":"public/page/4/index.html","hash":"5604fd3ea79413398e3c272f51674be3ee118195","modified":1653025790149},{"_id":"public/archives/2022/index.html","hash":"ac2f15e1f9bae5b707d5f0224716d12450f5a063","modified":1653025790152},{"_id":"public/archives/2022/05/index.html","hash":"a283f4187e573e86a643da93bc3000b80b593df5","modified":1653025790152},{"_id":"public/tags/服务器部署-hexo/index.html","hash":"05c0a87bd86b483305d0890a95da6cf79d694780","modified":1653025790152},{"_id":"public/tags/网络编程/index.html","hash":"80136dbec35fbff564c1425739a3215fa8ba82a8","modified":1653025790153},{"_id":"public/tags/vue/index.html","hash":"18b95cb418a8b57f9d3dda8ec6ff62e24ee6d893","modified":1653025790153},{"_id":"public/tags/前端/index.html","hash":"1d04c7e9894b5bf3c109299f3d185c1f5cd4d473","modified":1653025790153},{"_id":"public/tags/服务器/index.html","hash":"48e65e9af647927c8ab60c4347007efb3b98dc55","modified":1653025790153},{"_id":"public/tags/算法/index.html","hash":"e953f14eac7c166eabe06114a466ab5c17007d11","modified":1653025790153},{"_id":"public/2022/05/20/hexo部署/index.html","hash":"fbf4f15965142653cff3f6e3dbd15ff356da1bfa","modified":1653026520362},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1653025790155},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1653025790155},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1653025790155},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1653025790155},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1653025790155},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1653025790155},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1653025790155},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1653025790155},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1653025790155},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1653025790155},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1653025790155},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1653025790155},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1653025790155},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1653025790155},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1653025790155},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1653025790155},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1653025790155},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1653025790155},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1653025790155},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1653025790155},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1653025790155},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1653025790155},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1653025790155},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1653025790155},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1653025790155},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1653025790155},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1653025790155},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1653025790156},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1653025790156},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1653025790156},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1653025790156},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1653025790156},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1653025790156},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1653025790499},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1653025790500},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1653025790505},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1653025790505},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1653025790505},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1653025790505},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1653025790505},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1653025790505},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1653025790505},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1653025790505},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1653025790505},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1653025790505},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1653025790505},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1653025790505},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1653025790505},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1653025790506},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1653025790506},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1653025790506},{"_id":"public/css/main.css","hash":"fdc35d3965a9882a576ddf7813ea9cc2bbca9f06","modified":1653025790506},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1653025790506},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1653025790506},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1653025790506},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1653025790506},{"_id":"public/images/avatar.jpg","hash":"64538a29d72473b6cc10f0176e902caa608799bb","modified":1653025790506},{"_id":"public/images/search.jpeg","hash":"e81ccb2d9d04623a4e983769ffe6b90fc59df05e","modified":1653025790506},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1653025790509},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1653025790509},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1653025790510},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1653025790510},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1653025790510},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1653025790510},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1653025790510},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1653025790510},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1653025790510},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1653025790510},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1653025790510},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1653025790510},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1653025790510},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1653025790510},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1653025790510},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1653025790510},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1653025790510},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1653025790510},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1653025790510},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1653025790510},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1653025790510},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1653025790510},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1653025790510},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1653025790510},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1653025790510},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1653025790510},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1653025790510},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1653025790510},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1653025790510},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1653025790510},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1653025790510},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1653025790510},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1653025790510},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1653025790510},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1653025790510},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1653025790510},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1653025790510},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1653025790510},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1653025790510},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1653025790510},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1653025790510},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1653025790510},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1653025790510},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1653025790510},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1653025790510},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1653025790510},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1653025790510},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1653025790510},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1653025790510},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1653025790510},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1653025790510},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1653025790511},{"_id":"public/images/AOF-replication2.bmp","hash":"3d6049c996c123eba8a607edf85e4098ffcd97a1","modified":1653025790532},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1653025790534},{"_id":"public/images/redis-transcation2.bmp","hash":"7fd8be111187ce47920541c252ce7b931ee538bd","modified":1653025790535},{"_id":"public/images/AOF-replication.bmp","hash":"5284e7c7bb8f470e1ba36867c802170901d57659","modified":1653025790535},{"_id":"public/images/redis-transaction1.bmp","hash":"3a8e5ba6485a43ba37e1b0593aa39cc18c146977","modified":1653025790536}],"Category":[{"name":"docker","_id":"cl3e0vh7a0004lae15whkwbhm"},{"name":"javascript","_id":"cl3e0vh7d0009lae1y6jf0ds7"},{"name":"生活","_id":"cl3e0vh7i000mlae1sohi7f71"},{"name":"ES6","_id":"cl3e0vh7l0011lae1rb8hreoa"},{"name":"mysql","_id":"cl3e0vh7m001alae1b76p2h9o"},{"name":"python","_id":"cl3e0vh7o001jlae1b5he07cg"},{"name":"redis","_id":"cl3e0vh7u0028lae1ix7ff9gu"},{"name":"Tcp","_id":"cl3e0vh7x002qlae10znptkeb"},{"name":"socket","_id":"cl3e0vh7y002vlae1bamsz0lr"},{"name":"vue","_id":"cl3e0vh7y002zlae1vl2mtfrl"},{"name":"前端","_id":"cl3e0vh7z0034lae1ef23h0f1"},{"name":"算法","_id":"cl3e0vh7z003alae1r7h9513q"},{"name":"服务器","_id":"cl3e0vh80003ilae13izbh765"}],"Data":[],"Page":[{"layout":"false","_content":"oqwNl9pESa\n","source":"baidu_verify_oqwNl9pESa.html","raw":"layout: false\n---\noqwNl9pESa\n","date":"2022-05-20T02:24:20.544Z","updated":"2022-05-20T02:24:20.544Z","path":"baidu_verify_oqwNl9pESa.html","title":"","comments":1,"_id":"cl3e0vh5b0000lae1sumsqltf","content":"oqwNl9pESa\n","site":{"data":{}},"excerpt":"","more":"oqwNl9pESa\n"},{"layout":"false","_content":"google-site-verification: googleb84a398def4dfef1.html\n","source":"googleb84a398def4dfef1.html","raw":"layout: false\n---\ngoogle-site-verification: googleb84a398def4dfef1.html\n","date":"2022-05-20T02:24:20.545Z","updated":"2022-05-20T02:24:20.545Z","path":"googleb84a398def4dfef1.html","title":"","comments":1,"_id":"cl3e0vh5b0001lae1376ojz06","content":"google-site-verification: googleb84a398def4dfef1.html\n","site":{"data":{}},"excerpt":"","more":"google-site-verification: googleb84a398def4dfef1.html\n"},{"title":"About me","date":"2018-12-19T03:37:25.000Z","_content":"\n\n## wait for implement\n## how to be a coder","source":"about/index.md","raw":"---\ntitle: About me\ndate: 2018-12-19 11:37:25\n---\n\n\n## wait for implement\n## how to be a coder","updated":"2022-05-20T02:24:20.544Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl3e0vh8e0043lae1wt3xp0e6","content":"<h2 id=\"wait-for-implement\"><a href=\"#wait-for-implement\" class=\"headerlink\" title=\"wait for implement\"></a>wait for implement</h2><h2 id=\"how-to-be-a-coder\"><a href=\"#how-to-be-a-coder\" class=\"headerlink\" title=\"how to be a coder\"></a>how to be a coder</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"wait-for-implement\"><a href=\"#wait-for-implement\" class=\"headerlink\" title=\"wait for implement\"></a>wait for implement</h2><h2 id=\"how-to-be-a-coder\"><a href=\"#how-to-be-a-coder\" class=\"headerlink\" title=\"how to be a coder\"></a>how to be a coder</h2>"},{"title":"分类","date":"2018-12-19T03:37:46.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-12-19 11:37:46\ntype: \"categories\"\n---\n","updated":"2022-05-20T02:24:20.544Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl3e0vh8e0044lae1sxc1d6jw","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"posts","title":"Docker CI CD","date":"2019-05-15T03:30:07.000Z","_content":"### 记录docker的持续集成(CI)和自动部署(CD)\n\n\n#### docker+travis实现持续集成(CI)\n\n1.在github新建仓库，加入一个`Dockerfile`，内容自定义。\n\n2.在travis中添加这个仓库，登录travis-ci.com，然后登录github选中仓库即可。\n\n3.使用`tavis`需要编辑一个`.travis.yml`，内容如下\n```\nlanguage: bash\ndist: xenial\nservices:\n- docker\nbefore_script:\n- echo \"$DOCKER_PASSWORD\" | docker login -u \"$DOCKER_USERNAME\" --password-stdin\nscript:\n- echo \"test code\"\nafter_success:\n- docker build -t guoxy/alpine .\n- docker push guoxy/alpine\n\n```\n<!-- more -->\n这里只是很简单的测试文件，由于我们需要使用`docker`，所以在`serives`中天机`docker`，`before_script`是在运行之前先登录`dockerhub`的账号。    \n其中`$DOCKER_PASSWORD`和`DOCKER_USERNAME`我们可以在travis选中的这个仓库的settings中添加作为环境变量。    \n我们在持续集成中，一般把需要运行测试的代码添加到script中,以django为例的话，一般执行`python manage.py migrate`和`python manage.py test`来运行迁移和执行我们的单元测试代码。在运行成功后即`after_success`我们重新build了这个镜像，然后推送到我们的`dockerhub`的仓库。这里我们实现了持续集成，相当于我们每次提交了代码，完成了单元测试，然后travis会自动把我们的代码重新打包成镜像并且推送的我们的`dockerhub`。然后我们需要做的事是从服务器自动拉取更新过的镜像，然后运行，完成自动部署的部分。\n\n#### docker+travis实现自动部署\n\n1. 首先我们要在本机上安装ruby的gem，利用gem安装travis\n```\nsudo apt-get install ruby\nsudo apt-get install ruby-dev\nsudo gem install travis\n```\n2. 此时可以进行登录，这里卡了一个问题，由于travis-ci有俩网站，所以我们一定要看自己是在`travis-ci.org`结尾的网站还是`travis-ci.com`,非常重要，否则后面会出bug，我自己用的就是`travis-ci.com`，一般也都是这个。\n```\ntravis login --com  \n\n然后输入你的github的账号和密码\n```\n\n3.然后我们需要把我们服务器的私钥传到travis上才能让其远程登录服务器。  \n```\ntravis encrypt-file ~/.ssh/id_rsa --pro --com --add  #com网站后缀,add会把加密的私钥作为环境变量传送到travis的setting中可以查看。\n```\n这一步之后我们会发现有了我们之前加入的四个环境变量。`.travis.yml`的内容如下\n```\nlanguage: bash\ndist: xenial\nservices:\n- docker\nbefore_script:\n- echo \"$DOCKER_PASSWORD\" | docker login -u \"$DOCKER_USERNAME\" --password-stdin\nscript:\n- echo \"test code\"\nafter_success:\n- docker build -t guoxy/alpine .\n- docker push guoxy/alpine\n- ssh guoxiaoyang@101.201.68.24 -o StrictHostKeyChecking=no \"sh ~/travis-remote/test.sh\"\nenv:\n  global:\n    secure: jjMhZ/k9Yv+XjeUQxjC1lE2cOPJ8MTgmckJ8M7YCWcIn2u2lb+H+n/2CaTQUjpL3K9Q/OlePKQjioL1Qh2FGxi7x+8p2HpTVXxamrPSXF3DCkNBiWWRcvA8rBrTLztmap45qMyhNyNGxjiOOvS6PnNRjE29BJZd3Lmyu06Y7s/MiwGGrc12frs8m/Z/LahNg+oJeeZQilw795K6/X5gen2aRWaAlsk6c2FKbNU3Gh26ifMwdlgAYZ51Z7W2b610tT9DkV1r/nztLGd+1Y6PSSJUTd9q5R/Nm7xlHPyj9Pwhhyz6yiQ8Px3irKDh3iFBpzH2ylDoUr/9wPIwMsWg2Tb2DoF5LOjvcRVWRoBdOJAiQIdxXN2euPLkJBA/FEv1oPngBOKAljJn+BdKBq5PVGCdXBt8BAdCr8tjvlgT1YJdSFuz9wYZLyX9+WKUbDt5H4QwkMZ0Ro/xFx6u3yPnBf5bCkrgJzkpmLgakckFaU/uHEdp11p+SAQ35n/FVImnZgz9GiHWA6g7lTTvLt7U//KI+ZRT8n39fSDiS378x8ORqqnFcdAMzZAYWr26uVYTS/d6DpHWZlqLrIG0UPhy6+HRZa3U4OfYW4toe1u1SHWn9JuAA9ejFzvn3M4T/PDOcTEx/NsMIfzjsjfabWiPUoQ7Di8Hd6jYBxm+e9gBtYIM=\naddons:\n- ssh_known_hosts: 101.201.68.24\nbefore_install:\n- openssl aes-256-cbc -K $encrypted_78105f82ade5_key -iv $encrypted_78105f82ade5_iv\n  -in id_rsa.enc -out ~/.ssh/id_rsa -d\n- chmod 600 ~/.ssh/id_rsa\n\n```\n因为 travis 第一次登录远程服务器会出现 SSH 主机验证，这边会有一个主机信任问题。官方给出的方案是添加 addons 配置：\n```\naddons:\n- ssh_known_hosts: 服务器ip\n```\nssh那一步使我们登录远程服务器，并且执行相应的脚本。`-o`代表第一次舞曲输入确认的yes选项。\n\n关于ssh远程免密码登录记录如下:\n我们本地先生成一对秘钥，默认存放于`~/.ssh/`，我们把公钥上传至服务器\n```\nssh-copy-id -i ~/.ssh/id_rsa.pub username@ip\n然后在服务器端会生成authorized_keys的文件\n```\n然后登录即可\n```\nssh username@ip\n```\n自己的自动部署的脚本名为`test.sh`，内容如下\n```\n#!/bin/bash\necho \"Hello World\"\ncat ./.secret | docker login --username \"guoxy\" --password-stdin\ndocker stop deploy-test\ndocker rm $(docker ps -q)\ndocker container rm deploy-test\ndocker pull guoxy/ubuntu-with-vi:v1\ndocker run -it -d --name deploy-test guoxy/ubuntu-with-vi:v1\n\n```\n以上都是用测试的代码，不过也算完整的跑了一遍CI,CD,后面添加自己的web代码，再跑一遍，看看是否有问题。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Docker-CI-CD.md","raw":"---\nlayout: posts\ntitle: Docker CI CD\ndate: 2019-05-15 11:30:07\ntags: docker\ncategories: docker\n---\n### 记录docker的持续集成(CI)和自动部署(CD)\n\n\n#### docker+travis实现持续集成(CI)\n\n1.在github新建仓库，加入一个`Dockerfile`，内容自定义。\n\n2.在travis中添加这个仓库，登录travis-ci.com，然后登录github选中仓库即可。\n\n3.使用`tavis`需要编辑一个`.travis.yml`，内容如下\n```\nlanguage: bash\ndist: xenial\nservices:\n- docker\nbefore_script:\n- echo \"$DOCKER_PASSWORD\" | docker login -u \"$DOCKER_USERNAME\" --password-stdin\nscript:\n- echo \"test code\"\nafter_success:\n- docker build -t guoxy/alpine .\n- docker push guoxy/alpine\n\n```\n<!-- more -->\n这里只是很简单的测试文件，由于我们需要使用`docker`，所以在`serives`中天机`docker`，`before_script`是在运行之前先登录`dockerhub`的账号。    \n其中`$DOCKER_PASSWORD`和`DOCKER_USERNAME`我们可以在travis选中的这个仓库的settings中添加作为环境变量。    \n我们在持续集成中，一般把需要运行测试的代码添加到script中,以django为例的话，一般执行`python manage.py migrate`和`python manage.py test`来运行迁移和执行我们的单元测试代码。在运行成功后即`after_success`我们重新build了这个镜像，然后推送到我们的`dockerhub`的仓库。这里我们实现了持续集成，相当于我们每次提交了代码，完成了单元测试，然后travis会自动把我们的代码重新打包成镜像并且推送的我们的`dockerhub`。然后我们需要做的事是从服务器自动拉取更新过的镜像，然后运行，完成自动部署的部分。\n\n#### docker+travis实现自动部署\n\n1. 首先我们要在本机上安装ruby的gem，利用gem安装travis\n```\nsudo apt-get install ruby\nsudo apt-get install ruby-dev\nsudo gem install travis\n```\n2. 此时可以进行登录，这里卡了一个问题，由于travis-ci有俩网站，所以我们一定要看自己是在`travis-ci.org`结尾的网站还是`travis-ci.com`,非常重要，否则后面会出bug，我自己用的就是`travis-ci.com`，一般也都是这个。\n```\ntravis login --com  \n\n然后输入你的github的账号和密码\n```\n\n3.然后我们需要把我们服务器的私钥传到travis上才能让其远程登录服务器。  \n```\ntravis encrypt-file ~/.ssh/id_rsa --pro --com --add  #com网站后缀,add会把加密的私钥作为环境变量传送到travis的setting中可以查看。\n```\n这一步之后我们会发现有了我们之前加入的四个环境变量。`.travis.yml`的内容如下\n```\nlanguage: bash\ndist: xenial\nservices:\n- docker\nbefore_script:\n- echo \"$DOCKER_PASSWORD\" | docker login -u \"$DOCKER_USERNAME\" --password-stdin\nscript:\n- echo \"test code\"\nafter_success:\n- docker build -t guoxy/alpine .\n- docker push guoxy/alpine\n- ssh guoxiaoyang@101.201.68.24 -o StrictHostKeyChecking=no \"sh ~/travis-remote/test.sh\"\nenv:\n  global:\n    secure: jjMhZ/k9Yv+XjeUQxjC1lE2cOPJ8MTgmckJ8M7YCWcIn2u2lb+H+n/2CaTQUjpL3K9Q/OlePKQjioL1Qh2FGxi7x+8p2HpTVXxamrPSXF3DCkNBiWWRcvA8rBrTLztmap45qMyhNyNGxjiOOvS6PnNRjE29BJZd3Lmyu06Y7s/MiwGGrc12frs8m/Z/LahNg+oJeeZQilw795K6/X5gen2aRWaAlsk6c2FKbNU3Gh26ifMwdlgAYZ51Z7W2b610tT9DkV1r/nztLGd+1Y6PSSJUTd9q5R/Nm7xlHPyj9Pwhhyz6yiQ8Px3irKDh3iFBpzH2ylDoUr/9wPIwMsWg2Tb2DoF5LOjvcRVWRoBdOJAiQIdxXN2euPLkJBA/FEv1oPngBOKAljJn+BdKBq5PVGCdXBt8BAdCr8tjvlgT1YJdSFuz9wYZLyX9+WKUbDt5H4QwkMZ0Ro/xFx6u3yPnBf5bCkrgJzkpmLgakckFaU/uHEdp11p+SAQ35n/FVImnZgz9GiHWA6g7lTTvLt7U//KI+ZRT8n39fSDiS378x8ORqqnFcdAMzZAYWr26uVYTS/d6DpHWZlqLrIG0UPhy6+HRZa3U4OfYW4toe1u1SHWn9JuAA9ejFzvn3M4T/PDOcTEx/NsMIfzjsjfabWiPUoQ7Di8Hd6jYBxm+e9gBtYIM=\naddons:\n- ssh_known_hosts: 101.201.68.24\nbefore_install:\n- openssl aes-256-cbc -K $encrypted_78105f82ade5_key -iv $encrypted_78105f82ade5_iv\n  -in id_rsa.enc -out ~/.ssh/id_rsa -d\n- chmod 600 ~/.ssh/id_rsa\n\n```\n因为 travis 第一次登录远程服务器会出现 SSH 主机验证，这边会有一个主机信任问题。官方给出的方案是添加 addons 配置：\n```\naddons:\n- ssh_known_hosts: 服务器ip\n```\nssh那一步使我们登录远程服务器，并且执行相应的脚本。`-o`代表第一次舞曲输入确认的yes选项。\n\n关于ssh远程免密码登录记录如下:\n我们本地先生成一对秘钥，默认存放于`~/.ssh/`，我们把公钥上传至服务器\n```\nssh-copy-id -i ~/.ssh/id_rsa.pub username@ip\n然后在服务器端会生成authorized_keys的文件\n```\n然后登录即可\n```\nssh username@ip\n```\n自己的自动部署的脚本名为`test.sh`，内容如下\n```\n#!/bin/bash\necho \"Hello World\"\ncat ./.secret | docker login --username \"guoxy\" --password-stdin\ndocker stop deploy-test\ndocker rm $(docker ps -q)\ndocker container rm deploy-test\ndocker pull guoxy/ubuntu-with-vi:v1\ndocker run -it -d --name deploy-test guoxy/ubuntu-with-vi:v1\n\n```\n以上都是用测试的代码，不过也算完整的跑了一遍CI,CD,后面添加自己的web代码，再跑一遍，看看是否有问题。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Docker-CI-CD","published":1,"updated":"2022-05-20T02:24:20.540Z","comments":1,"photos":[],"link":"","_id":"cl3e0vh750002lae1c5p0o81z","content":"<h3 id=\"记录docker的持续集成-CI-和自动部署-CD\"><a href=\"#记录docker的持续集成-CI-和自动部署-CD\" class=\"headerlink\" title=\"记录docker的持续集成(CI)和自动部署(CD)\"></a>记录docker的持续集成(CI)和自动部署(CD)</h3><h4 id=\"docker-travis实现持续集成-CI\"><a href=\"#docker-travis实现持续集成-CI\" class=\"headerlink\" title=\"docker+travis实现持续集成(CI)\"></a>docker+travis实现持续集成(CI)</h4><p>1.在github新建仓库，加入一个<code>Dockerfile</code>，内容自定义。</p>\n<p>2.在travis中添加这个仓库，登录travis-ci.com，然后登录github选中仓库即可。</p>\n<p>3.使用<code>tavis</code>需要编辑一个<code>.travis.yml</code>，内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">language: bash</span><br><span class=\"line\">dist: xenial</span><br><span class=\"line\">services:</span><br><span class=\"line\">- docker</span><br><span class=\"line\">before_script:</span><br><span class=\"line\">- echo &quot;$DOCKER_PASSWORD&quot; | docker login -u &quot;$DOCKER_USERNAME&quot; --password-stdin</span><br><span class=\"line\">script:</span><br><span class=\"line\">- echo &quot;test code&quot;</span><br><span class=\"line\">after_success:</span><br><span class=\"line\">- docker build -t guoxy/alpine .</span><br><span class=\"line\">- docker push guoxy/alpine</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>这里只是很简单的测试文件，由于我们需要使用<code>docker</code>，所以在<code>serives</code>中天机<code>docker</code>，<code>before_script</code>是在运行之前先登录<code>dockerhub</code>的账号。<br>其中<code>$DOCKER_PASSWORD</code>和<code>DOCKER_USERNAME</code>我们可以在travis选中的这个仓库的settings中添加作为环境变量。<br>我们在持续集成中，一般把需要运行测试的代码添加到script中,以django为例的话，一般执行<code>python manage.py migrate</code>和<code>python manage.py test</code>来运行迁移和执行我们的单元测试代码。在运行成功后即<code>after_success</code>我们重新build了这个镜像，然后推送到我们的<code>dockerhub</code>的仓库。这里我们实现了持续集成，相当于我们每次提交了代码，完成了单元测试，然后travis会自动把我们的代码重新打包成镜像并且推送的我们的<code>dockerhub</code>。然后我们需要做的事是从服务器自动拉取更新过的镜像，然后运行，完成自动部署的部分。</p>\n<h4 id=\"docker-travis实现自动部署\"><a href=\"#docker-travis实现自动部署\" class=\"headerlink\" title=\"docker+travis实现自动部署\"></a>docker+travis实现自动部署</h4><ol>\n<li><p>首先我们要在本机上安装ruby的gem，利用gem安装travis</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install ruby</span><br><span class=\"line\">sudo apt-get install ruby-dev</span><br><span class=\"line\">sudo gem install travis</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>此时可以进行登录，这里卡了一个问题，由于travis-ci有俩网站，所以我们一定要看自己是在<code>travis-ci.org</code>结尾的网站还是<code>travis-ci.com</code>,非常重要，否则后面会出bug，我自己用的就是<code>travis-ci.com</code>，一般也都是这个。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">travis login --com  </span><br><span class=\"line\"></span><br><span class=\"line\">然后输入你的github的账号和密码</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.然后我们需要把我们服务器的私钥传到travis上才能让其远程登录服务器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">travis encrypt-file ~/.ssh/id_rsa --pro --com --add  #com网站后缀,add会把加密的私钥作为环境变量传送到travis的setting中可以查看。</span><br></pre></td></tr></table></figure></p>\n<p>这一步之后我们会发现有了我们之前加入的四个环境变量。<code>.travis.yml</code>的内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">language: bash</span><br><span class=\"line\">dist: xenial</span><br><span class=\"line\">services:</span><br><span class=\"line\">- docker</span><br><span class=\"line\">before_script:</span><br><span class=\"line\">- echo &quot;$DOCKER_PASSWORD&quot; | docker login -u &quot;$DOCKER_USERNAME&quot; --password-stdin</span><br><span class=\"line\">script:</span><br><span class=\"line\">- echo &quot;test code&quot;</span><br><span class=\"line\">after_success:</span><br><span class=\"line\">- docker build -t guoxy/alpine .</span><br><span class=\"line\">- docker push guoxy/alpine</span><br><span class=\"line\">- ssh guoxiaoyang@101.201.68.24 -o StrictHostKeyChecking=no &quot;sh ~/travis-remote/test.sh&quot;</span><br><span class=\"line\">env:</span><br><span class=\"line\">  global:</span><br><span class=\"line\">    secure: jjMhZ/k9Yv+XjeUQxjC1lE2cOPJ8MTgmckJ8M7YCWcIn2u2lb+H+n/2CaTQUjpL3K9Q/OlePKQjioL1Qh2FGxi7x+8p2HpTVXxamrPSXF3DCkNBiWWRcvA8rBrTLztmap45qMyhNyNGxjiOOvS6PnNRjE29BJZd3Lmyu06Y7s/MiwGGrc12frs8m/Z/LahNg+oJeeZQilw795K6/X5gen2aRWaAlsk6c2FKbNU3Gh26ifMwdlgAYZ51Z7W2b610tT9DkV1r/nztLGd+1Y6PSSJUTd9q5R/Nm7xlHPyj9Pwhhyz6yiQ8Px3irKDh3iFBpzH2ylDoUr/9wPIwMsWg2Tb2DoF5LOjvcRVWRoBdOJAiQIdxXN2euPLkJBA/FEv1oPngBOKAljJn+BdKBq5PVGCdXBt8BAdCr8tjvlgT1YJdSFuz9wYZLyX9+WKUbDt5H4QwkMZ0Ro/xFx6u3yPnBf5bCkrgJzkpmLgakckFaU/uHEdp11p+SAQ35n/FVImnZgz9GiHWA6g7lTTvLt7U//KI+ZRT8n39fSDiS378x8ORqqnFcdAMzZAYWr26uVYTS/d6DpHWZlqLrIG0UPhy6+HRZa3U4OfYW4toe1u1SHWn9JuAA9ejFzvn3M4T/PDOcTEx/NsMIfzjsjfabWiPUoQ7Di8Hd6jYBxm+e9gBtYIM=</span><br><span class=\"line\">addons:</span><br><span class=\"line\">- ssh_known_hosts: 101.201.68.24</span><br><span class=\"line\">before_install:</span><br><span class=\"line\">- openssl aes-256-cbc -K $encrypted_78105f82ade5_key -iv $encrypted_78105f82ade5_iv</span><br><span class=\"line\">  -in id_rsa.enc -out ~/.ssh/id_rsa -d</span><br><span class=\"line\">- chmod 600 ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></p>\n<p>因为 travis 第一次登录远程服务器会出现 SSH 主机验证，这边会有一个主机信任问题。官方给出的方案是添加 addons 配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addons:</span><br><span class=\"line\">- ssh_known_hosts: 服务器ip</span><br></pre></td></tr></table></figure></p>\n<p>ssh那一步使我们登录远程服务器，并且执行相应的脚本。<code>-o</code>代表第一次舞曲输入确认的yes选项。</p>\n<p>关于ssh远程免密码登录记录如下:<br>我们本地先生成一对秘钥，默认存放于<code>~/.ssh/</code>，我们把公钥上传至服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id -i ~/.ssh/id_rsa.pub username@ip</span><br><span class=\"line\">然后在服务器端会生成authorized_keys的文件</span><br></pre></td></tr></table></figure></p>\n<p>然后登录即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh username@ip</span><br></pre></td></tr></table></figure></p>\n<p>自己的自动部署的脚本名为<code>test.sh</code>，内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">echo &quot;Hello World&quot;</span><br><span class=\"line\">cat ./.secret | docker login --username &quot;guoxy&quot; --password-stdin</span><br><span class=\"line\">docker stop deploy-test</span><br><span class=\"line\">docker rm $(docker ps -q)</span><br><span class=\"line\">docker container rm deploy-test</span><br><span class=\"line\">docker pull guoxy/ubuntu-with-vi:v1</span><br><span class=\"line\">docker run -it -d --name deploy-test guoxy/ubuntu-with-vi:v1</span><br></pre></td></tr></table></figure></p>\n<p>以上都是用测试的代码，不过也算完整的跑了一遍CI,CD,后面添加自己的web代码，再跑一遍，看看是否有问题。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"记录docker的持续集成-CI-和自动部署-CD\"><a href=\"#记录docker的持续集成-CI-和自动部署-CD\" class=\"headerlink\" title=\"记录docker的持续集成(CI)和自动部署(CD)\"></a>记录docker的持续集成(CI)和自动部署(CD)</h3><h4 id=\"docker-travis实现持续集成-CI\"><a href=\"#docker-travis实现持续集成-CI\" class=\"headerlink\" title=\"docker+travis实现持续集成(CI)\"></a>docker+travis实现持续集成(CI)</h4><p>1.在github新建仓库，加入一个<code>Dockerfile</code>，内容自定义。</p>\n<p>2.在travis中添加这个仓库，登录travis-ci.com，然后登录github选中仓库即可。</p>\n<p>3.使用<code>tavis</code>需要编辑一个<code>.travis.yml</code>，内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">language: bash</span><br><span class=\"line\">dist: xenial</span><br><span class=\"line\">services:</span><br><span class=\"line\">- docker</span><br><span class=\"line\">before_script:</span><br><span class=\"line\">- echo &quot;$DOCKER_PASSWORD&quot; | docker login -u &quot;$DOCKER_USERNAME&quot; --password-stdin</span><br><span class=\"line\">script:</span><br><span class=\"line\">- echo &quot;test code&quot;</span><br><span class=\"line\">after_success:</span><br><span class=\"line\">- docker build -t guoxy/alpine .</span><br><span class=\"line\">- docker push guoxy/alpine</span><br></pre></td></tr></table></figure></p>","more":"<p>这里只是很简单的测试文件，由于我们需要使用<code>docker</code>，所以在<code>serives</code>中天机<code>docker</code>，<code>before_script</code>是在运行之前先登录<code>dockerhub</code>的账号。<br>其中<code>$DOCKER_PASSWORD</code>和<code>DOCKER_USERNAME</code>我们可以在travis选中的这个仓库的settings中添加作为环境变量。<br>我们在持续集成中，一般把需要运行测试的代码添加到script中,以django为例的话，一般执行<code>python manage.py migrate</code>和<code>python manage.py test</code>来运行迁移和执行我们的单元测试代码。在运行成功后即<code>after_success</code>我们重新build了这个镜像，然后推送到我们的<code>dockerhub</code>的仓库。这里我们实现了持续集成，相当于我们每次提交了代码，完成了单元测试，然后travis会自动把我们的代码重新打包成镜像并且推送的我们的<code>dockerhub</code>。然后我们需要做的事是从服务器自动拉取更新过的镜像，然后运行，完成自动部署的部分。</p>\n<h4 id=\"docker-travis实现自动部署\"><a href=\"#docker-travis实现自动部署\" class=\"headerlink\" title=\"docker+travis实现自动部署\"></a>docker+travis实现自动部署</h4><ol>\n<li><p>首先我们要在本机上安装ruby的gem，利用gem安装travis</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install ruby</span><br><span class=\"line\">sudo apt-get install ruby-dev</span><br><span class=\"line\">sudo gem install travis</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>此时可以进行登录，这里卡了一个问题，由于travis-ci有俩网站，所以我们一定要看自己是在<code>travis-ci.org</code>结尾的网站还是<code>travis-ci.com</code>,非常重要，否则后面会出bug，我自己用的就是<code>travis-ci.com</code>，一般也都是这个。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">travis login --com  </span><br><span class=\"line\"></span><br><span class=\"line\">然后输入你的github的账号和密码</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.然后我们需要把我们服务器的私钥传到travis上才能让其远程登录服务器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">travis encrypt-file ~/.ssh/id_rsa --pro --com --add  #com网站后缀,add会把加密的私钥作为环境变量传送到travis的setting中可以查看。</span><br></pre></td></tr></table></figure></p>\n<p>这一步之后我们会发现有了我们之前加入的四个环境变量。<code>.travis.yml</code>的内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">language: bash</span><br><span class=\"line\">dist: xenial</span><br><span class=\"line\">services:</span><br><span class=\"line\">- docker</span><br><span class=\"line\">before_script:</span><br><span class=\"line\">- echo &quot;$DOCKER_PASSWORD&quot; | docker login -u &quot;$DOCKER_USERNAME&quot; --password-stdin</span><br><span class=\"line\">script:</span><br><span class=\"line\">- echo &quot;test code&quot;</span><br><span class=\"line\">after_success:</span><br><span class=\"line\">- docker build -t guoxy/alpine .</span><br><span class=\"line\">- docker push guoxy/alpine</span><br><span class=\"line\">- ssh guoxiaoyang@101.201.68.24 -o StrictHostKeyChecking=no &quot;sh ~/travis-remote/test.sh&quot;</span><br><span class=\"line\">env:</span><br><span class=\"line\">  global:</span><br><span class=\"line\">    secure: jjMhZ/k9Yv+XjeUQxjC1lE2cOPJ8MTgmckJ8M7YCWcIn2u2lb+H+n/2CaTQUjpL3K9Q/OlePKQjioL1Qh2FGxi7x+8p2HpTVXxamrPSXF3DCkNBiWWRcvA8rBrTLztmap45qMyhNyNGxjiOOvS6PnNRjE29BJZd3Lmyu06Y7s/MiwGGrc12frs8m/Z/LahNg+oJeeZQilw795K6/X5gen2aRWaAlsk6c2FKbNU3Gh26ifMwdlgAYZ51Z7W2b610tT9DkV1r/nztLGd+1Y6PSSJUTd9q5R/Nm7xlHPyj9Pwhhyz6yiQ8Px3irKDh3iFBpzH2ylDoUr/9wPIwMsWg2Tb2DoF5LOjvcRVWRoBdOJAiQIdxXN2euPLkJBA/FEv1oPngBOKAljJn+BdKBq5PVGCdXBt8BAdCr8tjvlgT1YJdSFuz9wYZLyX9+WKUbDt5H4QwkMZ0Ro/xFx6u3yPnBf5bCkrgJzkpmLgakckFaU/uHEdp11p+SAQ35n/FVImnZgz9GiHWA6g7lTTvLt7U//KI+ZRT8n39fSDiS378x8ORqqnFcdAMzZAYWr26uVYTS/d6DpHWZlqLrIG0UPhy6+HRZa3U4OfYW4toe1u1SHWn9JuAA9ejFzvn3M4T/PDOcTEx/NsMIfzjsjfabWiPUoQ7Di8Hd6jYBxm+e9gBtYIM=</span><br><span class=\"line\">addons:</span><br><span class=\"line\">- ssh_known_hosts: 101.201.68.24</span><br><span class=\"line\">before_install:</span><br><span class=\"line\">- openssl aes-256-cbc -K $encrypted_78105f82ade5_key -iv $encrypted_78105f82ade5_iv</span><br><span class=\"line\">  -in id_rsa.enc -out ~/.ssh/id_rsa -d</span><br><span class=\"line\">- chmod 600 ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></p>\n<p>因为 travis 第一次登录远程服务器会出现 SSH 主机验证，这边会有一个主机信任问题。官方给出的方案是添加 addons 配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addons:</span><br><span class=\"line\">- ssh_known_hosts: 服务器ip</span><br></pre></td></tr></table></figure></p>\n<p>ssh那一步使我们登录远程服务器，并且执行相应的脚本。<code>-o</code>代表第一次舞曲输入确认的yes选项。</p>\n<p>关于ssh远程免密码登录记录如下:<br>我们本地先生成一对秘钥，默认存放于<code>~/.ssh/</code>，我们把公钥上传至服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id -i ~/.ssh/id_rsa.pub username@ip</span><br><span class=\"line\">然后在服务器端会生成authorized_keys的文件</span><br></pre></td></tr></table></figure></p>\n<p>然后登录即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh username@ip</span><br></pre></td></tr></table></figure></p>\n<p>自己的自动部署的脚本名为<code>test.sh</code>，内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">echo &quot;Hello World&quot;</span><br><span class=\"line\">cat ./.secret | docker login --username &quot;guoxy&quot; --password-stdin</span><br><span class=\"line\">docker stop deploy-test</span><br><span class=\"line\">docker rm $(docker ps -q)</span><br><span class=\"line\">docker container rm deploy-test</span><br><span class=\"line\">docker pull guoxy/ubuntu-with-vi:v1</span><br><span class=\"line\">docker run -it -d --name deploy-test guoxy/ubuntu-with-vi:v1</span><br></pre></td></tr></table></figure></p>\n<p>以上都是用测试的代码，不过也算完整的跑了一遍CI,CD,后面添加自己的web代码，再跑一遍，看看是否有问题。</p>"},{"title":"js的apply函数","date":"2018-12-01T02:33:09.000Z","_content":"## <center>apply call bind</center>\n### 1.apply和call\n在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。\nJS的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。    \n例子：\n```\nfunction fruits() {}\n \nfruits.prototype = {\n    color: \"red\",\n    say: function() {\n        console.log(\"My color is \" + this.color);\n    }\n}\n \nvar apple = new fruits;\napple.say();    //My color is red\n```\n<!-- more -->\n但是如果我们有一个对象banana= {color : \"yellow\"} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法：\n```\nbanana = {\n    color: 'yellow'\n}\napple.say.call(banana); //My color is yellow\napple.say.apply(banana); //My color is yellow\n```\n### 2.apply和call的区别\n对于appl和call而言，作用是一样的，但是接收参数的方式不太一样，例如\n```\nvar func = function (arg1, arg2) {};\n```\n可以通过以下方式来调用\n```\nfunc.call(this.arg1, arg2);\nfunc.apply(this, [arg1, arg2])\n```\n其中this是指定的上下文，可以使任何的JS对象，call需要把参数按顺序传递进去，apply则是把参数放在数组里面。    \nJS中，某个函数的参数量是不确定的，知道数量用call，不确定用apply并且把参数push到数组中。    \n用法如下：\n```\nvar arr1 = [12, 'foo', {'name':'Joe'}, -201];\nvar arr2 = [\"Doe\", 555, 100]\nArray.prototype.push.apply(arr1, arr2)\n/* array1 值为  [12 , \"foo\" , {name \"Joe\"} , -2458 , \"Doe\" , 555 , 100] */\n```\n获取数组的最大最小值\n```\nvar number = [5, 458, 120, -215]\nvar maxInNumber = Math.max.apply(Math, numbers) //458\nvar maxInNumber = Math.max.call(Math, 5, 458, 120, -215) //-215\n```\nnumber本身没有Max方法，但是Math有，我们可以借助call或者apply使用其方法。    \n对于伪数组的使用数组方法\n```\nvar domNodes = Array.prototype.slice.call(document.getElementsByTagName('*'))\n```\nJS存在一种名为伪数组的对象结构，还有像调用getElementByTagName,document.childNodes返回的NodeList都是伪数组，不可以应用Array的push，pop方法。可以通过Array.prototype.slice.apply转化为真正的数组带有length属性的对象。\n### 3.深入理解call和apply\n一个题目，定义一个log方法，去代理console.log方法，常用的解决方案。\n```\nfunction log(msg) {\n    cosole.log(msg)\n}\nlog(1) //1\nlog(1,2) //1\n```\n当传入的参数不确定的时候，上面的方法就失效了，考虑使用apply和call，因为不固定的所以肯定要用apply了，方法如下：\n```\nfunction log() {\n    var args = Array.prototype.slice.call(arguments)\n    console.log.apply(console, args)\n}\nlog(1) //1\n\nlog(1, 2) //1,2\n```\n### 4.bind详解\nMDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n\n直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 _this , that , self 等保存 this ，这样我们可以在改变了上下文之后继续引用到它。 像这样\n```\nvar foo = {\n    bar: 1,\n    eventBind: function() {\n        var _this = this\n        $('.someClass').on('click',function(e){\n            console.log(this.bar) //1\n        })\n    }\n}\n```\n由于 Javascript 特有的机制，上下文环境在 eventBind:function(){ } 过渡到 $('.someClass').on('click',function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题：\n```\nvar foo = {\n    bar: 1,\n    eventBind: function() {\n        $('.someClass').on('click', function(e){\n            console.log(this.bar) //1\n        }).bind(this)\n        \n    }\n}\n```\n在上述代码中，bind绑定了一个函数，当这个click函数被调用的时候，他的this的关键字会被设置成传入的值，这里我们想要传入的参数其实是对象foo到bind函数，当函数执行的时候，this便指向foo对象。\n```\nvar bar = function() {\n    console.log(this.x)\n}\nvar foo = {\n    x:3\n}\nbar() //undefined\nvar func = bar.bind(foo);\nfunc() //3\n```\n那么当我们多bind几次会发生什么现象呢？\n```\nvar bar = function() {\n    caonsole.log(this.x)\n}\nvar foo = {\n    x:3\n}\nvar sed = {\n    x:4\n}\nvar func = bar.bind(foo).bind(sed)\nfunc() //?\nvar five = {\n    x:5\n}\nvar func = bar.bind(foo).bind(sed).bind(five)\nfunc() //?\n```\n两次结果输出都是3，在js中多次bind是无效的\n### 5三者的比较\n```\nvar obj = {\n    x: 81,\n};\n \nvar foo = {\n    getX: function() {\n        return this.x;\n    }\n}\n \nconsole.log(foo.getX.bind(obj)());  //81\nconsole.log(foo.getX.call(obj));    //81\n```\n三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。\n\n也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。\n再总结一下：\n\n- apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；\n- apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；\n- apply 、 call 、bind 三者都可以利用后续参数传参；\nbind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。\n","source":"_posts/apply.mkd","raw":"---\ntitle: js的apply函数\ndate: 2018-12-01 10:33:09\ntags: javascript\ncategories: javascript\n---\n## <center>apply call bind</center>\n### 1.apply和call\n在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。\nJS的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。    \n例子：\n```\nfunction fruits() {}\n \nfruits.prototype = {\n    color: \"red\",\n    say: function() {\n        console.log(\"My color is \" + this.color);\n    }\n}\n \nvar apple = new fruits;\napple.say();    //My color is red\n```\n<!-- more -->\n但是如果我们有一个对象banana= {color : \"yellow\"} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法：\n```\nbanana = {\n    color: 'yellow'\n}\napple.say.call(banana); //My color is yellow\napple.say.apply(banana); //My color is yellow\n```\n### 2.apply和call的区别\n对于appl和call而言，作用是一样的，但是接收参数的方式不太一样，例如\n```\nvar func = function (arg1, arg2) {};\n```\n可以通过以下方式来调用\n```\nfunc.call(this.arg1, arg2);\nfunc.apply(this, [arg1, arg2])\n```\n其中this是指定的上下文，可以使任何的JS对象，call需要把参数按顺序传递进去，apply则是把参数放在数组里面。    \nJS中，某个函数的参数量是不确定的，知道数量用call，不确定用apply并且把参数push到数组中。    \n用法如下：\n```\nvar arr1 = [12, 'foo', {'name':'Joe'}, -201];\nvar arr2 = [\"Doe\", 555, 100]\nArray.prototype.push.apply(arr1, arr2)\n/* array1 值为  [12 , \"foo\" , {name \"Joe\"} , -2458 , \"Doe\" , 555 , 100] */\n```\n获取数组的最大最小值\n```\nvar number = [5, 458, 120, -215]\nvar maxInNumber = Math.max.apply(Math, numbers) //458\nvar maxInNumber = Math.max.call(Math, 5, 458, 120, -215) //-215\n```\nnumber本身没有Max方法，但是Math有，我们可以借助call或者apply使用其方法。    \n对于伪数组的使用数组方法\n```\nvar domNodes = Array.prototype.slice.call(document.getElementsByTagName('*'))\n```\nJS存在一种名为伪数组的对象结构，还有像调用getElementByTagName,document.childNodes返回的NodeList都是伪数组，不可以应用Array的push，pop方法。可以通过Array.prototype.slice.apply转化为真正的数组带有length属性的对象。\n### 3.深入理解call和apply\n一个题目，定义一个log方法，去代理console.log方法，常用的解决方案。\n```\nfunction log(msg) {\n    cosole.log(msg)\n}\nlog(1) //1\nlog(1,2) //1\n```\n当传入的参数不确定的时候，上面的方法就失效了，考虑使用apply和call，因为不固定的所以肯定要用apply了，方法如下：\n```\nfunction log() {\n    var args = Array.prototype.slice.call(arguments)\n    console.log.apply(console, args)\n}\nlog(1) //1\n\nlog(1, 2) //1,2\n```\n### 4.bind详解\nMDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n\n直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 _this , that , self 等保存 this ，这样我们可以在改变了上下文之后继续引用到它。 像这样\n```\nvar foo = {\n    bar: 1,\n    eventBind: function() {\n        var _this = this\n        $('.someClass').on('click',function(e){\n            console.log(this.bar) //1\n        })\n    }\n}\n```\n由于 Javascript 特有的机制，上下文环境在 eventBind:function(){ } 过渡到 $('.someClass').on('click',function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题：\n```\nvar foo = {\n    bar: 1,\n    eventBind: function() {\n        $('.someClass').on('click', function(e){\n            console.log(this.bar) //1\n        }).bind(this)\n        \n    }\n}\n```\n在上述代码中，bind绑定了一个函数，当这个click函数被调用的时候，他的this的关键字会被设置成传入的值，这里我们想要传入的参数其实是对象foo到bind函数，当函数执行的时候，this便指向foo对象。\n```\nvar bar = function() {\n    console.log(this.x)\n}\nvar foo = {\n    x:3\n}\nbar() //undefined\nvar func = bar.bind(foo);\nfunc() //3\n```\n那么当我们多bind几次会发生什么现象呢？\n```\nvar bar = function() {\n    caonsole.log(this.x)\n}\nvar foo = {\n    x:3\n}\nvar sed = {\n    x:4\n}\nvar func = bar.bind(foo).bind(sed)\nfunc() //?\nvar five = {\n    x:5\n}\nvar func = bar.bind(foo).bind(sed).bind(five)\nfunc() //?\n```\n两次结果输出都是3，在js中多次bind是无效的\n### 5三者的比较\n```\nvar obj = {\n    x: 81,\n};\n \nvar foo = {\n    getX: function() {\n        return this.x;\n    }\n}\n \nconsole.log(foo.getX.bind(obj)());  //81\nconsole.log(foo.getX.call(obj));    //81\n```\n三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。\n\n也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。\n再总结一下：\n\n- apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；\n- apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；\n- apply 、 call 、bind 三者都可以利用后续参数传参；\nbind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。\n","slug":"apply","published":1,"updated":"2022-05-20T02:24:20.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7a0003lae1d1jssrc9","content":"<h2 id=\"apply-call-bind\"><a href=\"#apply-call-bind\" class=\"headerlink\" title=\"apply call bind\"></a><center>apply call bind</center></h2><h3 id=\"1-apply和call\"><a href=\"#1-apply和call\" class=\"headerlink\" title=\"1.apply和call\"></a>1.apply和call</h3><p>在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。<br>JS的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。<br>例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fruits() &#123;&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">fruits.prototype = &#123;</span><br><span class=\"line\">    color: &quot;red&quot;,</span><br><span class=\"line\">    say: function() &#123;</span><br><span class=\"line\">        console.log(&quot;My color is &quot; + this.color);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">var apple = new fruits;</span><br><span class=\"line\">apple.say();    //My color is red</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>但是如果我们有一个对象banana= {color : “yellow”} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">banana = &#123;</span><br><span class=\"line\">    color: &apos;yellow&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">apple.say.call(banana); //My color is yellow</span><br><span class=\"line\">apple.say.apply(banana); //My color is yellow</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-apply和call的区别\"><a href=\"#2-apply和call的区别\" class=\"headerlink\" title=\"2.apply和call的区别\"></a>2.apply和call的区别</h3><p>对于appl和call而言，作用是一样的，但是接收参数的方式不太一样，例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var func = function (arg1, arg2) &#123;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>可以通过以下方式来调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func.call(this.arg1, arg2);</span><br><span class=\"line\">func.apply(this, [arg1, arg2])</span><br></pre></td></tr></table></figure></p>\n<p>其中this是指定的上下文，可以使任何的JS对象，call需要把参数按顺序传递进去，apply则是把参数放在数组里面。<br>JS中，某个函数的参数量是不确定的，知道数量用call，不确定用apply并且把参数push到数组中。<br>用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr1 = [12, &apos;foo&apos;, &#123;&apos;name&apos;:&apos;Joe&apos;&#125;, -201];</span><br><span class=\"line\">var arr2 = [&quot;Doe&quot;, 555, 100]</span><br><span class=\"line\">Array.prototype.push.apply(arr1, arr2)</span><br><span class=\"line\">/* array1 值为  [12 , &quot;foo&quot; , &#123;name &quot;Joe&quot;&#125; , -2458 , &quot;Doe&quot; , 555 , 100] */</span><br></pre></td></tr></table></figure></p>\n<p>获取数组的最大最小值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var number = [5, 458, 120, -215]</span><br><span class=\"line\">var maxInNumber = Math.max.apply(Math, numbers) //458</span><br><span class=\"line\">var maxInNumber = Math.max.call(Math, 5, 458, 120, -215) //-215</span><br></pre></td></tr></table></figure></p>\n<p>number本身没有Max方法，但是Math有，我们可以借助call或者apply使用其方法。<br>对于伪数组的使用数组方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var domNodes = Array.prototype.slice.call(document.getElementsByTagName(&apos;*&apos;))</span><br></pre></td></tr></table></figure></p>\n<p>JS存在一种名为伪数组的对象结构，还有像调用getElementByTagName,document.childNodes返回的NodeList都是伪数组，不可以应用Array的push，pop方法。可以通过Array.prototype.slice.apply转化为真正的数组带有length属性的对象。</p>\n<h3 id=\"3-深入理解call和apply\"><a href=\"#3-深入理解call和apply\" class=\"headerlink\" title=\"3.深入理解call和apply\"></a>3.深入理解call和apply</h3><p>一个题目，定义一个log方法，去代理console.log方法，常用的解决方案。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log(msg) &#123;</span><br><span class=\"line\">    cosole.log(msg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(1) //1</span><br><span class=\"line\">log(1,2) //1</span><br></pre></td></tr></table></figure></p>\n<p>当传入的参数不确定的时候，上面的方法就失效了，考虑使用apply和call，因为不固定的所以肯定要用apply了，方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log() &#123;</span><br><span class=\"line\">    var args = Array.prototype.slice.call(arguments)</span><br><span class=\"line\">    console.log.apply(console, args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(1) //1</span><br><span class=\"line\"></span><br><span class=\"line\">log(1, 2) //1,2</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-bind详解\"><a href=\"#4-bind详解\" class=\"headerlink\" title=\"4.bind详解\"></a>4.bind详解</h3><p>MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>\n<p>直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 _this , that , self 等保存 this ，这样我们可以在改变了上下文之后继续引用到它。 像这样<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var foo = &#123;</span><br><span class=\"line\">    bar: 1,</span><br><span class=\"line\">    eventBind: function() &#123;</span><br><span class=\"line\">        var _this = this</span><br><span class=\"line\">        $(&apos;.someClass&apos;).on(&apos;click&apos;,function(e)&#123;</span><br><span class=\"line\">            console.log(this.bar) //1</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于 Javascript 特有的机制，上下文环境在 eventBind:function(){ } 过渡到 $(‘.someClass’).on(‘click’,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var foo = &#123;</span><br><span class=\"line\">    bar: 1,</span><br><span class=\"line\">    eventBind: function() &#123;</span><br><span class=\"line\">        $(&apos;.someClass&apos;).on(&apos;click&apos;, function(e)&#123;</span><br><span class=\"line\">            console.log(this.bar) //1</span><br><span class=\"line\">        &#125;).bind(this)</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上述代码中，bind绑定了一个函数，当这个click函数被调用的时候，他的this的关键字会被设置成传入的值，这里我们想要传入的参数其实是对象foo到bind函数，当函数执行的时候，this便指向foo对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var bar = function() &#123;</span><br><span class=\"line\">    console.log(this.x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var foo = &#123;</span><br><span class=\"line\">    x:3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar() //undefined</span><br><span class=\"line\">var func = bar.bind(foo);</span><br><span class=\"line\">func() //3</span><br></pre></td></tr></table></figure></p>\n<p>那么当我们多bind几次会发生什么现象呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var bar = function() &#123;</span><br><span class=\"line\">    caonsole.log(this.x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var foo = &#123;</span><br><span class=\"line\">    x:3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var sed = &#123;</span><br><span class=\"line\">    x:4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var func = bar.bind(foo).bind(sed)</span><br><span class=\"line\">func() //?</span><br><span class=\"line\">var five = &#123;</span><br><span class=\"line\">    x:5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var func = bar.bind(foo).bind(sed).bind(five)</span><br><span class=\"line\">func() //?</span><br></pre></td></tr></table></figure></p>\n<p>两次结果输出都是3，在js中多次bind是无效的</p>\n<h3 id=\"5三者的比较\"><a href=\"#5三者的比较\" class=\"headerlink\" title=\"5三者的比较\"></a>5三者的比较</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 81,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">var foo = &#123;</span><br><span class=\"line\">    getX: function() &#123;</span><br><span class=\"line\">        return this.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(foo.getX.bind(obj)());  //81</span><br><span class=\"line\">console.log(foo.getX.call(obj));    //81</span><br></pre></td></tr></table></figure>\n<p>三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。</p>\n<p>也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。<br>再总结一下：</p>\n<ul>\n<li>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</li>\n<li>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；</li>\n<li>apply 、 call 、bind 三者都可以利用后续参数传参；<br>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"apply-call-bind\"><a href=\"#apply-call-bind\" class=\"headerlink\" title=\"apply call bind\"></a><center>apply call bind</center></h2><h3 id=\"1-apply和call\"><a href=\"#1-apply和call\" class=\"headerlink\" title=\"1.apply和call\"></a>1.apply和call</h3><p>在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。<br>JS的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。<br>例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fruits() &#123;&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">fruits.prototype = &#123;</span><br><span class=\"line\">    color: &quot;red&quot;,</span><br><span class=\"line\">    say: function() &#123;</span><br><span class=\"line\">        console.log(&quot;My color is &quot; + this.color);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">var apple = new fruits;</span><br><span class=\"line\">apple.say();    //My color is red</span><br></pre></td></tr></table></figure></p>","more":"<p>但是如果我们有一个对象banana= {color : “yellow”} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">banana = &#123;</span><br><span class=\"line\">    color: &apos;yellow&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">apple.say.call(banana); //My color is yellow</span><br><span class=\"line\">apple.say.apply(banana); //My color is yellow</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-apply和call的区别\"><a href=\"#2-apply和call的区别\" class=\"headerlink\" title=\"2.apply和call的区别\"></a>2.apply和call的区别</h3><p>对于appl和call而言，作用是一样的，但是接收参数的方式不太一样，例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var func = function (arg1, arg2) &#123;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>可以通过以下方式来调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func.call(this.arg1, arg2);</span><br><span class=\"line\">func.apply(this, [arg1, arg2])</span><br></pre></td></tr></table></figure></p>\n<p>其中this是指定的上下文，可以使任何的JS对象，call需要把参数按顺序传递进去，apply则是把参数放在数组里面。<br>JS中，某个函数的参数量是不确定的，知道数量用call，不确定用apply并且把参数push到数组中。<br>用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr1 = [12, &apos;foo&apos;, &#123;&apos;name&apos;:&apos;Joe&apos;&#125;, -201];</span><br><span class=\"line\">var arr2 = [&quot;Doe&quot;, 555, 100]</span><br><span class=\"line\">Array.prototype.push.apply(arr1, arr2)</span><br><span class=\"line\">/* array1 值为  [12 , &quot;foo&quot; , &#123;name &quot;Joe&quot;&#125; , -2458 , &quot;Doe&quot; , 555 , 100] */</span><br></pre></td></tr></table></figure></p>\n<p>获取数组的最大最小值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var number = [5, 458, 120, -215]</span><br><span class=\"line\">var maxInNumber = Math.max.apply(Math, numbers) //458</span><br><span class=\"line\">var maxInNumber = Math.max.call(Math, 5, 458, 120, -215) //-215</span><br></pre></td></tr></table></figure></p>\n<p>number本身没有Max方法，但是Math有，我们可以借助call或者apply使用其方法。<br>对于伪数组的使用数组方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var domNodes = Array.prototype.slice.call(document.getElementsByTagName(&apos;*&apos;))</span><br></pre></td></tr></table></figure></p>\n<p>JS存在一种名为伪数组的对象结构，还有像调用getElementByTagName,document.childNodes返回的NodeList都是伪数组，不可以应用Array的push，pop方法。可以通过Array.prototype.slice.apply转化为真正的数组带有length属性的对象。</p>\n<h3 id=\"3-深入理解call和apply\"><a href=\"#3-深入理解call和apply\" class=\"headerlink\" title=\"3.深入理解call和apply\"></a>3.深入理解call和apply</h3><p>一个题目，定义一个log方法，去代理console.log方法，常用的解决方案。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log(msg) &#123;</span><br><span class=\"line\">    cosole.log(msg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(1) //1</span><br><span class=\"line\">log(1,2) //1</span><br></pre></td></tr></table></figure></p>\n<p>当传入的参数不确定的时候，上面的方法就失效了，考虑使用apply和call，因为不固定的所以肯定要用apply了，方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log() &#123;</span><br><span class=\"line\">    var args = Array.prototype.slice.call(arguments)</span><br><span class=\"line\">    console.log.apply(console, args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(1) //1</span><br><span class=\"line\"></span><br><span class=\"line\">log(1, 2) //1,2</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-bind详解\"><a href=\"#4-bind详解\" class=\"headerlink\" title=\"4.bind详解\"></a>4.bind详解</h3><p>MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>\n<p>直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 _this , that , self 等保存 this ，这样我们可以在改变了上下文之后继续引用到它。 像这样<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var foo = &#123;</span><br><span class=\"line\">    bar: 1,</span><br><span class=\"line\">    eventBind: function() &#123;</span><br><span class=\"line\">        var _this = this</span><br><span class=\"line\">        $(&apos;.someClass&apos;).on(&apos;click&apos;,function(e)&#123;</span><br><span class=\"line\">            console.log(this.bar) //1</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于 Javascript 特有的机制，上下文环境在 eventBind:function(){ } 过渡到 $(‘.someClass’).on(‘click’,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var foo = &#123;</span><br><span class=\"line\">    bar: 1,</span><br><span class=\"line\">    eventBind: function() &#123;</span><br><span class=\"line\">        $(&apos;.someClass&apos;).on(&apos;click&apos;, function(e)&#123;</span><br><span class=\"line\">            console.log(this.bar) //1</span><br><span class=\"line\">        &#125;).bind(this)</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上述代码中，bind绑定了一个函数，当这个click函数被调用的时候，他的this的关键字会被设置成传入的值，这里我们想要传入的参数其实是对象foo到bind函数，当函数执行的时候，this便指向foo对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var bar = function() &#123;</span><br><span class=\"line\">    console.log(this.x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var foo = &#123;</span><br><span class=\"line\">    x:3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar() //undefined</span><br><span class=\"line\">var func = bar.bind(foo);</span><br><span class=\"line\">func() //3</span><br></pre></td></tr></table></figure></p>\n<p>那么当我们多bind几次会发生什么现象呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var bar = function() &#123;</span><br><span class=\"line\">    caonsole.log(this.x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var foo = &#123;</span><br><span class=\"line\">    x:3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var sed = &#123;</span><br><span class=\"line\">    x:4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var func = bar.bind(foo).bind(sed)</span><br><span class=\"line\">func() //?</span><br><span class=\"line\">var five = &#123;</span><br><span class=\"line\">    x:5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var func = bar.bind(foo).bind(sed).bind(five)</span><br><span class=\"line\">func() //?</span><br></pre></td></tr></table></figure></p>\n<p>两次结果输出都是3，在js中多次bind是无效的</p>\n<h3 id=\"5三者的比较\"><a href=\"#5三者的比较\" class=\"headerlink\" title=\"5三者的比较\"></a>5三者的比较</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    x: 81,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">var foo = &#123;</span><br><span class=\"line\">    getX: function() &#123;</span><br><span class=\"line\">        return this.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(foo.getX.bind(obj)());  //81</span><br><span class=\"line\">console.log(foo.getX.call(obj));    //81</span><br></pre></td></tr></table></figure>\n<p>三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。</p>\n<p>也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。<br>再总结一下：</p>\n<ul>\n<li>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</li>\n<li>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；</li>\n<li>apply 、 call 、bind 三者都可以利用后续参数传参；<br>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</li>\n</ul>"},{"title":"es6的Objects函数","date":"2018-12-15T02:33:09.000Z","_content":"\n## <center>对象的扩展</center>\n\n### 1.es6允许在对象之中直接书写变量    \n\n- 例一    \n\n```\nfunction f(x, y) {\n    return {x ,y}\n}\n//等同于\nfunction f(x, y) {\n    return {x: x, y: y}\n}\nf(1, 2) // Object {x :1, y:2}\n```\n - 例二    \n\n ```\n let birth = '200/01/01'\n const Person = {\n    'name': '张三',\n    birth, //等同于birth: birth\n    //等同于hello: f()\n    hello() {console.log('我的名字是:', this.name)}\n }\n ```\n<!--more -->\n ####2.属性名表达式    \n - 例一\n\n```\nlet propKey = 'foo'\nlet obj = {\n    [propKey]: true,\n    ['a' + 'bc']: 123\n}\nobj.abc //123\nobj.foo //true\nobj[propKey] //true\n```\n### 属性的可枚举性和遍历\n\n - 可枚举性\n\n对象的每个属性都有一个描述对象(Descriptor)，用来控制该属性的行为，Object.getOwnPropertyDescriptor方法可以获得该属性的描述对象。    \n```\nlet obj = {foo: 123}\nObject.getOwnPropertyDescriptor(obj, 'foo')\n//\n{\n    value: 123,\n    writeable: true,\n    enumerable: true,\n    configurable: true\n}\n```\nes6共有5种方法可以遍历对象的属性    \n - for ... in\n - Object.keys(obj)\n - OBject.getOwnPropertyNames(obj)\n - OBject.getOwnPropertySymbols(obj)\n - Reflect.ownKeys(obj)\n","source":"_posts/Objects.mkd","raw":"---\ntitle: es6的Objects函数\ndate: 2018-12-15 10:33:09\ntags: javascript\ncategories: javascript\n---\n\n## <center>对象的扩展</center>\n\n### 1.es6允许在对象之中直接书写变量    \n\n- 例一    \n\n```\nfunction f(x, y) {\n    return {x ,y}\n}\n//等同于\nfunction f(x, y) {\n    return {x: x, y: y}\n}\nf(1, 2) // Object {x :1, y:2}\n```\n - 例二    \n\n ```\n let birth = '200/01/01'\n const Person = {\n    'name': '张三',\n    birth, //等同于birth: birth\n    //等同于hello: f()\n    hello() {console.log('我的名字是:', this.name)}\n }\n ```\n<!--more -->\n ####2.属性名表达式    \n - 例一\n\n```\nlet propKey = 'foo'\nlet obj = {\n    [propKey]: true,\n    ['a' + 'bc']: 123\n}\nobj.abc //123\nobj.foo //true\nobj[propKey] //true\n```\n### 属性的可枚举性和遍历\n\n - 可枚举性\n\n对象的每个属性都有一个描述对象(Descriptor)，用来控制该属性的行为，Object.getOwnPropertyDescriptor方法可以获得该属性的描述对象。    \n```\nlet obj = {foo: 123}\nObject.getOwnPropertyDescriptor(obj, 'foo')\n//\n{\n    value: 123,\n    writeable: true,\n    enumerable: true,\n    configurable: true\n}\n```\nes6共有5种方法可以遍历对象的属性    \n - for ... in\n - Object.keys(obj)\n - OBject.getOwnPropertyNames(obj)\n - OBject.getOwnPropertySymbols(obj)\n - Reflect.ownKeys(obj)\n","slug":"Objects","published":1,"updated":"2022-05-20T02:24:20.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7b0006lae19taj14fv","content":"<h2 id=\"对象的扩展\"><a href=\"#对象的扩展\" class=\"headerlink\" title=\"对象的扩展\"></a><center>对象的扩展</center></h2><h3 id=\"1-es6允许在对象之中直接书写变量\"><a href=\"#1-es6允许在对象之中直接书写变量\" class=\"headerlink\" title=\"1.es6允许在对象之中直接书写变量\"></a>1.es6允许在对象之中直接书写变量</h3><ul>\n<li>例一    </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(x, y) &#123;</span><br><span class=\"line\">    return &#123;x ,y&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//等同于</span><br><span class=\"line\">function f(x, y) &#123;</span><br><span class=\"line\">    return &#123;x: x, y: y&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(1, 2) // Object &#123;x :1, y:2&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>例二    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let birth = &apos;200/01/01&apos;</span><br><span class=\"line\">const Person = &#123;</span><br><span class=\"line\">   &apos;name&apos;: &apos;张三&apos;,</span><br><span class=\"line\">   birth, //等同于birth: birth</span><br><span class=\"line\">   //等同于hello: f()</span><br><span class=\"line\">   hello() &#123;console.log(&apos;我的名字是:&apos;, this.name)&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<a id=\"more\"></a>\n<p> ####2.属性名表达式    </p>\n<ul>\n<li>例一</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let propKey = &apos;foo&apos;</span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    [propKey]: true,</span><br><span class=\"line\">    [&apos;a&apos; + &apos;bc&apos;]: 123</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.abc //123</span><br><span class=\"line\">obj.foo //true</span><br><span class=\"line\">obj[propKey] //true</span><br></pre></td></tr></table></figure>\n<h3 id=\"属性的可枚举性和遍历\"><a href=\"#属性的可枚举性和遍历\" class=\"headerlink\" title=\"属性的可枚举性和遍历\"></a>属性的可枚举性和遍历</h3><ul>\n<li>可枚举性</li>\n</ul>\n<p>对象的每个属性都有一个描述对象(Descriptor)，用来控制该属性的行为，Object.getOwnPropertyDescriptor方法可以获得该属性的描述对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;foo: 123&#125;</span><br><span class=\"line\">Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)</span><br><span class=\"line\">//</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    value: 123,</span><br><span class=\"line\">    writeable: true,</span><br><span class=\"line\">    enumerable: true,</span><br><span class=\"line\">    configurable: true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>es6共有5种方法可以遍历对象的属性    </p>\n<ul>\n<li>for … in</li>\n<li>Object.keys(obj)</li>\n<li>OBject.getOwnPropertyNames(obj)</li>\n<li>OBject.getOwnPropertySymbols(obj)</li>\n<li>Reflect.ownKeys(obj)</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"对象的扩展\"><a href=\"#对象的扩展\" class=\"headerlink\" title=\"对象的扩展\"></a><center>对象的扩展</center></h2><h3 id=\"1-es6允许在对象之中直接书写变量\"><a href=\"#1-es6允许在对象之中直接书写变量\" class=\"headerlink\" title=\"1.es6允许在对象之中直接书写变量\"></a>1.es6允许在对象之中直接书写变量</h3><ul>\n<li>例一    </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(x, y) &#123;</span><br><span class=\"line\">    return &#123;x ,y&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//等同于</span><br><span class=\"line\">function f(x, y) &#123;</span><br><span class=\"line\">    return &#123;x: x, y: y&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(1, 2) // Object &#123;x :1, y:2&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>例二    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let birth = &apos;200/01/01&apos;</span><br><span class=\"line\">const Person = &#123;</span><br><span class=\"line\">   &apos;name&apos;: &apos;张三&apos;,</span><br><span class=\"line\">   birth, //等同于birth: birth</span><br><span class=\"line\">   //等同于hello: f()</span><br><span class=\"line\">   hello() &#123;console.log(&apos;我的名字是:&apos;, this.name)&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>","more":"<p> ####2.属性名表达式    </p>\n<ul>\n<li>例一</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let propKey = &apos;foo&apos;</span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    [propKey]: true,</span><br><span class=\"line\">    [&apos;a&apos; + &apos;bc&apos;]: 123</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.abc //123</span><br><span class=\"line\">obj.foo //true</span><br><span class=\"line\">obj[propKey] //true</span><br></pre></td></tr></table></figure>\n<h3 id=\"属性的可枚举性和遍历\"><a href=\"#属性的可枚举性和遍历\" class=\"headerlink\" title=\"属性的可枚举性和遍历\"></a>属性的可枚举性和遍历</h3><ul>\n<li>可枚举性</li>\n</ul>\n<p>对象的每个属性都有一个描述对象(Descriptor)，用来控制该属性的行为，Object.getOwnPropertyDescriptor方法可以获得该属性的描述对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;foo: 123&#125;</span><br><span class=\"line\">Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)</span><br><span class=\"line\">//</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    value: 123,</span><br><span class=\"line\">    writeable: true,</span><br><span class=\"line\">    enumerable: true,</span><br><span class=\"line\">    configurable: true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>es6共有5种方法可以遍历对象的属性    </p>\n<ul>\n<li>for … in</li>\n<li>Object.keys(obj)</li>\n<li>OBject.getOwnPropertyNames(obj)</li>\n<li>OBject.getOwnPropertySymbols(obj)</li>\n<li>Reflect.ownKeys(obj)</li>\n</ul>"},{"title":"2018总结","date":"2018-12-29T02:33:07.000Z","_content":"2018年已经接近尾声了，我觉得有必要总结一下自己这一年来的经历吧，每年结束的时候，我总会想起曾经看过的一个人的签名。    \n`这一年来我们得到了什么，又失去了多少。`\n<!-- more -->\n#### <center>学习的总结</center>    \n大概在去年的时候，那时候在寒假，还是会做一些网页端统计的功能。那时候觉得很无聊，当然能力也很弱，只能做一些简单的功能。寒假结束之后，应该是完善公司网页端的一些界面吧。相对来说，对于`django`更熟悉了一些，对于python的使用也更熟悉了一些。在9月之前吧，当时我确实不知道自己要什么，我也想找一个方向，前端？后端？但是我发现自己实在是会的太少了。那段时间我又想做数据分析，又借了数据分析的书，之前说毕设会做一些大数据方面的工作，稍微看了hadoop，不过一知半解而已，只是看了一部分，后面接到了别的任务也就没继续了。大概在七八月份的时候，我又想重新进阶一下python吧，那时候买了一本书`流畅的python`，虽然电子版的有，但我讨厌电子书，我不喜欢总是对着屏幕，所以买了一本吧。这本书可以说真的很不错，从中学到了很多，包括函数的闭包的理解，闭包是之延伸了函数的作用域，可以访问到其它函数的变量，而这个变量并非是全局变量。其他的包括字典生成式，列表生成式，字典如何构建，什么是散列表等等。目前还没读完，还有第五章和第六章吧，后面会继续把他读完。    \n在这个节点大概10月份了，这是有新的项目，风力发电的前端页面的展示，讨论时说过前端需要处理挺多的逻辑，分担后端的压力。当时前段我会的很少，公司的项目都是用的jquery+bootstrap，css只能说勉强会用。当时如果逻辑放到前端，那么jquery并非不可以实现，但是肯定会有大量的$符号就不说了，操作dom也太多次了。我当时也在知乎上浏览了很多文章，再次之前说实话，我听说过vue，angular，react。那时候我每天在想怎么去实现呢，现在想来，想得再多，不动手去做都是徒劳。然后我选择vue这个框架吧，相对来说，技术上过度比较平缓，一开始的话，我觉得挺难用的。后来，只能真香了。说来，vue主要的也是双向绑定了，而且将数据与视图分离，现在看起来真的清爽不少，方法有单独的地方写，不至于代码结构混乱。如果jquery的，我觉得界面还是比较乱的。当时差不多做了一个月，简单界面搭建基本完成，能够使用vue做一些项目了，但是vue的slot这部分我没有深入了解。后面又看了一点es6的语法，买了本vue.js的书籍，这本书看完了，但我感觉提升也就一般。不过跟着书中的例子搭建知乎日报的建立，由于知乎日报的接口挂了，有的文章显示不出。不过这个例子比较简单。后面有个仿饿了么的学习例子，这个例子挺好的，做了一部分。总的来说这段时间能够使用vue来完成前端的工作，但没有仔细深入，但我觉得这种mvvm架构确实很方便。    \n后面，我的同学应该也在某方面的项目，用到了docker，然后在一次报告上讲述了应用。后面，老师也让我们的项目部署在docker中。于是花了些时间学习docker，docker确实挺好的，将环境与外部隔离，需要什么装什么，在用的时候也会遇到一些问题，例如挂载，端口映射之类吧，主要是每次构件错了的话，重写dockerfile略微麻烦，docker commit 似乎不是标准的做法。    \n那差不多十二月了，这时候公司的事情需要做一些了，完善tcp的测试吧。说实话当时我很头痛，因为没接触过socket编程与tcp协议的编写，我很害怕自己做不出来。之前的tcp有份代码我的老师已经写好了，我大概了花了3-5天对着协议把代码全部读了一遍，并且手动敲了一遍加上注释。当我再回过头来，也明白了这些代码的用途和使用吧，对于新的tcp协议，我也可以编写了，并且搭建了测试的服务器。从这时候开始，我觉得多学习一下后端了，相对于前端，我认为我更喜欢后端多一些，因为我不喜欢写css，好麻烦。这段时间我也看了mysql的使用，公司使用的pq，但是数据库语言都是产不多的。虽说公司用的pq,但是查询语言都是django的封装好的查询语言，所以我觉得有必要学习一下mysql，包括后续的风力发电的数据库肯定也会弃用sqlite而转到pq，这是我的想法吧。     \n这一年来，进步还是有一点点，当时我觉的差的好多，有时候我总觉得很无力，出来混总要还的吧，做好自己现在的而努力追求更高的，是当下应该做的。    \n\n#### <center>生活的总结</center>\n\n说实话，当初选择西安，我当初是想一个人，而且西安是一座旅游城市，我可以经常出去逛，现在想想只觉得自己年轻。从我来到西安，因为基础比较差，我当时真的很难受，同学有，但是并非所有事情可以倾诉。那时候我才感觉一个人无助的感觉是有多么落寞。后来慢慢的吧，能做一些了，才会积累起一些自信。六月份的时候，我的高中同学来找我，然后我们去了华清池等地方，只能说我的朋友带我浏览的西安，但是我还是很开心的，自己来了西安那么久，到现在我也没去过兵马俑。。。    \n来了西安一年半多有了吧，现在研二上学期快结束了，大约研一还呆在实验室，研二上学期开始待在公司这边，但是就我一个人，为了占工位，我觉得自己越来越一个人，有利也有弊，我怕自己管不住自己，老是玩游戏，有过一段这个时间，那一周啥也没做，内心的愧疚吧。但是，好处是没有人打扰，我想多久回就多久回，正常来说，冬天好冷的情况下，晚上八点工作，到十一点半左右回去吧。这边创新咖啡街区晚上的夜景其实还不错。晚上人还挺多的。一个人的坏处还有就是太宅了，以至于我不知道要去干什么，难道只能对着电脑吗？我现在感觉很少与人交流，虽然我本身不善言辞，但我感觉更善于倾听了吧，但是如果熟悉了之后我觉得还是话挺多的吧。    \n每当我对比其他人，我的基础是最差的，但是也要慢慢提升嘛，就像昨天的聚餐，曾老师的一句话大致的意思是这样，`遇到困难或者不会的事情只要去解决，就会发现它没那么难，你不会，总有人会`，这句话对于学习中我觉得还是很适用的，遇到问题如果就下定决心去解决它，回头发现自己又会进步一点点。如果让我选择，读研来说还是正确的选择。无论别人怎么认为我，我觉得到了更大的平台，自己周围的人和事情都会变的不一样，我觉得最主要的一点是学会了如何学习？而并非是把事件花费在很多没有意义的事情上，我还是很佩服我的老师的，因为我觉得首先他很厉害，我觉得他什么都会，智商又高，又可以指导我。我印象比较深的是在一次晚上我提交了代码后，老师给我的评注大概在12点40左右吧，那也快一点了，因为今年来说老师比较忙，那时候我觉得已经十二点多了，还在工作，好辛苦的说。还有一次是早晨七点多也就接到了代码的评注，起得好早啊。感触挺深的吧，真的很佩服齐老师啊。    \n无论自己处于什么位置，也不能放弃向上的姿态吧。有一句话是这么说的，人比人之间的差距，比人和狗之间的差距还大。深有体会吧，但是并不代表自己放弃了什么，我认为做好自己的，然后进步是自己的方式，而并非处于差距之下而无法自拔。毕竟行拂乱其所为，所以动心忍性，增益其所不能。脚踏实地再是最重要的，而并非眼高手低。    \n\n#### <center>2019规划</center>\n\n总结完了，还要展望新的一年啊。资本的寒冬来临了，提示自己变得越来越紧迫，现制定几个小目标吧。\n\n- 阅读完流畅的python一书\n- mysql的使用，书籍的阅读\n- 学习一门nosql\n- 计算机网络的了解，tcp/ip协议的阅读\n- 后端技能树的获取以及学习，例如redis\n- linux shell的编写，能够熟练的编写一些脚本，更加自动化。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2018总结.md","raw":"---\ntitle: 2018总结\ndate: 2018-12-29 10:33:07\ntags: 生活\ncategories: 生活\n---\n2018年已经接近尾声了，我觉得有必要总结一下自己这一年来的经历吧，每年结束的时候，我总会想起曾经看过的一个人的签名。    \n`这一年来我们得到了什么，又失去了多少。`\n<!-- more -->\n#### <center>学习的总结</center>    \n大概在去年的时候，那时候在寒假，还是会做一些网页端统计的功能。那时候觉得很无聊，当然能力也很弱，只能做一些简单的功能。寒假结束之后，应该是完善公司网页端的一些界面吧。相对来说，对于`django`更熟悉了一些，对于python的使用也更熟悉了一些。在9月之前吧，当时我确实不知道自己要什么，我也想找一个方向，前端？后端？但是我发现自己实在是会的太少了。那段时间我又想做数据分析，又借了数据分析的书，之前说毕设会做一些大数据方面的工作，稍微看了hadoop，不过一知半解而已，只是看了一部分，后面接到了别的任务也就没继续了。大概在七八月份的时候，我又想重新进阶一下python吧，那时候买了一本书`流畅的python`，虽然电子版的有，但我讨厌电子书，我不喜欢总是对着屏幕，所以买了一本吧。这本书可以说真的很不错，从中学到了很多，包括函数的闭包的理解，闭包是之延伸了函数的作用域，可以访问到其它函数的变量，而这个变量并非是全局变量。其他的包括字典生成式，列表生成式，字典如何构建，什么是散列表等等。目前还没读完，还有第五章和第六章吧，后面会继续把他读完。    \n在这个节点大概10月份了，这是有新的项目，风力发电的前端页面的展示，讨论时说过前端需要处理挺多的逻辑，分担后端的压力。当时前段我会的很少，公司的项目都是用的jquery+bootstrap，css只能说勉强会用。当时如果逻辑放到前端，那么jquery并非不可以实现，但是肯定会有大量的$符号就不说了，操作dom也太多次了。我当时也在知乎上浏览了很多文章，再次之前说实话，我听说过vue，angular，react。那时候我每天在想怎么去实现呢，现在想来，想得再多，不动手去做都是徒劳。然后我选择vue这个框架吧，相对来说，技术上过度比较平缓，一开始的话，我觉得挺难用的。后来，只能真香了。说来，vue主要的也是双向绑定了，而且将数据与视图分离，现在看起来真的清爽不少，方法有单独的地方写，不至于代码结构混乱。如果jquery的，我觉得界面还是比较乱的。当时差不多做了一个月，简单界面搭建基本完成，能够使用vue做一些项目了，但是vue的slot这部分我没有深入了解。后面又看了一点es6的语法，买了本vue.js的书籍，这本书看完了，但我感觉提升也就一般。不过跟着书中的例子搭建知乎日报的建立，由于知乎日报的接口挂了，有的文章显示不出。不过这个例子比较简单。后面有个仿饿了么的学习例子，这个例子挺好的，做了一部分。总的来说这段时间能够使用vue来完成前端的工作，但没有仔细深入，但我觉得这种mvvm架构确实很方便。    \n后面，我的同学应该也在某方面的项目，用到了docker，然后在一次报告上讲述了应用。后面，老师也让我们的项目部署在docker中。于是花了些时间学习docker，docker确实挺好的，将环境与外部隔离，需要什么装什么，在用的时候也会遇到一些问题，例如挂载，端口映射之类吧，主要是每次构件错了的话，重写dockerfile略微麻烦，docker commit 似乎不是标准的做法。    \n那差不多十二月了，这时候公司的事情需要做一些了，完善tcp的测试吧。说实话当时我很头痛，因为没接触过socket编程与tcp协议的编写，我很害怕自己做不出来。之前的tcp有份代码我的老师已经写好了，我大概了花了3-5天对着协议把代码全部读了一遍，并且手动敲了一遍加上注释。当我再回过头来，也明白了这些代码的用途和使用吧，对于新的tcp协议，我也可以编写了，并且搭建了测试的服务器。从这时候开始，我觉得多学习一下后端了，相对于前端，我认为我更喜欢后端多一些，因为我不喜欢写css，好麻烦。这段时间我也看了mysql的使用，公司使用的pq，但是数据库语言都是产不多的。虽说公司用的pq,但是查询语言都是django的封装好的查询语言，所以我觉得有必要学习一下mysql，包括后续的风力发电的数据库肯定也会弃用sqlite而转到pq，这是我的想法吧。     \n这一年来，进步还是有一点点，当时我觉的差的好多，有时候我总觉得很无力，出来混总要还的吧，做好自己现在的而努力追求更高的，是当下应该做的。    \n\n#### <center>生活的总结</center>\n\n说实话，当初选择西安，我当初是想一个人，而且西安是一座旅游城市，我可以经常出去逛，现在想想只觉得自己年轻。从我来到西安，因为基础比较差，我当时真的很难受，同学有，但是并非所有事情可以倾诉。那时候我才感觉一个人无助的感觉是有多么落寞。后来慢慢的吧，能做一些了，才会积累起一些自信。六月份的时候，我的高中同学来找我，然后我们去了华清池等地方，只能说我的朋友带我浏览的西安，但是我还是很开心的，自己来了西安那么久，到现在我也没去过兵马俑。。。    \n来了西安一年半多有了吧，现在研二上学期快结束了，大约研一还呆在实验室，研二上学期开始待在公司这边，但是就我一个人，为了占工位，我觉得自己越来越一个人，有利也有弊，我怕自己管不住自己，老是玩游戏，有过一段这个时间，那一周啥也没做，内心的愧疚吧。但是，好处是没有人打扰，我想多久回就多久回，正常来说，冬天好冷的情况下，晚上八点工作，到十一点半左右回去吧。这边创新咖啡街区晚上的夜景其实还不错。晚上人还挺多的。一个人的坏处还有就是太宅了，以至于我不知道要去干什么，难道只能对着电脑吗？我现在感觉很少与人交流，虽然我本身不善言辞，但我感觉更善于倾听了吧，但是如果熟悉了之后我觉得还是话挺多的吧。    \n每当我对比其他人，我的基础是最差的，但是也要慢慢提升嘛，就像昨天的聚餐，曾老师的一句话大致的意思是这样，`遇到困难或者不会的事情只要去解决，就会发现它没那么难，你不会，总有人会`，这句话对于学习中我觉得还是很适用的，遇到问题如果就下定决心去解决它，回头发现自己又会进步一点点。如果让我选择，读研来说还是正确的选择。无论别人怎么认为我，我觉得到了更大的平台，自己周围的人和事情都会变的不一样，我觉得最主要的一点是学会了如何学习？而并非是把事件花费在很多没有意义的事情上，我还是很佩服我的老师的，因为我觉得首先他很厉害，我觉得他什么都会，智商又高，又可以指导我。我印象比较深的是在一次晚上我提交了代码后，老师给我的评注大概在12点40左右吧，那也快一点了，因为今年来说老师比较忙，那时候我觉得已经十二点多了，还在工作，好辛苦的说。还有一次是早晨七点多也就接到了代码的评注，起得好早啊。感触挺深的吧，真的很佩服齐老师啊。    \n无论自己处于什么位置，也不能放弃向上的姿态吧。有一句话是这么说的，人比人之间的差距，比人和狗之间的差距还大。深有体会吧，但是并不代表自己放弃了什么，我认为做好自己的，然后进步是自己的方式，而并非处于差距之下而无法自拔。毕竟行拂乱其所为，所以动心忍性，增益其所不能。脚踏实地再是最重要的，而并非眼高手低。    \n\n#### <center>2019规划</center>\n\n总结完了，还要展望新的一年啊。资本的寒冬来临了，提示自己变得越来越紧迫，现制定几个小目标吧。\n\n- 阅读完流畅的python一书\n- mysql的使用，书籍的阅读\n- 学习一门nosql\n- 计算机网络的了解，tcp/ip协议的阅读\n- 后端技能树的获取以及学习，例如redis\n- linux shell的编写，能够熟练的编写一些脚本，更加自动化。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2018总结","published":1,"updated":"2022-05-20T02:24:20.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7c0007lae1ppe58zsz","content":"<p>2018年已经接近尾声了，我觉得有必要总结一下自己这一年来的经历吧，每年结束的时候，我总会想起曾经看过的一个人的签名。<br><code>这一年来我们得到了什么，又失去了多少。</code><br><a id=\"more\"></a></p>\n<h4 id=\"学习的总结\"><a href=\"#学习的总结\" class=\"headerlink\" title=\"学习的总结\"></a><center>学习的总结</center></h4><p>大概在去年的时候，那时候在寒假，还是会做一些网页端统计的功能。那时候觉得很无聊，当然能力也很弱，只能做一些简单的功能。寒假结束之后，应该是完善公司网页端的一些界面吧。相对来说，对于<code>django</code>更熟悉了一些，对于python的使用也更熟悉了一些。在9月之前吧，当时我确实不知道自己要什么，我也想找一个方向，前端？后端？但是我发现自己实在是会的太少了。那段时间我又想做数据分析，又借了数据分析的书，之前说毕设会做一些大数据方面的工作，稍微看了hadoop，不过一知半解而已，只是看了一部分，后面接到了别的任务也就没继续了。大概在七八月份的时候，我又想重新进阶一下python吧，那时候买了一本书<code>流畅的python</code>，虽然电子版的有，但我讨厌电子书，我不喜欢总是对着屏幕，所以买了一本吧。这本书可以说真的很不错，从中学到了很多，包括函数的闭包的理解，闭包是之延伸了函数的作用域，可以访问到其它函数的变量，而这个变量并非是全局变量。其他的包括字典生成式，列表生成式，字典如何构建，什么是散列表等等。目前还没读完，还有第五章和第六章吧，后面会继续把他读完。<br>在这个节点大概10月份了，这是有新的项目，风力发电的前端页面的展示，讨论时说过前端需要处理挺多的逻辑，分担后端的压力。当时前段我会的很少，公司的项目都是用的jquery+bootstrap，css只能说勉强会用。当时如果逻辑放到前端，那么jquery并非不可以实现，但是肯定会有大量的$符号就不说了，操作dom也太多次了。我当时也在知乎上浏览了很多文章，再次之前说实话，我听说过vue，angular，react。那时候我每天在想怎么去实现呢，现在想来，想得再多，不动手去做都是徒劳。然后我选择vue这个框架吧，相对来说，技术上过度比较平缓，一开始的话，我觉得挺难用的。后来，只能真香了。说来，vue主要的也是双向绑定了，而且将数据与视图分离，现在看起来真的清爽不少，方法有单独的地方写，不至于代码结构混乱。如果jquery的，我觉得界面还是比较乱的。当时差不多做了一个月，简单界面搭建基本完成，能够使用vue做一些项目了，但是vue的slot这部分我没有深入了解。后面又看了一点es6的语法，买了本vue.js的书籍，这本书看完了，但我感觉提升也就一般。不过跟着书中的例子搭建知乎日报的建立，由于知乎日报的接口挂了，有的文章显示不出。不过这个例子比较简单。后面有个仿饿了么的学习例子，这个例子挺好的，做了一部分。总的来说这段时间能够使用vue来完成前端的工作，但没有仔细深入，但我觉得这种mvvm架构确实很方便。<br>后面，我的同学应该也在某方面的项目，用到了docker，然后在一次报告上讲述了应用。后面，老师也让我们的项目部署在docker中。于是花了些时间学习docker，docker确实挺好的，将环境与外部隔离，需要什么装什么，在用的时候也会遇到一些问题，例如挂载，端口映射之类吧，主要是每次构件错了的话，重写dockerfile略微麻烦，docker commit 似乎不是标准的做法。<br>那差不多十二月了，这时候公司的事情需要做一些了，完善tcp的测试吧。说实话当时我很头痛，因为没接触过socket编程与tcp协议的编写，我很害怕自己做不出来。之前的tcp有份代码我的老师已经写好了，我大概了花了3-5天对着协议把代码全部读了一遍，并且手动敲了一遍加上注释。当我再回过头来，也明白了这些代码的用途和使用吧，对于新的tcp协议，我也可以编写了，并且搭建了测试的服务器。从这时候开始，我觉得多学习一下后端了，相对于前端，我认为我更喜欢后端多一些，因为我不喜欢写css，好麻烦。这段时间我也看了mysql的使用，公司使用的pq，但是数据库语言都是产不多的。虽说公司用的pq,但是查询语言都是django的封装好的查询语言，所以我觉得有必要学习一下mysql，包括后续的风力发电的数据库肯定也会弃用sqlite而转到pq，这是我的想法吧。<br>这一年来，进步还是有一点点，当时我觉的差的好多，有时候我总觉得很无力，出来混总要还的吧，做好自己现在的而努力追求更高的，是当下应该做的。    </p>\n<h4 id=\"生活的总结\"><a href=\"#生活的总结\" class=\"headerlink\" title=\"生活的总结\"></a><center>生活的总结</center></h4><p>说实话，当初选择西安，我当初是想一个人，而且西安是一座旅游城市，我可以经常出去逛，现在想想只觉得自己年轻。从我来到西安，因为基础比较差，我当时真的很难受，同学有，但是并非所有事情可以倾诉。那时候我才感觉一个人无助的感觉是有多么落寞。后来慢慢的吧，能做一些了，才会积累起一些自信。六月份的时候，我的高中同学来找我，然后我们去了华清池等地方，只能说我的朋友带我浏览的西安，但是我还是很开心的，自己来了西安那么久，到现在我也没去过兵马俑。。。<br>来了西安一年半多有了吧，现在研二上学期快结束了，大约研一还呆在实验室，研二上学期开始待在公司这边，但是就我一个人，为了占工位，我觉得自己越来越一个人，有利也有弊，我怕自己管不住自己，老是玩游戏，有过一段这个时间，那一周啥也没做，内心的愧疚吧。但是，好处是没有人打扰，我想多久回就多久回，正常来说，冬天好冷的情况下，晚上八点工作，到十一点半左右回去吧。这边创新咖啡街区晚上的夜景其实还不错。晚上人还挺多的。一个人的坏处还有就是太宅了，以至于我不知道要去干什么，难道只能对着电脑吗？我现在感觉很少与人交流，虽然我本身不善言辞，但我感觉更善于倾听了吧，但是如果熟悉了之后我觉得还是话挺多的吧。<br>每当我对比其他人，我的基础是最差的，但是也要慢慢提升嘛，就像昨天的聚餐，曾老师的一句话大致的意思是这样，<code>遇到困难或者不会的事情只要去解决，就会发现它没那么难，你不会，总有人会</code>，这句话对于学习中我觉得还是很适用的，遇到问题如果就下定决心去解决它，回头发现自己又会进步一点点。如果让我选择，读研来说还是正确的选择。无论别人怎么认为我，我觉得到了更大的平台，自己周围的人和事情都会变的不一样，我觉得最主要的一点是学会了如何学习？而并非是把事件花费在很多没有意义的事情上，我还是很佩服我的老师的，因为我觉得首先他很厉害，我觉得他什么都会，智商又高，又可以指导我。我印象比较深的是在一次晚上我提交了代码后，老师给我的评注大概在12点40左右吧，那也快一点了，因为今年来说老师比较忙，那时候我觉得已经十二点多了，还在工作，好辛苦的说。还有一次是早晨七点多也就接到了代码的评注，起得好早啊。感触挺深的吧，真的很佩服齐老师啊。<br>无论自己处于什么位置，也不能放弃向上的姿态吧。有一句话是这么说的，人比人之间的差距，比人和狗之间的差距还大。深有体会吧，但是并不代表自己放弃了什么，我认为做好自己的，然后进步是自己的方式，而并非处于差距之下而无法自拔。毕竟行拂乱其所为，所以动心忍性，增益其所不能。脚踏实地再是最重要的，而并非眼高手低。    </p>\n<h4 id=\"2019规划\"><a href=\"#2019规划\" class=\"headerlink\" title=\"2019规划\"></a><center>2019规划</center></h4><p>总结完了，还要展望新的一年啊。资本的寒冬来临了，提示自己变得越来越紧迫，现制定几个小目标吧。</p>\n<ul>\n<li>阅读完流畅的python一书</li>\n<li>mysql的使用，书籍的阅读</li>\n<li>学习一门nosql</li>\n<li>计算机网络的了解，tcp/ip协议的阅读</li>\n<li>后端技能树的获取以及学习，例如redis</li>\n<li>linux shell的编写，能够熟练的编写一些脚本，更加自动化。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>2018年已经接近尾声了，我觉得有必要总结一下自己这一年来的经历吧，每年结束的时候，我总会想起曾经看过的一个人的签名。<br><code>这一年来我们得到了什么，又失去了多少。</code><br>","more":"</p>\n<h4 id=\"学习的总结\"><a href=\"#学习的总结\" class=\"headerlink\" title=\"学习的总结\"></a><center>学习的总结</center></h4><p>大概在去年的时候，那时候在寒假，还是会做一些网页端统计的功能。那时候觉得很无聊，当然能力也很弱，只能做一些简单的功能。寒假结束之后，应该是完善公司网页端的一些界面吧。相对来说，对于<code>django</code>更熟悉了一些，对于python的使用也更熟悉了一些。在9月之前吧，当时我确实不知道自己要什么，我也想找一个方向，前端？后端？但是我发现自己实在是会的太少了。那段时间我又想做数据分析，又借了数据分析的书，之前说毕设会做一些大数据方面的工作，稍微看了hadoop，不过一知半解而已，只是看了一部分，后面接到了别的任务也就没继续了。大概在七八月份的时候，我又想重新进阶一下python吧，那时候买了一本书<code>流畅的python</code>，虽然电子版的有，但我讨厌电子书，我不喜欢总是对着屏幕，所以买了一本吧。这本书可以说真的很不错，从中学到了很多，包括函数的闭包的理解，闭包是之延伸了函数的作用域，可以访问到其它函数的变量，而这个变量并非是全局变量。其他的包括字典生成式，列表生成式，字典如何构建，什么是散列表等等。目前还没读完，还有第五章和第六章吧，后面会继续把他读完。<br>在这个节点大概10月份了，这是有新的项目，风力发电的前端页面的展示，讨论时说过前端需要处理挺多的逻辑，分担后端的压力。当时前段我会的很少，公司的项目都是用的jquery+bootstrap，css只能说勉强会用。当时如果逻辑放到前端，那么jquery并非不可以实现，但是肯定会有大量的$符号就不说了，操作dom也太多次了。我当时也在知乎上浏览了很多文章，再次之前说实话，我听说过vue，angular，react。那时候我每天在想怎么去实现呢，现在想来，想得再多，不动手去做都是徒劳。然后我选择vue这个框架吧，相对来说，技术上过度比较平缓，一开始的话，我觉得挺难用的。后来，只能真香了。说来，vue主要的也是双向绑定了，而且将数据与视图分离，现在看起来真的清爽不少，方法有单独的地方写，不至于代码结构混乱。如果jquery的，我觉得界面还是比较乱的。当时差不多做了一个月，简单界面搭建基本完成，能够使用vue做一些项目了，但是vue的slot这部分我没有深入了解。后面又看了一点es6的语法，买了本vue.js的书籍，这本书看完了，但我感觉提升也就一般。不过跟着书中的例子搭建知乎日报的建立，由于知乎日报的接口挂了，有的文章显示不出。不过这个例子比较简单。后面有个仿饿了么的学习例子，这个例子挺好的，做了一部分。总的来说这段时间能够使用vue来完成前端的工作，但没有仔细深入，但我觉得这种mvvm架构确实很方便。<br>后面，我的同学应该也在某方面的项目，用到了docker，然后在一次报告上讲述了应用。后面，老师也让我们的项目部署在docker中。于是花了些时间学习docker，docker确实挺好的，将环境与外部隔离，需要什么装什么，在用的时候也会遇到一些问题，例如挂载，端口映射之类吧，主要是每次构件错了的话，重写dockerfile略微麻烦，docker commit 似乎不是标准的做法。<br>那差不多十二月了，这时候公司的事情需要做一些了，完善tcp的测试吧。说实话当时我很头痛，因为没接触过socket编程与tcp协议的编写，我很害怕自己做不出来。之前的tcp有份代码我的老师已经写好了，我大概了花了3-5天对着协议把代码全部读了一遍，并且手动敲了一遍加上注释。当我再回过头来，也明白了这些代码的用途和使用吧，对于新的tcp协议，我也可以编写了，并且搭建了测试的服务器。从这时候开始，我觉得多学习一下后端了，相对于前端，我认为我更喜欢后端多一些，因为我不喜欢写css，好麻烦。这段时间我也看了mysql的使用，公司使用的pq，但是数据库语言都是产不多的。虽说公司用的pq,但是查询语言都是django的封装好的查询语言，所以我觉得有必要学习一下mysql，包括后续的风力发电的数据库肯定也会弃用sqlite而转到pq，这是我的想法吧。<br>这一年来，进步还是有一点点，当时我觉的差的好多，有时候我总觉得很无力，出来混总要还的吧，做好自己现在的而努力追求更高的，是当下应该做的。    </p>\n<h4 id=\"生活的总结\"><a href=\"#生活的总结\" class=\"headerlink\" title=\"生活的总结\"></a><center>生活的总结</center></h4><p>说实话，当初选择西安，我当初是想一个人，而且西安是一座旅游城市，我可以经常出去逛，现在想想只觉得自己年轻。从我来到西安，因为基础比较差，我当时真的很难受，同学有，但是并非所有事情可以倾诉。那时候我才感觉一个人无助的感觉是有多么落寞。后来慢慢的吧，能做一些了，才会积累起一些自信。六月份的时候，我的高中同学来找我，然后我们去了华清池等地方，只能说我的朋友带我浏览的西安，但是我还是很开心的，自己来了西安那么久，到现在我也没去过兵马俑。。。<br>来了西安一年半多有了吧，现在研二上学期快结束了，大约研一还呆在实验室，研二上学期开始待在公司这边，但是就我一个人，为了占工位，我觉得自己越来越一个人，有利也有弊，我怕自己管不住自己，老是玩游戏，有过一段这个时间，那一周啥也没做，内心的愧疚吧。但是，好处是没有人打扰，我想多久回就多久回，正常来说，冬天好冷的情况下，晚上八点工作，到十一点半左右回去吧。这边创新咖啡街区晚上的夜景其实还不错。晚上人还挺多的。一个人的坏处还有就是太宅了，以至于我不知道要去干什么，难道只能对着电脑吗？我现在感觉很少与人交流，虽然我本身不善言辞，但我感觉更善于倾听了吧，但是如果熟悉了之后我觉得还是话挺多的吧。<br>每当我对比其他人，我的基础是最差的，但是也要慢慢提升嘛，就像昨天的聚餐，曾老师的一句话大致的意思是这样，<code>遇到困难或者不会的事情只要去解决，就会发现它没那么难，你不会，总有人会</code>，这句话对于学习中我觉得还是很适用的，遇到问题如果就下定决心去解决它，回头发现自己又会进步一点点。如果让我选择，读研来说还是正确的选择。无论别人怎么认为我，我觉得到了更大的平台，自己周围的人和事情都会变的不一样，我觉得最主要的一点是学会了如何学习？而并非是把事件花费在很多没有意义的事情上，我还是很佩服我的老师的，因为我觉得首先他很厉害，我觉得他什么都会，智商又高，又可以指导我。我印象比较深的是在一次晚上我提交了代码后，老师给我的评注大概在12点40左右吧，那也快一点了，因为今年来说老师比较忙，那时候我觉得已经十二点多了，还在工作，好辛苦的说。还有一次是早晨七点多也就接到了代码的评注，起得好早啊。感触挺深的吧，真的很佩服齐老师啊。<br>无论自己处于什么位置，也不能放弃向上的姿态吧。有一句话是这么说的，人比人之间的差距，比人和狗之间的差距还大。深有体会吧，但是并不代表自己放弃了什么，我认为做好自己的，然后进步是自己的方式，而并非处于差距之下而无法自拔。毕竟行拂乱其所为，所以动心忍性，增益其所不能。脚踏实地再是最重要的，而并非眼高手低。    </p>\n<h4 id=\"2019规划\"><a href=\"#2019规划\" class=\"headerlink\" title=\"2019规划\"></a><center>2019规划</center></h4><p>总结完了，还要展望新的一年啊。资本的寒冬来临了，提示自己变得越来越紧迫，现制定几个小目标吧。</p>\n<ul>\n<li>阅读完流畅的python一书</li>\n<li>mysql的使用，书籍的阅读</li>\n<li>学习一门nosql</li>\n<li>计算机网络的了解，tcp/ip协议的阅读</li>\n<li>后端技能树的获取以及学习，例如redis</li>\n<li>linux shell的编写，能够熟练的编写一些脚本，更加自动化。</li>\n</ul>"},{"title":"es6的数组","date":"2018-12-06T02:33:09.000Z","_content":"\n## <center>es6数组</center>\n\n### 1.扩展运算符\n```\nconsole.log(...[1,2,3]) //1,2,3\nconsole.log(1, ...[2,3,4],5)\n```\n\n- 取代apply的例子\n\n```\nES5: Math.max.apply(null, [14,3,3])\nES6: Math.max(...[14,3,37])\n```\n\n- 另一个数组push的例子\n\n```\nvar arr1 = [0,1,2]\nvar arr2 = [3,4,5]\nArray.prototype.push.apply(arr1, arr2)\nES6: arr1.push(...arr2)\n```\n- 扩展运算符的应用    \n<!--more -->\n1.复制数组\n\n```\nconst a1 = [1,2]\nconst a2 = a1\na2[0] = 2\na1 //[2,2,]\n```\n上述代码中，a2并不是数组a1的克隆，而是指向同一份数据的指针，修改a2，那么a1也会变化，es5的方法\n```\nconst a1 = [1,2]\ncosnta a2 = a1.contact()\na2[0] = 2\na1 //[1,2]\n```\n上述代码中a1会返回原数组的克隆，再修改a2就不会对a1产生影响，对于es6的写法如下\n```\nconst a1 = [1,2]\nconst a2 = [...a1]\n```\n\n2.合并数组\n\n```\nconst arr1 = ['a', 'b']\nconst arr2 = ['c']\nconst arr3 = ['d', 'e']\nes5合并: arr1.contanct(arr2,arr3)\nes6合并: [...arr1,...arr2,...arr3]\n```\n但是上述方法均是浅拷贝，如果修改了原数组的变量，那么会同步映射到新的合并的数组。\n\n3.与解构赋值结合\n```\nconst [first, ...rest] = [1,2,3,4,5]\nfirst //1\nrest //[2,3,4,5]\nconst [first, ...rest] = []\nfirst //undefined\nrest //[]\nconst [first, ...rest] = ['foo']\nfirst //'foo'\nrest //[]\n```\n### 2.Array.from()\nArray.from方法用于将两类对象转化为真正的数组：类数组对象(array-like object)和可遍历对象(iterable)，类数组对象是指可以通过索引访问元素，并且拥有length属性，但是没有数组的其他方法，如push，forEach，indexOf。常见的像字典，DOM操作返回的NodeList,以及函数内部的arguments对象\n```\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n```\n### Array.of()\nArray.of方法将一组值转化为数组\n```\nArray.of(1,11,3) //[1,11,3]\nArray.of() //[]\n```\n### 数组实例的find和findIndex\n数组实例的find方法，用于找出第一个符合条件的数组成员，他的参数是一个回调函数，若没有返回则为undefined\n```\n[1,3,-5,18].find((n) => n < 0) //-5\n[1,5,10,15].find(function(value, index, arr){\n    return value > 9\n}) //2\n```\nfindIndex同上\n### 数组实例的fill\n```\n['a', 'b', 'c'].fill(7)\n// [7, 7, 7]\n\nnew Array(3).fill(7)\n// [7, 7, 7]\n['a', 'b', 'c'].fill(7, 1, 2)\n// ['a', 7, 'c']\n```\n### 数组实例的 entries()，keys() 和 values()\nES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。\n\n```\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n```\n\n### Array.prototype.includes\nArray.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。\n\n```\n[1, 2, 3].includes(2)     // true\n[1, 2, 3].includes(4)     // false\n[1, 2, NaN].includes(NaN) // true\n```\n该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。\n```\n[1, 2, 3].includes(3, 3);  // false\n[1, 2, 3].includes(3, -1); // true\n```\n### 数组实例的 flat()，flatMap()\n数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。\n```\n[1, 2, [3, 4]].flat()\n// [1, 2, 3, 4]\n```\nflat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。\n```\n[1, 2, [3, [4, 5]]].flat()\n// [1, 2, 3, [4, 5]]\n\n[1, 2, [3, [4, 5]]].flat(2)\n// [1, 2, 3, 4, 5]\n```\n如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。\n```\n[1, [2, [3]]].flat(Infinity)\n// [1, 2, 3]\n```","source":"_posts/array.mkd","raw":"---\ntitle: es6的数组\ndate: 2018-12-06 10:33:09\ntags: javascript\ncategories: javascript\n---\n\n## <center>es6数组</center>\n\n### 1.扩展运算符\n```\nconsole.log(...[1,2,3]) //1,2,3\nconsole.log(1, ...[2,3,4],5)\n```\n\n- 取代apply的例子\n\n```\nES5: Math.max.apply(null, [14,3,3])\nES6: Math.max(...[14,3,37])\n```\n\n- 另一个数组push的例子\n\n```\nvar arr1 = [0,1,2]\nvar arr2 = [3,4,5]\nArray.prototype.push.apply(arr1, arr2)\nES6: arr1.push(...arr2)\n```\n- 扩展运算符的应用    \n<!--more -->\n1.复制数组\n\n```\nconst a1 = [1,2]\nconst a2 = a1\na2[0] = 2\na1 //[2,2,]\n```\n上述代码中，a2并不是数组a1的克隆，而是指向同一份数据的指针，修改a2，那么a1也会变化，es5的方法\n```\nconst a1 = [1,2]\ncosnta a2 = a1.contact()\na2[0] = 2\na1 //[1,2]\n```\n上述代码中a1会返回原数组的克隆，再修改a2就不会对a1产生影响，对于es6的写法如下\n```\nconst a1 = [1,2]\nconst a2 = [...a1]\n```\n\n2.合并数组\n\n```\nconst arr1 = ['a', 'b']\nconst arr2 = ['c']\nconst arr3 = ['d', 'e']\nes5合并: arr1.contanct(arr2,arr3)\nes6合并: [...arr1,...arr2,...arr3]\n```\n但是上述方法均是浅拷贝，如果修改了原数组的变量，那么会同步映射到新的合并的数组。\n\n3.与解构赋值结合\n```\nconst [first, ...rest] = [1,2,3,4,5]\nfirst //1\nrest //[2,3,4,5]\nconst [first, ...rest] = []\nfirst //undefined\nrest //[]\nconst [first, ...rest] = ['foo']\nfirst //'foo'\nrest //[]\n```\n### 2.Array.from()\nArray.from方法用于将两类对象转化为真正的数组：类数组对象(array-like object)和可遍历对象(iterable)，类数组对象是指可以通过索引访问元素，并且拥有length属性，但是没有数组的其他方法，如push，forEach，indexOf。常见的像字典，DOM操作返回的NodeList,以及函数内部的arguments对象\n```\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n```\n### Array.of()\nArray.of方法将一组值转化为数组\n```\nArray.of(1,11,3) //[1,11,3]\nArray.of() //[]\n```\n### 数组实例的find和findIndex\n数组实例的find方法，用于找出第一个符合条件的数组成员，他的参数是一个回调函数，若没有返回则为undefined\n```\n[1,3,-5,18].find((n) => n < 0) //-5\n[1,5,10,15].find(function(value, index, arr){\n    return value > 9\n}) //2\n```\nfindIndex同上\n### 数组实例的fill\n```\n['a', 'b', 'c'].fill(7)\n// [7, 7, 7]\n\nnew Array(3).fill(7)\n// [7, 7, 7]\n['a', 'b', 'c'].fill(7, 1, 2)\n// ['a', 7, 'c']\n```\n### 数组实例的 entries()，keys() 和 values()\nES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。\n\n```\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n```\n\n### Array.prototype.includes\nArray.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。\n\n```\n[1, 2, 3].includes(2)     // true\n[1, 2, 3].includes(4)     // false\n[1, 2, NaN].includes(NaN) // true\n```\n该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。\n```\n[1, 2, 3].includes(3, 3);  // false\n[1, 2, 3].includes(3, -1); // true\n```\n### 数组实例的 flat()，flatMap()\n数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。\n```\n[1, 2, [3, 4]].flat()\n// [1, 2, 3, 4]\n```\nflat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。\n```\n[1, 2, [3, [4, 5]]].flat()\n// [1, 2, 3, [4, 5]]\n\n[1, 2, [3, [4, 5]]].flat(2)\n// [1, 2, 3, 4, 5]\n```\n如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。\n```\n[1, [2, [3]]].flat(Infinity)\n// [1, 2, 3]\n```","slug":"array","published":1,"updated":"2022-05-20T02:24:20.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7d0008lae16nn6rlt2","content":"<h2 id=\"es6数组\"><a href=\"#es6数组\" class=\"headerlink\" title=\"es6数组\"></a><center>es6数组</center></h2><h3 id=\"1-扩展运算符\"><a href=\"#1-扩展运算符\" class=\"headerlink\" title=\"1.扩展运算符\"></a>1.扩展运算符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(...[1,2,3]) //1,2,3</span><br><span class=\"line\">console.log(1, ...[2,3,4],5)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>取代apply的例子</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ES5: Math.max.apply(null, [14,3,3])</span><br><span class=\"line\">ES6: Math.max(...[14,3,37])</span><br></pre></td></tr></table></figure>\n<ul>\n<li>另一个数组push的例子</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr1 = [0,1,2]</span><br><span class=\"line\">var arr2 = [3,4,5]</span><br><span class=\"line\">Array.prototype.push.apply(arr1, arr2)</span><br><span class=\"line\">ES6: arr1.push(...arr2)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>扩展运算符的应用    <a id=\"more\"></a>\n1.复制数组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a1 = [1,2]</span><br><span class=\"line\">const a2 = a1</span><br><span class=\"line\">a2[0] = 2</span><br><span class=\"line\">a1 //[2,2,]</span><br></pre></td></tr></table></figure>\n<p>上述代码中，a2并不是数组a1的克隆，而是指向同一份数据的指针，修改a2，那么a1也会变化，es5的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a1 = [1,2]</span><br><span class=\"line\">cosnta a2 = a1.contact()</span><br><span class=\"line\">a2[0] = 2</span><br><span class=\"line\">a1 //[1,2]</span><br></pre></td></tr></table></figure></p>\n<p>上述代码中a1会返回原数组的克隆，再修改a2就不会对a1产生影响，对于es6的写法如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a1 = [1,2]</span><br><span class=\"line\">const a2 = [...a1]</span><br></pre></td></tr></table></figure></p>\n<p>2.合并数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr1 = [&apos;a&apos;, &apos;b&apos;]</span><br><span class=\"line\">const arr2 = [&apos;c&apos;]</span><br><span class=\"line\">const arr3 = [&apos;d&apos;, &apos;e&apos;]</span><br><span class=\"line\">es5合并: arr1.contanct(arr2,arr3)</span><br><span class=\"line\">es6合并: [...arr1,...arr2,...arr3]</span><br></pre></td></tr></table></figure>\n<p>但是上述方法均是浅拷贝，如果修改了原数组的变量，那么会同步映射到新的合并的数组。</p>\n<p>3.与解构赋值结合<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const [first, ...rest] = [1,2,3,4,5]</span><br><span class=\"line\">first //1</span><br><span class=\"line\">rest //[2,3,4,5]</span><br><span class=\"line\">const [first, ...rest] = []</span><br><span class=\"line\">first //undefined</span><br><span class=\"line\">rest //[]</span><br><span class=\"line\">const [first, ...rest] = [&apos;foo&apos;]</span><br><span class=\"line\">first //&apos;foo&apos;</span><br><span class=\"line\">rest //[]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-Array-from\"><a href=\"#2-Array-from\" class=\"headerlink\" title=\"2.Array.from()\"></a>2.Array.from()</h3><p>Array.from方法用于将两类对象转化为真正的数组：类数组对象(array-like object)和可遍历对象(iterable)，类数组对象是指可以通过索引访问元素，并且拥有length属性，但是没有数组的其他方法，如push，forEach，indexOf。常见的像字典，DOM操作返回的NodeList,以及函数内部的arguments对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arrayLike = &#123;</span><br><span class=\"line\">    &apos;0&apos;: &apos;a&apos;,</span><br><span class=\"line\">    &apos;1&apos;: &apos;b&apos;,</span><br><span class=\"line\">    &apos;2&apos;: &apos;c&apos;,</span><br><span class=\"line\">    length: 3</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES5的写法</span><br><span class=\"line\">var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6的写法</span><br><span class=\"line\">let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h3><p>Array.of方法将一组值转化为数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.of(1,11,3) //[1,11,3]</span><br><span class=\"line\">Array.of() //[]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数组实例的find和findIndex\"><a href=\"#数组实例的find和findIndex\" class=\"headerlink\" title=\"数组实例的find和findIndex\"></a>数组实例的find和findIndex</h3><p>数组实例的find方法，用于找出第一个符合条件的数组成员，他的参数是一个回调函数，若没有返回则为undefined<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1,3,-5,18].find((n) =&gt; n &lt; 0) //-5</span><br><span class=\"line\">[1,5,10,15].find(function(value, index, arr)&#123;</span><br><span class=\"line\">    return value &gt; 9</span><br><span class=\"line\">&#125;) //2</span><br></pre></td></tr></table></figure></p>\n<p>findIndex同上</p>\n<h3 id=\"数组实例的fill\"><a href=\"#数组实例的fill\" class=\"headerlink\" title=\"数组实例的fill\"></a>数组实例的fill</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)</span><br><span class=\"line\">// [7, 7, 7]</span><br><span class=\"line\"></span><br><span class=\"line\">new Array(3).fill(7)</span><br><span class=\"line\">// [7, 7, 7]</span><br><span class=\"line\">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)</span><br><span class=\"line\">// [&apos;a&apos;, 7, &apos;c&apos;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组实例的-entries-，keys-和-values\"><a href=\"#数组实例的-entries-，keys-和-values\" class=\"headerlink\" title=\"数组实例的 entries()，keys() 和 values()\"></a>数组实例的 entries()，keys() 和 values()</h3><p>ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</span><br><span class=\"line\">  console.log(index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 0</span><br><span class=\"line\">// 1</span><br><span class=\"line\"></span><br><span class=\"line\">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</span><br><span class=\"line\">  console.log(elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// &apos;a&apos;</span><br><span class=\"line\">// &apos;b&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</span><br><span class=\"line\">  console.log(index, elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 0 &quot;a&quot;</span><br><span class=\"line\">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Array-prototype-includes\"><a href=\"#Array-prototype-includes\" class=\"headerlink\" title=\"Array.prototype.includes\"></a>Array.prototype.includes</h3><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3].includes(2)     // true</span><br><span class=\"line\">[1, 2, 3].includes(4)     // false</span><br><span class=\"line\">[1, 2, NaN].includes(NaN) // true</span><br></pre></td></tr></table></figure>\n<p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3].includes(3, 3);  // false</span><br><span class=\"line\">[1, 2, 3].includes(3, -1); // true</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数组实例的-flat-，flatMap\"><a href=\"#数组实例的-flat-，flatMap\" class=\"headerlink\" title=\"数组实例的 flat()，flatMap()\"></a>数组实例的 flat()，flatMap()</h3><p>数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, [3, 4]].flat()</span><br><span class=\"line\">// [1, 2, 3, 4]</span><br></pre></td></tr></table></figure></p>\n<p>flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, [3, [4, 5]]].flat()</span><br><span class=\"line\">// [1, 2, 3, [4, 5]]</span><br><span class=\"line\"></span><br><span class=\"line\">[1, 2, [3, [4, 5]]].flat(2)</span><br><span class=\"line\">// [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></p>\n<p>如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, [2, [3]]].flat(Infinity)</span><br><span class=\"line\">// [1, 2, 3]</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"es6数组\"><a href=\"#es6数组\" class=\"headerlink\" title=\"es6数组\"></a><center>es6数组</center></h2><h3 id=\"1-扩展运算符\"><a href=\"#1-扩展运算符\" class=\"headerlink\" title=\"1.扩展运算符\"></a>1.扩展运算符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(...[1,2,3]) //1,2,3</span><br><span class=\"line\">console.log(1, ...[2,3,4],5)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>取代apply的例子</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ES5: Math.max.apply(null, [14,3,3])</span><br><span class=\"line\">ES6: Math.max(...[14,3,37])</span><br></pre></td></tr></table></figure>\n<ul>\n<li>另一个数组push的例子</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr1 = [0,1,2]</span><br><span class=\"line\">var arr2 = [3,4,5]</span><br><span class=\"line\">Array.prototype.push.apply(arr1, arr2)</span><br><span class=\"line\">ES6: arr1.push(...arr2)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>扩展运算符的应用","more":"1.复制数组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a1 = [1,2]</span><br><span class=\"line\">const a2 = a1</span><br><span class=\"line\">a2[0] = 2</span><br><span class=\"line\">a1 //[2,2,]</span><br></pre></td></tr></table></figure>\n<p>上述代码中，a2并不是数组a1的克隆，而是指向同一份数据的指针，修改a2，那么a1也会变化，es5的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a1 = [1,2]</span><br><span class=\"line\">cosnta a2 = a1.contact()</span><br><span class=\"line\">a2[0] = 2</span><br><span class=\"line\">a1 //[1,2]</span><br></pre></td></tr></table></figure></p>\n<p>上述代码中a1会返回原数组的克隆，再修改a2就不会对a1产生影响，对于es6的写法如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a1 = [1,2]</span><br><span class=\"line\">const a2 = [...a1]</span><br></pre></td></tr></table></figure></p>\n<p>2.合并数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr1 = [&apos;a&apos;, &apos;b&apos;]</span><br><span class=\"line\">const arr2 = [&apos;c&apos;]</span><br><span class=\"line\">const arr3 = [&apos;d&apos;, &apos;e&apos;]</span><br><span class=\"line\">es5合并: arr1.contanct(arr2,arr3)</span><br><span class=\"line\">es6合并: [...arr1,...arr2,...arr3]</span><br></pre></td></tr></table></figure>\n<p>但是上述方法均是浅拷贝，如果修改了原数组的变量，那么会同步映射到新的合并的数组。</p>\n<p>3.与解构赋值结合<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const [first, ...rest] = [1,2,3,4,5]</span><br><span class=\"line\">first //1</span><br><span class=\"line\">rest //[2,3,4,5]</span><br><span class=\"line\">const [first, ...rest] = []</span><br><span class=\"line\">first //undefined</span><br><span class=\"line\">rest //[]</span><br><span class=\"line\">const [first, ...rest] = [&apos;foo&apos;]</span><br><span class=\"line\">first //&apos;foo&apos;</span><br><span class=\"line\">rest //[]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-Array-from\"><a href=\"#2-Array-from\" class=\"headerlink\" title=\"2.Array.from()\"></a>2.Array.from()</h3><p>Array.from方法用于将两类对象转化为真正的数组：类数组对象(array-like object)和可遍历对象(iterable)，类数组对象是指可以通过索引访问元素，并且拥有length属性，但是没有数组的其他方法，如push，forEach，indexOf。常见的像字典，DOM操作返回的NodeList,以及函数内部的arguments对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arrayLike = &#123;</span><br><span class=\"line\">    &apos;0&apos;: &apos;a&apos;,</span><br><span class=\"line\">    &apos;1&apos;: &apos;b&apos;,</span><br><span class=\"line\">    &apos;2&apos;: &apos;c&apos;,</span><br><span class=\"line\">    length: 3</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES5的写法</span><br><span class=\"line\">var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6的写法</span><br><span class=\"line\">let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h3><p>Array.of方法将一组值转化为数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.of(1,11,3) //[1,11,3]</span><br><span class=\"line\">Array.of() //[]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数组实例的find和findIndex\"><a href=\"#数组实例的find和findIndex\" class=\"headerlink\" title=\"数组实例的find和findIndex\"></a>数组实例的find和findIndex</h3><p>数组实例的find方法，用于找出第一个符合条件的数组成员，他的参数是一个回调函数，若没有返回则为undefined<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1,3,-5,18].find((n) =&gt; n &lt; 0) //-5</span><br><span class=\"line\">[1,5,10,15].find(function(value, index, arr)&#123;</span><br><span class=\"line\">    return value &gt; 9</span><br><span class=\"line\">&#125;) //2</span><br></pre></td></tr></table></figure></p>\n<p>findIndex同上</p>\n<h3 id=\"数组实例的fill\"><a href=\"#数组实例的fill\" class=\"headerlink\" title=\"数组实例的fill\"></a>数组实例的fill</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)</span><br><span class=\"line\">// [7, 7, 7]</span><br><span class=\"line\"></span><br><span class=\"line\">new Array(3).fill(7)</span><br><span class=\"line\">// [7, 7, 7]</span><br><span class=\"line\">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)</span><br><span class=\"line\">// [&apos;a&apos;, 7, &apos;c&apos;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组实例的-entries-，keys-和-values\"><a href=\"#数组实例的-entries-，keys-和-values\" class=\"headerlink\" title=\"数组实例的 entries()，keys() 和 values()\"></a>数组实例的 entries()，keys() 和 values()</h3><p>ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</span><br><span class=\"line\">  console.log(index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 0</span><br><span class=\"line\">// 1</span><br><span class=\"line\"></span><br><span class=\"line\">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</span><br><span class=\"line\">  console.log(elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// &apos;a&apos;</span><br><span class=\"line\">// &apos;b&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</span><br><span class=\"line\">  console.log(index, elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 0 &quot;a&quot;</span><br><span class=\"line\">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Array-prototype-includes\"><a href=\"#Array-prototype-includes\" class=\"headerlink\" title=\"Array.prototype.includes\"></a>Array.prototype.includes</h3><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3].includes(2)     // true</span><br><span class=\"line\">[1, 2, 3].includes(4)     // false</span><br><span class=\"line\">[1, 2, NaN].includes(NaN) // true</span><br></pre></td></tr></table></figure>\n<p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3].includes(3, 3);  // false</span><br><span class=\"line\">[1, 2, 3].includes(3, -1); // true</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数组实例的-flat-，flatMap\"><a href=\"#数组实例的-flat-，flatMap\" class=\"headerlink\" title=\"数组实例的 flat()，flatMap()\"></a>数组实例的 flat()，flatMap()</h3><p>数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, [3, 4]].flat()</span><br><span class=\"line\">// [1, 2, 3, 4]</span><br></pre></td></tr></table></figure></p>\n<p>flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, [3, [4, 5]]].flat()</span><br><span class=\"line\">// [1, 2, 3, [4, 5]]</span><br><span class=\"line\"></span><br><span class=\"line\">[1, 2, [3, [4, 5]]].flat(2)</span><br><span class=\"line\">// [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></p>\n<p>如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, [2, [3]]].flat(Infinity)</span><br><span class=\"line\">// [1, 2, 3]</span><br></pre></td></tr></table></figure></p>"},{"layout":"posts","title":"docker-compose的使用","date":"2019-04-29T09:50:06.000Z","_content":"\n## <center>记录docker-compose的使用</center>\n\n1.使用docker-compose的目的: 我么一般把web和数据库进行分离，每个应用程序作为一个docker的镜像来使用，这也是docker官方推荐的做法。\n\n2.docker-compose是官方的编排应用。官方有django的设置。今天你测试了以下自己的环境。记录一下。\n\n3.首先我们使用的是django和postgresql数据库。然后需要拉取postgresql数据库。先看一下`docker-compose.yaml`文件。\n\n```\nversion: '3'\n\nservices:\n  db:\n    image: postgres #依赖的镜像，若没有则会自动从dockerhub获取\n    volumes:\n      - ./postgres-data:/var/lib/postgresql/data #挂载数据库文件，因为如果不挂载，那么容易起一停止数据就没了。运行的数据都会同步到这里\n  web:\n    build: .  #这部分是值相当于docker build，会自动寻找Dockerfile，.代表当前目录。\n    command: python manage.py runserver 0.0.0.0:8000  #启动命令。\n    volumes:\n      - .:/code  #也是挂载web的一些代码\n    ports:\n      - \"8000:8000\"  #端口映射\n    depends_on:\n      - db  #这里是依赖，那么就是先启动了db\n```\n<!-- more -->\n4.由于使用的pqsql，所以我们在settings需要更改。\n如下\n```\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': 'postgres',\n        'USER': 'postgres',\n        'HOST': 'db',\n        'PORT': 5432,\n    }\n}\n```\n5. 这个时候已经可以启动了，并且使用的是pqsql，因为我需要导入一些测试数据。先运行这写代码,在包含yml的文件的目录下运行\n```\ndocker-compose config ##检查yml文件格式\ndocker-compose config --service  ##显示service\ndocker-compose run web python manage.py migrate\ndocker-compose run web python manage.py loaddata test_auth.json\ndocker-compose run web python manage.py loaddata test_management.json\ndocker-comnpose run web python manage.py loaddata test_location.json\ndocker-compose up ##启动\n```\n6. 晚上加个班，加上一层nginx,Dockerfile如下\n```\nFROM nginx\n\n\n#对外暴露端口\nEXPOSE 8005\n\nRUN rm /etc/nginx/conf.d/default.conf\n\nADD localhost.conf  /etc/nginx/conf.d/\n\n\n```\nlocalhost.conf如下\n\n```\nserver {\n    charset utf-8;\n    listen 8005;\n    server_name 127.0.0.1;\n    \n    error_log /var/nginx_error.log;\n    access_log /var/nginx_access.log;\n\n    location /static {\n\talias /var/www/static/guacamole;\n    }\n    location / {\n\tproxy_set_header Host $host;\n\tproxy_pass http://web:8000;  ##注意这里写service web的名字，找了好久的错误\n    }\n}\n\n```\n最后修改docker-compose.yml如下\n```\nversion: '3'\n\nservices:\n  db:\n    image: postgres\n    volumes:\n      - ./postgres-data:/var/lib/postgresql/data\n  web:\n    build: .\n    command: python manage.py runserver 0.0.0.0:8000\n    volumes:\n      - .:/code\n    depends_on:\n      - db\n  nginx:\n    build: ./nginx\n    volumes:\n      - /var/www/static/guacamole:/var/www/static/guacamole\n    ports:\n      - \"8005:8005\"\n    depends_on:\n      - web\n```\n最后执行 `docker-compose up`即可，访问127.0.01:8005便可以访问到服务。\n\n7.等待套一层gunicorn\n8.有个bug，有时候数据库最后启动导致服务启动不了，等待查看原因。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/docker-compose的使用.md","raw":"---\nlayout: posts\ntitle: docker-compose的使用\ndate: 2019-04-29 17:50:06\ntags: docker\ncategories: docker\n---\n\n## <center>记录docker-compose的使用</center>\n\n1.使用docker-compose的目的: 我么一般把web和数据库进行分离，每个应用程序作为一个docker的镜像来使用，这也是docker官方推荐的做法。\n\n2.docker-compose是官方的编排应用。官方有django的设置。今天你测试了以下自己的环境。记录一下。\n\n3.首先我们使用的是django和postgresql数据库。然后需要拉取postgresql数据库。先看一下`docker-compose.yaml`文件。\n\n```\nversion: '3'\n\nservices:\n  db:\n    image: postgres #依赖的镜像，若没有则会自动从dockerhub获取\n    volumes:\n      - ./postgres-data:/var/lib/postgresql/data #挂载数据库文件，因为如果不挂载，那么容易起一停止数据就没了。运行的数据都会同步到这里\n  web:\n    build: .  #这部分是值相当于docker build，会自动寻找Dockerfile，.代表当前目录。\n    command: python manage.py runserver 0.0.0.0:8000  #启动命令。\n    volumes:\n      - .:/code  #也是挂载web的一些代码\n    ports:\n      - \"8000:8000\"  #端口映射\n    depends_on:\n      - db  #这里是依赖，那么就是先启动了db\n```\n<!-- more -->\n4.由于使用的pqsql，所以我们在settings需要更改。\n如下\n```\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': 'postgres',\n        'USER': 'postgres',\n        'HOST': 'db',\n        'PORT': 5432,\n    }\n}\n```\n5. 这个时候已经可以启动了，并且使用的是pqsql，因为我需要导入一些测试数据。先运行这写代码,在包含yml的文件的目录下运行\n```\ndocker-compose config ##检查yml文件格式\ndocker-compose config --service  ##显示service\ndocker-compose run web python manage.py migrate\ndocker-compose run web python manage.py loaddata test_auth.json\ndocker-compose run web python manage.py loaddata test_management.json\ndocker-comnpose run web python manage.py loaddata test_location.json\ndocker-compose up ##启动\n```\n6. 晚上加个班，加上一层nginx,Dockerfile如下\n```\nFROM nginx\n\n\n#对外暴露端口\nEXPOSE 8005\n\nRUN rm /etc/nginx/conf.d/default.conf\n\nADD localhost.conf  /etc/nginx/conf.d/\n\n\n```\nlocalhost.conf如下\n\n```\nserver {\n    charset utf-8;\n    listen 8005;\n    server_name 127.0.0.1;\n    \n    error_log /var/nginx_error.log;\n    access_log /var/nginx_access.log;\n\n    location /static {\n\talias /var/www/static/guacamole;\n    }\n    location / {\n\tproxy_set_header Host $host;\n\tproxy_pass http://web:8000;  ##注意这里写service web的名字，找了好久的错误\n    }\n}\n\n```\n最后修改docker-compose.yml如下\n```\nversion: '3'\n\nservices:\n  db:\n    image: postgres\n    volumes:\n      - ./postgres-data:/var/lib/postgresql/data\n  web:\n    build: .\n    command: python manage.py runserver 0.0.0.0:8000\n    volumes:\n      - .:/code\n    depends_on:\n      - db\n  nginx:\n    build: ./nginx\n    volumes:\n      - /var/www/static/guacamole:/var/www/static/guacamole\n    ports:\n      - \"8005:8005\"\n    depends_on:\n      - web\n```\n最后执行 `docker-compose up`即可，访问127.0.01:8005便可以访问到服务。\n\n7.等待套一层gunicorn\n8.有个bug，有时候数据库最后启动导致服务启动不了，等待查看原因。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"docker-compose的使用","published":1,"updated":"2022-05-20T02:24:20.541Z","comments":1,"photos":[],"link":"","_id":"cl3e0vh7e000clae1bg2s060o","content":"<h2 id=\"记录docker-compose的使用\"><a href=\"#记录docker-compose的使用\" class=\"headerlink\" title=\"记录docker-compose的使用\"></a><center>记录docker-compose的使用</center></h2><p>1.使用docker-compose的目的: 我么一般把web和数据库进行分离，每个应用程序作为一个docker的镜像来使用，这也是docker官方推荐的做法。</p>\n<p>2.docker-compose是官方的编排应用。官方有django的设置。今天你测试了以下自己的环境。记录一下。</p>\n<p>3.首先我们使用的是django和postgresql数据库。然后需要拉取postgresql数据库。先看一下<code>docker-compose.yaml</code>文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version: &apos;3&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">services:</span><br><span class=\"line\">  db:</span><br><span class=\"line\">    image: postgres #依赖的镜像，若没有则会自动从dockerhub获取</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - ./postgres-data:/var/lib/postgresql/data #挂载数据库文件，因为如果不挂载，那么容易起一停止数据就没了。运行的数据都会同步到这里</span><br><span class=\"line\">  web:</span><br><span class=\"line\">    build: .  #这部分是值相当于docker build，会自动寻找Dockerfile，.代表当前目录。</span><br><span class=\"line\">    command: python manage.py runserver 0.0.0.0:8000  #启动命令。</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - .:/code  #也是挂载web的一些代码</span><br><span class=\"line\">    ports:</span><br><span class=\"line\">      - &quot;8000:8000&quot;  #端口映射</span><br><span class=\"line\">    depends_on:</span><br><span class=\"line\">      - db  #这里是依赖，那么就是先启动了db</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>4.由于使用的pqsql，所以我们在settings需要更改。<br>如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATABASES = &#123;</span><br><span class=\"line\">    &apos;default&apos;: &#123;</span><br><span class=\"line\">        &apos;ENGINE&apos;: &apos;django.db.backends.postgresql&apos;,</span><br><span class=\"line\">        &apos;NAME&apos;: &apos;postgres&apos;,</span><br><span class=\"line\">        &apos;USER&apos;: &apos;postgres&apos;,</span><br><span class=\"line\">        &apos;HOST&apos;: &apos;db&apos;,</span><br><span class=\"line\">        &apos;PORT&apos;: 5432,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"5\">\n<li><p>这个时候已经可以启动了，并且使用的是pqsql，因为我需要导入一些测试数据。先运行这写代码,在包含yml的文件的目录下运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose config ##检查yml文件格式</span><br><span class=\"line\">docker-compose config --service  ##显示service</span><br><span class=\"line\">docker-compose run web python manage.py migrate</span><br><span class=\"line\">docker-compose run web python manage.py loaddata test_auth.json</span><br><span class=\"line\">docker-compose run web python manage.py loaddata test_management.json</span><br><span class=\"line\">docker-comnpose run web python manage.py loaddata test_location.json</span><br><span class=\"line\">docker-compose up ##启动</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>晚上加个班，加上一层nginx,Dockerfile如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nginx</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#对外暴露端口</span><br><span class=\"line\">EXPOSE 8005</span><br><span class=\"line\"></span><br><span class=\"line\">RUN rm /etc/nginx/conf.d/default.conf</span><br><span class=\"line\"></span><br><span class=\"line\">ADD localhost.conf  /etc/nginx/conf.d/</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>localhost.conf如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    charset utf-8;</span><br><span class=\"line\">    listen 8005;</span><br><span class=\"line\">    server_name 127.0.0.1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    error_log /var/nginx_error.log;</span><br><span class=\"line\">    access_log /var/nginx_access.log;</span><br><span class=\"line\"></span><br><span class=\"line\">    location /static &#123;</span><br><span class=\"line\">\talias /var/www/static/guacamole;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">\tproxy_set_header Host $host;</span><br><span class=\"line\">\tproxy_pass http://web:8000;  ##注意这里写service web的名字，找了好久的错误</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后修改docker-compose.yml如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version: &apos;3&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">services:</span><br><span class=\"line\">  db:</span><br><span class=\"line\">    image: postgres</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - ./postgres-data:/var/lib/postgresql/data</span><br><span class=\"line\">  web:</span><br><span class=\"line\">    build: .</span><br><span class=\"line\">    command: python manage.py runserver 0.0.0.0:8000</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - .:/code</span><br><span class=\"line\">    depends_on:</span><br><span class=\"line\">      - db</span><br><span class=\"line\">  nginx:</span><br><span class=\"line\">    build: ./nginx</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - /var/www/static/guacamole:/var/www/static/guacamole</span><br><span class=\"line\">    ports:</span><br><span class=\"line\">      - &quot;8005:8005&quot;</span><br><span class=\"line\">    depends_on:</span><br><span class=\"line\">      - web</span><br></pre></td></tr></table></figure></p>\n<p>最后执行 <code>docker-compose up</code>即可，访问127.0.01:8005便可以访问到服务。</p>\n<p>7.等待套一层gunicorn<br>8.有个bug，有时候数据库最后启动导致服务启动不了，等待查看原因。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"记录docker-compose的使用\"><a href=\"#记录docker-compose的使用\" class=\"headerlink\" title=\"记录docker-compose的使用\"></a><center>记录docker-compose的使用</center></h2><p>1.使用docker-compose的目的: 我么一般把web和数据库进行分离，每个应用程序作为一个docker的镜像来使用，这也是docker官方推荐的做法。</p>\n<p>2.docker-compose是官方的编排应用。官方有django的设置。今天你测试了以下自己的环境。记录一下。</p>\n<p>3.首先我们使用的是django和postgresql数据库。然后需要拉取postgresql数据库。先看一下<code>docker-compose.yaml</code>文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version: &apos;3&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">services:</span><br><span class=\"line\">  db:</span><br><span class=\"line\">    image: postgres #依赖的镜像，若没有则会自动从dockerhub获取</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - ./postgres-data:/var/lib/postgresql/data #挂载数据库文件，因为如果不挂载，那么容易起一停止数据就没了。运行的数据都会同步到这里</span><br><span class=\"line\">  web:</span><br><span class=\"line\">    build: .  #这部分是值相当于docker build，会自动寻找Dockerfile，.代表当前目录。</span><br><span class=\"line\">    command: python manage.py runserver 0.0.0.0:8000  #启动命令。</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - .:/code  #也是挂载web的一些代码</span><br><span class=\"line\">    ports:</span><br><span class=\"line\">      - &quot;8000:8000&quot;  #端口映射</span><br><span class=\"line\">    depends_on:</span><br><span class=\"line\">      - db  #这里是依赖，那么就是先启动了db</span><br></pre></td></tr></table></figure>","more":"<p>4.由于使用的pqsql，所以我们在settings需要更改。<br>如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATABASES = &#123;</span><br><span class=\"line\">    &apos;default&apos;: &#123;</span><br><span class=\"line\">        &apos;ENGINE&apos;: &apos;django.db.backends.postgresql&apos;,</span><br><span class=\"line\">        &apos;NAME&apos;: &apos;postgres&apos;,</span><br><span class=\"line\">        &apos;USER&apos;: &apos;postgres&apos;,</span><br><span class=\"line\">        &apos;HOST&apos;: &apos;db&apos;,</span><br><span class=\"line\">        &apos;PORT&apos;: 5432,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"5\">\n<li><p>这个时候已经可以启动了，并且使用的是pqsql，因为我需要导入一些测试数据。先运行这写代码,在包含yml的文件的目录下运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose config ##检查yml文件格式</span><br><span class=\"line\">docker-compose config --service  ##显示service</span><br><span class=\"line\">docker-compose run web python manage.py migrate</span><br><span class=\"line\">docker-compose run web python manage.py loaddata test_auth.json</span><br><span class=\"line\">docker-compose run web python manage.py loaddata test_management.json</span><br><span class=\"line\">docker-comnpose run web python manage.py loaddata test_location.json</span><br><span class=\"line\">docker-compose up ##启动</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>晚上加个班，加上一层nginx,Dockerfile如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nginx</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#对外暴露端口</span><br><span class=\"line\">EXPOSE 8005</span><br><span class=\"line\"></span><br><span class=\"line\">RUN rm /etc/nginx/conf.d/default.conf</span><br><span class=\"line\"></span><br><span class=\"line\">ADD localhost.conf  /etc/nginx/conf.d/</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>localhost.conf如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    charset utf-8;</span><br><span class=\"line\">    listen 8005;</span><br><span class=\"line\">    server_name 127.0.0.1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    error_log /var/nginx_error.log;</span><br><span class=\"line\">    access_log /var/nginx_access.log;</span><br><span class=\"line\"></span><br><span class=\"line\">    location /static &#123;</span><br><span class=\"line\">\talias /var/www/static/guacamole;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">\tproxy_set_header Host $host;</span><br><span class=\"line\">\tproxy_pass http://web:8000;  ##注意这里写service web的名字，找了好久的错误</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后修改docker-compose.yml如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version: &apos;3&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">services:</span><br><span class=\"line\">  db:</span><br><span class=\"line\">    image: postgres</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - ./postgres-data:/var/lib/postgresql/data</span><br><span class=\"line\">  web:</span><br><span class=\"line\">    build: .</span><br><span class=\"line\">    command: python manage.py runserver 0.0.0.0:8000</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - .:/code</span><br><span class=\"line\">    depends_on:</span><br><span class=\"line\">      - db</span><br><span class=\"line\">  nginx:</span><br><span class=\"line\">    build: ./nginx</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - /var/www/static/guacamole:/var/www/static/guacamole</span><br><span class=\"line\">    ports:</span><br><span class=\"line\">      - &quot;8005:8005&quot;</span><br><span class=\"line\">    depends_on:</span><br><span class=\"line\">      - web</span><br></pre></td></tr></table></figure></p>\n<p>最后执行 <code>docker-compose up</code>即可，访问127.0.01:8005便可以访问到服务。</p>\n<p>7.等待套一层gunicorn<br>8.有个bug，有时候数据库最后启动导致服务启动不了，等待查看原因。</p>"},{"title":"docker部署记录文件","date":"2018-12-09T02:33:09.000Z","_content":"docker部署记录\n1.文件位置 /var/www/powerpred    \n\n2.收集静态文件位置 /var/www/static\n\n3.80占用? netstat -ano | grep 80找到，kill掉pid\n4 进入container \n```\ndocker run -it -p 80:80 test:v4\n```\n进入到相应的web目录\n```\npython3 manage.py runserver 0.0.0.0:8000\n```\nok，此时可以访问。\n","source":"_posts/docker部署.mkd","raw":"---\ntitle: docker部署记录文件\ndate: 2018-12-09 10:33:09\ntags: dcoker\ncategories: docker\n---\ndocker部署记录\n1.文件位置 /var/www/powerpred    \n\n2.收集静态文件位置 /var/www/static\n\n3.80占用? netstat -ano | grep 80找到，kill掉pid\n4 进入container \n```\ndocker run -it -p 80:80 test:v4\n```\n进入到相应的web目录\n```\npython3 manage.py runserver 0.0.0.0:8000\n```\nok，此时可以访问。\n","slug":"docker部署","published":1,"updated":"2022-05-20T02:24:20.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7e000dlae12hr3xkm2","content":"<p>docker部署记录<br>1.文件位置 /var/www/powerpred    </p>\n<p>2.收集静态文件位置 /var/www/static</p>\n<p>3.80占用? netstat -ano | grep 80找到，kill掉pid<br>4 进入container<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -p 80:80 test:v4</span><br></pre></td></tr></table></figure></p>\n<p>进入到相应的web目录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 manage.py runserver 0.0.0.0:8000</span><br></pre></td></tr></table></figure></p>\n<p>ok，此时可以访问。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>docker部署记录<br>1.文件位置 /var/www/powerpred    </p>\n<p>2.收集静态文件位置 /var/www/static</p>\n<p>3.80占用? netstat -ano | grep 80找到，kill掉pid<br>4 进入container<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -p 80:80 test:v4</span><br></pre></td></tr></table></figure></p>\n<p>进入到相应的web目录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 manage.py runserver 0.0.0.0:8000</span><br></pre></td></tr></table></figure></p>\n<p>ok，此时可以访问。</p>\n"},{"layout":"posts","title":"docker和宿主机同时部署","date":"2019-04-16T13:36:25.000Z","_content":"今天完成的是在docker中部署一个服务，然后宿主机也部署一个服务。将二者回顾一下。\n\n问题:使用docker部署的时候，不需要宿主机的nginx来工作，但是当有俩服务，如果docker还用80端口映射，那么宿主机的web服务的nginx则无法工作，那么此时我们需要映射到其他端口，再用宿主的nginx来代理反代docker的服务。\n\n1.在docker中部署一个nginx服务，上文已经介绍过了，在docker中我们可以像宿主机一样来部署nginx，在`/etc/nginx/sites-enabled/`下新建一个文件，命名为powerped.cc，我们监听的是内容就和上文一样，然后需要映射为81:8000，把docker的8000端口映射到宿主机的81端口，proxy_pass在我们测试时，可以填写127.0.0.1:81,然后回到网页的目录执行`python3 manage.py runserver 127.0.0.1:81`，如果网页可以访问了，说明可以，我们再使用gunicorn启动，`gunicorn --bind unix:/tmp/windystreet.cn.socket ppower.wsgi:application`，同时powerpred.cc的proxy_pass的地址也改为`http://unix:/tmp/windystreet.cn.socket;`,保证一致。\n<!-- more -->\n\n2.在宿主机部署另一个web服务，此时我们把映射的docker的81的端口使用nginx代理，同时也代理另一个web服务叫guacamole(web名字而已)，在宿主机的`/etc/nginx/sites-enabled/`新建guacamole，同时新建powrepred，二者均监听80端口。powerpred即需要反代docker的服务，内容如下\n```\nserver {\n\tcharset utf-8;\n\tlisten 80;\n\tserver_name windystreet.cn;\n\t\n\tlocation / {\n\t\tproxy_set_header Host $host;\n\t\tproxy_pass http://127.0.0.1:81;\n\t}\n}\n```\n由于我们映射到宿主机的81端口，反代地址为127.0.0.1:81,且静态文件已经由docker的nginx代理完毕。    \nguacamole的内容如下：\n```\nserver {\n        charset utf-8;\n        listen 80;\n        server_name common.windystreet.cn;\n\n        location /static {\n                alias /var/www/static/guacamole;\n        }\n        location / {\n                proxy_set_header Host $host;\n                proxy_pass http://unix:/tmp/common.windystreet.cn.socket;\n        }\n}\n\n```\n这里依然监听80端口，但是代理的位置不同。\n`service nginx start`\n我们切换到gucamole的目录下`gunicorn --bind unix:/tmp/common.windystreet.cn.socket guacamole.wsgi:application`启动，\n然后分别访问'windystreet.cn'和'common.windystreet.cn'会发现这是两个不同的服务。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/docker和宿主机同时部署.md","raw":"---\nlayout: posts\ntitle: docker和宿主机同时部署\ndate: 2019-04-16 21:36:25\ntags: docker\ncategories: docker\n---\n今天完成的是在docker中部署一个服务，然后宿主机也部署一个服务。将二者回顾一下。\n\n问题:使用docker部署的时候，不需要宿主机的nginx来工作，但是当有俩服务，如果docker还用80端口映射，那么宿主机的web服务的nginx则无法工作，那么此时我们需要映射到其他端口，再用宿主的nginx来代理反代docker的服务。\n\n1.在docker中部署一个nginx服务，上文已经介绍过了，在docker中我们可以像宿主机一样来部署nginx，在`/etc/nginx/sites-enabled/`下新建一个文件，命名为powerped.cc，我们监听的是内容就和上文一样，然后需要映射为81:8000，把docker的8000端口映射到宿主机的81端口，proxy_pass在我们测试时，可以填写127.0.0.1:81,然后回到网页的目录执行`python3 manage.py runserver 127.0.0.1:81`，如果网页可以访问了，说明可以，我们再使用gunicorn启动，`gunicorn --bind unix:/tmp/windystreet.cn.socket ppower.wsgi:application`，同时powerpred.cc的proxy_pass的地址也改为`http://unix:/tmp/windystreet.cn.socket;`,保证一致。\n<!-- more -->\n\n2.在宿主机部署另一个web服务，此时我们把映射的docker的81的端口使用nginx代理，同时也代理另一个web服务叫guacamole(web名字而已)，在宿主机的`/etc/nginx/sites-enabled/`新建guacamole，同时新建powrepred，二者均监听80端口。powerpred即需要反代docker的服务，内容如下\n```\nserver {\n\tcharset utf-8;\n\tlisten 80;\n\tserver_name windystreet.cn;\n\t\n\tlocation / {\n\t\tproxy_set_header Host $host;\n\t\tproxy_pass http://127.0.0.1:81;\n\t}\n}\n```\n由于我们映射到宿主机的81端口，反代地址为127.0.0.1:81,且静态文件已经由docker的nginx代理完毕。    \nguacamole的内容如下：\n```\nserver {\n        charset utf-8;\n        listen 80;\n        server_name common.windystreet.cn;\n\n        location /static {\n                alias /var/www/static/guacamole;\n        }\n        location / {\n                proxy_set_header Host $host;\n                proxy_pass http://unix:/tmp/common.windystreet.cn.socket;\n        }\n}\n\n```\n这里依然监听80端口，但是代理的位置不同。\n`service nginx start`\n我们切换到gucamole的目录下`gunicorn --bind unix:/tmp/common.windystreet.cn.socket guacamole.wsgi:application`启动，\n然后分别访问'windystreet.cn'和'common.windystreet.cn'会发现这是两个不同的服务。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"docker和宿主机同时部署","published":1,"updated":"2022-05-20T02:24:20.541Z","comments":1,"photos":[],"link":"","_id":"cl3e0vh7g000ilae1z44pw3q8","content":"<p>今天完成的是在docker中部署一个服务，然后宿主机也部署一个服务。将二者回顾一下。</p>\n<p>问题:使用docker部署的时候，不需要宿主机的nginx来工作，但是当有俩服务，如果docker还用80端口映射，那么宿主机的web服务的nginx则无法工作，那么此时我们需要映射到其他端口，再用宿主的nginx来代理反代docker的服务。</p>\n<p>1.在docker中部署一个nginx服务，上文已经介绍过了，在docker中我们可以像宿主机一样来部署nginx，在<code>/etc/nginx/sites-enabled/</code>下新建一个文件，命名为powerped.cc，我们监听的是内容就和上文一样，然后需要映射为81:8000，把docker的8000端口映射到宿主机的81端口，proxy_pass在我们测试时，可以填写127.0.0.1:81,然后回到网页的目录执行<code>python3 manage.py runserver 127.0.0.1:81</code>，如果网页可以访问了，说明可以，我们再使用gunicorn启动，<code>gunicorn --bind unix:/tmp/windystreet.cn.socket ppower.wsgi:application</code>，同时powerpred.cc的proxy_pass的地址也改为<code>http://unix:/tmp/windystreet.cn.socket;</code>,保证一致。<br><a id=\"more\"></a></p>\n<p>2.在宿主机部署另一个web服务，此时我们把映射的docker的81的端口使用nginx代理，同时也代理另一个web服务叫guacamole(web名字而已)，在宿主机的<code>/etc/nginx/sites-enabled/</code>新建guacamole，同时新建powrepred，二者均监听80端口。powerpred即需要反代docker的服务，内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tcharset utf-8;</span><br><span class=\"line\">\tlisten 80;</span><br><span class=\"line\">\tserver_name windystreet.cn;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">\t\tproxy_set_header Host $host;</span><br><span class=\"line\">\t\tproxy_pass http://127.0.0.1:81;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于我们映射到宿主机的81端口，反代地址为127.0.0.1:81,且静态文件已经由docker的nginx代理完毕。<br>guacamole的内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">        charset utf-8;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name common.windystreet.cn;</span><br><span class=\"line\"></span><br><span class=\"line\">        location /static &#123;</span><br><span class=\"line\">                alias /var/www/static/guacamole;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">                proxy_set_header Host $host;</span><br><span class=\"line\">                proxy_pass http://unix:/tmp/common.windystreet.cn.socket;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里依然监听80端口，但是代理的位置不同。<br><code>service nginx start</code><br>我们切换到gucamole的目录下<code>gunicorn --bind unix:/tmp/common.windystreet.cn.socket guacamole.wsgi:application</code>启动，<br>然后分别访问’windystreet.cn’和’common.windystreet.cn’会发现这是两个不同的服务。</p>\n","site":{"data":{}},"excerpt":"<p>今天完成的是在docker中部署一个服务，然后宿主机也部署一个服务。将二者回顾一下。</p>\n<p>问题:使用docker部署的时候，不需要宿主机的nginx来工作，但是当有俩服务，如果docker还用80端口映射，那么宿主机的web服务的nginx则无法工作，那么此时我们需要映射到其他端口，再用宿主的nginx来代理反代docker的服务。</p>\n<p>1.在docker中部署一个nginx服务，上文已经介绍过了，在docker中我们可以像宿主机一样来部署nginx，在<code>/etc/nginx/sites-enabled/</code>下新建一个文件，命名为powerped.cc，我们监听的是内容就和上文一样，然后需要映射为81:8000，把docker的8000端口映射到宿主机的81端口，proxy_pass在我们测试时，可以填写127.0.0.1:81,然后回到网页的目录执行<code>python3 manage.py runserver 127.0.0.1:81</code>，如果网页可以访问了，说明可以，我们再使用gunicorn启动，<code>gunicorn --bind unix:/tmp/windystreet.cn.socket ppower.wsgi:application</code>，同时powerpred.cc的proxy_pass的地址也改为<code>http://unix:/tmp/windystreet.cn.socket;</code>,保证一致。<br>","more":"</p>\n<p>2.在宿主机部署另一个web服务，此时我们把映射的docker的81的端口使用nginx代理，同时也代理另一个web服务叫guacamole(web名字而已)，在宿主机的<code>/etc/nginx/sites-enabled/</code>新建guacamole，同时新建powrepred，二者均监听80端口。powerpred即需要反代docker的服务，内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tcharset utf-8;</span><br><span class=\"line\">\tlisten 80;</span><br><span class=\"line\">\tserver_name windystreet.cn;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">\t\tproxy_set_header Host $host;</span><br><span class=\"line\">\t\tproxy_pass http://127.0.0.1:81;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于我们映射到宿主机的81端口，反代地址为127.0.0.1:81,且静态文件已经由docker的nginx代理完毕。<br>guacamole的内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">        charset utf-8;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name common.windystreet.cn;</span><br><span class=\"line\"></span><br><span class=\"line\">        location /static &#123;</span><br><span class=\"line\">                alias /var/www/static/guacamole;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">                proxy_set_header Host $host;</span><br><span class=\"line\">                proxy_pass http://unix:/tmp/common.windystreet.cn.socket;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里依然监听80端口，但是代理的位置不同。<br><code>service nginx start</code><br>我们切换到gucamole的目录下<code>gunicorn --bind unix:/tmp/common.windystreet.cn.socket guacamole.wsgi:application</code>启动，<br>然后分别访问’windystreet.cn’和’common.windystreet.cn’会发现这是两个不同的服务。</p>"},{"layout":"posts","title":"es6-1","date":"2019-03-19T12:05:24.000Z","_content":"#### 数据类型\n\n- 数字\n- 字符串\n- 布尔\n- null\n- undefined\n- object\n- 符号(symbol)\n\n##### 字符串\n\n增加了模板字符串，避免经常使用+\n```\n例如\nlet a = 'dog'\nlet b = 'lili'\nlet message = `this is my ${a} named ${b}` ##反丿号\n```\n多行字符串也可使用反丿号包裹\n```\nconst a = `line1\n            line2`\n\n```\n<!-- more -->\n#### 符号\n\n符号是ES6的新特性，它是一种新的数据类型，代表一个唯一的标志，符号一经创建就是独一无二的，他不会匹配其他任何符号。\n```\nconst red = Symbol()\nconst oranger = Symbol(\"The color of a sunset!\")\nred === oranger //false\n```\n\n#### null和undefined\n\njs的两种特殊类型，null和undefined，他们俩都有一个唯一的值，分别为null和undefined，这两者都代表不存在。    \n一般来说，null是给开发者用的，而undefined是给js用的，用来表示未赋值的内容。当需要表示一个变量的值是`未知`或者不适用的时候，常见的做法是null。`当声明的变量没有赋值的时候，变量会有一个默认值undefined`。\n```\nlet currentTime  //隐含值undefined\nconst taget = null  //target为null，代表还不知道,const声明要赋值\ncurrentTime = 19.7\n```\n\n### 对象\n对象与基本类型不太一致，基本类型只能代表一个值，而对象可以代表多个值或者复杂的值。\n```\nconst obj = {}\n```\n\n对象的内容成为属性，属性由键和值组成。对象还可以包含函数\n```\nobj.size = function () {\n    return 'xxxx'\n}\n```\n通过delete来删除属性\n```\ndelete obj.size  //返回true\n\n```\n\n#### 日期\n\n```\nconst now = new Date()\nconst hallween = new Date(2019, 2, 18) //月份中0开始\nconst time_now = new Date(2019, 9, 31, 19, 0)\n\ntime_now.getFullYear() //2019\ntime_now.getMonth()  //9\ntime_now.getDate()  //31\ntime_now.getDay()  //对着英文的0=Sunday,1=Monday\ntime_now.getHours()  //19\ntime_now.getMinutes()  //0\ntime_now.getSeconds()  //0\ntime_now.getMillseconds() //0\n```\n\n#### 映射和集合\n\nES6引入了Map和Set，及他们的弱引用类型WeakMap和WeakSet\n\n#### 数据转化\n\n##### 转化为数字\n字符串转化为数字\n1.使用Number\n```\nconst numStr = \"33.3\"\nconst num = Number(numStr) //如果字符串不符合数字格式返回NaN\n```\n2.使用ParseInt和ParseFloat,其可以跟进制\n3.日期转化为数字\n```\nconst d = new Date()\nconst ts = d.valueOf() //返回毫秒数，距utc时间\n```\n\n##### 转化为字符串\n\njs的任何对象都有toString()方法，数组的比较实用。\n```\nconst arr = [1, true, 'hello']\narr.toString() // \"1,true,hello\"\n```\n\n#### 真值和假值\n\n下面的值在js都为false\n\n- undefined\n- null\n- false\n- 0 \n- NaN\n- ''\n以下为部分真值：\n- 所有对象(包括valueOf()返回的false对象)\n- 所有数组包括空数组\n- 仅仅包含空格的字符串\n- 字符串\"false\"\n\n#### 短路求值\n```\nconst skip = true\nlet x = 0\nconst result = skip || x++  //true,由于为true，那么直接返回而不计算x++,若为false，两个都执行则result为0，\n\n\nconst doit = false\nlet x = 0\nconst result = doit && x++ //false，如果doit为true,结果还是result=0,而不是false？\n```\n#### 算术运算符\n\n- x++:后置自增运算符，给x的值加1，并在x增加前计算它的值\n- ++x:前置自增运算符，给x的值加1，并计算他的值\n\n```\nlet x = 2\nconst r1 = x++ + x++  //分解第一个x++,在x的值变为3，那么x++是计算自增前的值，即为(2+3)，结果为5，而x为4.\nconst r2 = ++x + ++x  //分解第一个++x，x的值变为5，为(5+6) =11 ,x的值为6\nconst r3 = x++ + ++x  //分解第一个x++,x的值变为7，x++计算之前，(6+8)=14, x的值为8\n\nlet y = 10\nconst z = y++ ;z为10;y为11\n\n```\n\n#### 数字的比较\n\n例子\n```\nlet n = 0\nwhile(true) {\n    n += 0.1\n    if(n === 0.3) {\n        break;\n    }\n}\nconsole.log(n)\n```\n这里跳过0.3，由于0.1不能精确代表一个双精度值。可使用Number.EPSILON,代表一个非常小的数字\n```\nlet n = 0\nwhile (true) {\n    n += 0.1\n    if (Math.abs(n - 0.3) < Numbers.EPSILON) {\n        break;\n    }\n}\n\n```\n\n#### 类判断运算符\n\n- typeof(undefined): \"undefined\"\n- typeof(null): \"object\" //没办法\n- typeof({}): \"object\"\n- typeof(true): \"boolean\"\n- typeof(1): \"number\"\n- typeof(\"\"): \"string\"\n- typeof(Symbol()): \"symbol\"\n- typeof(function(){}): \"function\"\n\n#### 赋值运算符\n\n```\nlet v, v0;\nv = v0 = 9.8 //链式赋值，先给v0赋值9.8，然后给v赋值9.8\n```\n\n#### 解构赋值\n\n前文已写过\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/es6-1.md","raw":"---\nlayout: posts\ntitle: es6-1\ndate: 2019-03-19 20:05:24\ntags: ES6\ncategories: ES6\n---\n#### 数据类型\n\n- 数字\n- 字符串\n- 布尔\n- null\n- undefined\n- object\n- 符号(symbol)\n\n##### 字符串\n\n增加了模板字符串，避免经常使用+\n```\n例如\nlet a = 'dog'\nlet b = 'lili'\nlet message = `this is my ${a} named ${b}` ##反丿号\n```\n多行字符串也可使用反丿号包裹\n```\nconst a = `line1\n            line2`\n\n```\n<!-- more -->\n#### 符号\n\n符号是ES6的新特性，它是一种新的数据类型，代表一个唯一的标志，符号一经创建就是独一无二的，他不会匹配其他任何符号。\n```\nconst red = Symbol()\nconst oranger = Symbol(\"The color of a sunset!\")\nred === oranger //false\n```\n\n#### null和undefined\n\njs的两种特殊类型，null和undefined，他们俩都有一个唯一的值，分别为null和undefined，这两者都代表不存在。    \n一般来说，null是给开发者用的，而undefined是给js用的，用来表示未赋值的内容。当需要表示一个变量的值是`未知`或者不适用的时候，常见的做法是null。`当声明的变量没有赋值的时候，变量会有一个默认值undefined`。\n```\nlet currentTime  //隐含值undefined\nconst taget = null  //target为null，代表还不知道,const声明要赋值\ncurrentTime = 19.7\n```\n\n### 对象\n对象与基本类型不太一致，基本类型只能代表一个值，而对象可以代表多个值或者复杂的值。\n```\nconst obj = {}\n```\n\n对象的内容成为属性，属性由键和值组成。对象还可以包含函数\n```\nobj.size = function () {\n    return 'xxxx'\n}\n```\n通过delete来删除属性\n```\ndelete obj.size  //返回true\n\n```\n\n#### 日期\n\n```\nconst now = new Date()\nconst hallween = new Date(2019, 2, 18) //月份中0开始\nconst time_now = new Date(2019, 9, 31, 19, 0)\n\ntime_now.getFullYear() //2019\ntime_now.getMonth()  //9\ntime_now.getDate()  //31\ntime_now.getDay()  //对着英文的0=Sunday,1=Monday\ntime_now.getHours()  //19\ntime_now.getMinutes()  //0\ntime_now.getSeconds()  //0\ntime_now.getMillseconds() //0\n```\n\n#### 映射和集合\n\nES6引入了Map和Set，及他们的弱引用类型WeakMap和WeakSet\n\n#### 数据转化\n\n##### 转化为数字\n字符串转化为数字\n1.使用Number\n```\nconst numStr = \"33.3\"\nconst num = Number(numStr) //如果字符串不符合数字格式返回NaN\n```\n2.使用ParseInt和ParseFloat,其可以跟进制\n3.日期转化为数字\n```\nconst d = new Date()\nconst ts = d.valueOf() //返回毫秒数，距utc时间\n```\n\n##### 转化为字符串\n\njs的任何对象都有toString()方法，数组的比较实用。\n```\nconst arr = [1, true, 'hello']\narr.toString() // \"1,true,hello\"\n```\n\n#### 真值和假值\n\n下面的值在js都为false\n\n- undefined\n- null\n- false\n- 0 \n- NaN\n- ''\n以下为部分真值：\n- 所有对象(包括valueOf()返回的false对象)\n- 所有数组包括空数组\n- 仅仅包含空格的字符串\n- 字符串\"false\"\n\n#### 短路求值\n```\nconst skip = true\nlet x = 0\nconst result = skip || x++  //true,由于为true，那么直接返回而不计算x++,若为false，两个都执行则result为0，\n\n\nconst doit = false\nlet x = 0\nconst result = doit && x++ //false，如果doit为true,结果还是result=0,而不是false？\n```\n#### 算术运算符\n\n- x++:后置自增运算符，给x的值加1，并在x增加前计算它的值\n- ++x:前置自增运算符，给x的值加1，并计算他的值\n\n```\nlet x = 2\nconst r1 = x++ + x++  //分解第一个x++,在x的值变为3，那么x++是计算自增前的值，即为(2+3)，结果为5，而x为4.\nconst r2 = ++x + ++x  //分解第一个++x，x的值变为5，为(5+6) =11 ,x的值为6\nconst r3 = x++ + ++x  //分解第一个x++,x的值变为7，x++计算之前，(6+8)=14, x的值为8\n\nlet y = 10\nconst z = y++ ;z为10;y为11\n\n```\n\n#### 数字的比较\n\n例子\n```\nlet n = 0\nwhile(true) {\n    n += 0.1\n    if(n === 0.3) {\n        break;\n    }\n}\nconsole.log(n)\n```\n这里跳过0.3，由于0.1不能精确代表一个双精度值。可使用Number.EPSILON,代表一个非常小的数字\n```\nlet n = 0\nwhile (true) {\n    n += 0.1\n    if (Math.abs(n - 0.3) < Numbers.EPSILON) {\n        break;\n    }\n}\n\n```\n\n#### 类判断运算符\n\n- typeof(undefined): \"undefined\"\n- typeof(null): \"object\" //没办法\n- typeof({}): \"object\"\n- typeof(true): \"boolean\"\n- typeof(1): \"number\"\n- typeof(\"\"): \"string\"\n- typeof(Symbol()): \"symbol\"\n- typeof(function(){}): \"function\"\n\n#### 赋值运算符\n\n```\nlet v, v0;\nv = v0 = 9.8 //链式赋值，先给v0赋值9.8，然后给v赋值9.8\n```\n\n#### 解构赋值\n\n前文已写过\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"es6-1","published":1,"updated":"2022-05-20T02:24:20.541Z","comments":1,"photos":[],"link":"","_id":"cl3e0vh7h000klae18kzuovdj","content":"<h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><ul>\n<li>数字</li>\n<li>字符串</li>\n<li>布尔</li>\n<li>null</li>\n<li>undefined</li>\n<li>object</li>\n<li>符号(symbol)</li>\n</ul>\n<h5 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h5><p>增加了模板字符串，避免经常使用+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如</span><br><span class=\"line\">let a = &apos;dog&apos;</span><br><span class=\"line\">let b = &apos;lili&apos;</span><br><span class=\"line\">let message = `this is my $&#123;a&#125; named $&#123;b&#125;` ##反丿号</span><br></pre></td></tr></table></figure></p>\n<p>多行字符串也可使用反丿号包裹<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = `line1</span><br><span class=\"line\">            line2`</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h4 id=\"符号\"><a href=\"#符号\" class=\"headerlink\" title=\"符号\"></a>符号</h4><p>符号是ES6的新特性，它是一种新的数据类型，代表一个唯一的标志，符号一经创建就是独一无二的，他不会匹配其他任何符号。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const red = Symbol()</span><br><span class=\"line\">const oranger = Symbol(&quot;The color of a sunset!&quot;)</span><br><span class=\"line\">red === oranger //false</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"null和undefined\"><a href=\"#null和undefined\" class=\"headerlink\" title=\"null和undefined\"></a>null和undefined</h4><p>js的两种特殊类型，null和undefined，他们俩都有一个唯一的值，分别为null和undefined，这两者都代表不存在。<br>一般来说，null是给开发者用的，而undefined是给js用的，用来表示未赋值的内容。当需要表示一个变量的值是<code>未知</code>或者不适用的时候，常见的做法是null。<code>当声明的变量没有赋值的时候，变量会有一个默认值undefined</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let currentTime  //隐含值undefined</span><br><span class=\"line\">const taget = null  //target为null，代表还不知道,const声明要赋值</span><br><span class=\"line\">currentTime = 19.7</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>对象与基本类型不太一致，基本类型只能代表一个值，而对象可以代表多个值或者复杂的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对象的内容成为属性，属性由键和值组成。对象还可以包含函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.size = function () &#123;</span><br><span class=\"line\">    return &apos;xxxx&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过delete来删除属性<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete obj.size  //返回true</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"日期\"><a href=\"#日期\" class=\"headerlink\" title=\"日期\"></a>日期</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const now = new Date()</span><br><span class=\"line\">const hallween = new Date(2019, 2, 18) //月份中0开始</span><br><span class=\"line\">const time_now = new Date(2019, 9, 31, 19, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">time_now.getFullYear() //2019</span><br><span class=\"line\">time_now.getMonth()  //9</span><br><span class=\"line\">time_now.getDate()  //31</span><br><span class=\"line\">time_now.getDay()  //对着英文的0=Sunday,1=Monday</span><br><span class=\"line\">time_now.getHours()  //19</span><br><span class=\"line\">time_now.getMinutes()  //0</span><br><span class=\"line\">time_now.getSeconds()  //0</span><br><span class=\"line\">time_now.getMillseconds() //0</span><br></pre></td></tr></table></figure>\n<h4 id=\"映射和集合\"><a href=\"#映射和集合\" class=\"headerlink\" title=\"映射和集合\"></a>映射和集合</h4><p>ES6引入了Map和Set，及他们的弱引用类型WeakMap和WeakSet</p>\n<h4 id=\"数据转化\"><a href=\"#数据转化\" class=\"headerlink\" title=\"数据转化\"></a>数据转化</h4><h5 id=\"转化为数字\"><a href=\"#转化为数字\" class=\"headerlink\" title=\"转化为数字\"></a>转化为数字</h5><p>字符串转化为数字<br>1.使用Number<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const numStr = &quot;33.3&quot;</span><br><span class=\"line\">const num = Number(numStr) //如果字符串不符合数字格式返回NaN</span><br></pre></td></tr></table></figure></p>\n<p>2.使用ParseInt和ParseFloat,其可以跟进制<br>3.日期转化为数字<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const d = new Date()</span><br><span class=\"line\">const ts = d.valueOf() //返回毫秒数，距utc时间</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"转化为字符串\"><a href=\"#转化为字符串\" class=\"headerlink\" title=\"转化为字符串\"></a>转化为字符串</h5><p>js的任何对象都有toString()方法，数组的比较实用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, true, &apos;hello&apos;]</span><br><span class=\"line\">arr.toString() // &quot;1,true,hello&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"真值和假值\"><a href=\"#真值和假值\" class=\"headerlink\" title=\"真值和假值\"></a>真值和假值</h4><p>下面的值在js都为false</p>\n<ul>\n<li>undefined</li>\n<li>null</li>\n<li>false</li>\n<li>0 </li>\n<li>NaN</li>\n<li>‘’<br>以下为部分真值：</li>\n<li>所有对象(包括valueOf()返回的false对象)</li>\n<li>所有数组包括空数组</li>\n<li>仅仅包含空格的字符串</li>\n<li>字符串”false”</li>\n</ul>\n<h4 id=\"短路求值\"><a href=\"#短路求值\" class=\"headerlink\" title=\"短路求值\"></a>短路求值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const skip = true</span><br><span class=\"line\">let x = 0</span><br><span class=\"line\">const result = skip || x++  //true,由于为true，那么直接返回而不计算x++,若为false，两个都执行则result为0，</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const doit = false</span><br><span class=\"line\">let x = 0</span><br><span class=\"line\">const result = doit &amp;&amp; x++ //false，如果doit为true,结果还是result=0,而不是false？</span><br></pre></td></tr></table></figure>\n<h4 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h4><ul>\n<li>x++:后置自增运算符，给x的值加1，并在x增加前计算它的值</li>\n<li>++x:前置自增运算符，给x的值加1，并计算他的值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x = 2</span><br><span class=\"line\">const r1 = x++ + x++  //分解第一个x++,在x的值变为3，那么x++是计算自增前的值，即为(2+3)，结果为5，而x为4.</span><br><span class=\"line\">const r2 = ++x + ++x  //分解第一个++x，x的值变为5，为(5+6) =11 ,x的值为6</span><br><span class=\"line\">const r3 = x++ + ++x  //分解第一个x++,x的值变为7，x++计算之前，(6+8)=14, x的值为8</span><br><span class=\"line\"></span><br><span class=\"line\">let y = 10</span><br><span class=\"line\">const z = y++ ;z为10;y为11</span><br></pre></td></tr></table></figure>\n<h4 id=\"数字的比较\"><a href=\"#数字的比较\" class=\"headerlink\" title=\"数字的比较\"></a>数字的比较</h4><p>例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let n = 0</span><br><span class=\"line\">while(true) &#123;</span><br><span class=\"line\">    n += 0.1</span><br><span class=\"line\">    if(n === 0.3) &#123;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(n)</span><br></pre></td></tr></table></figure></p>\n<p>这里跳过0.3，由于0.1不能精确代表一个双精度值。可使用Number.EPSILON,代表一个非常小的数字<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let n = 0</span><br><span class=\"line\">while (true) &#123;</span><br><span class=\"line\">    n += 0.1</span><br><span class=\"line\">    if (Math.abs(n - 0.3) &lt; Numbers.EPSILON) &#123;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"类判断运算符\"><a href=\"#类判断运算符\" class=\"headerlink\" title=\"类判断运算符\"></a>类判断运算符</h4><ul>\n<li>typeof(undefined): “undefined”</li>\n<li>typeof(null): “object” //没办法</li>\n<li>typeof({}): “object”</li>\n<li>typeof(true): “boolean”</li>\n<li>typeof(1): “number”</li>\n<li>typeof(“”): “string”</li>\n<li>typeof(Symbol()): “symbol”</li>\n<li>typeof(function(){}): “function”</li>\n</ul>\n<h4 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let v, v0;</span><br><span class=\"line\">v = v0 = 9.8 //链式赋值，先给v0赋值9.8，然后给v赋值9.8</span><br></pre></td></tr></table></figure>\n<h4 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h4><p>前文已写过</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><ul>\n<li>数字</li>\n<li>字符串</li>\n<li>布尔</li>\n<li>null</li>\n<li>undefined</li>\n<li>object</li>\n<li>符号(symbol)</li>\n</ul>\n<h5 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h5><p>增加了模板字符串，避免经常使用+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如</span><br><span class=\"line\">let a = &apos;dog&apos;</span><br><span class=\"line\">let b = &apos;lili&apos;</span><br><span class=\"line\">let message = `this is my $&#123;a&#125; named $&#123;b&#125;` ##反丿号</span><br></pre></td></tr></table></figure></p>\n<p>多行字符串也可使用反丿号包裹<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = `line1</span><br><span class=\"line\">            line2`</span><br></pre></td></tr></table></figure></p>","more":"<h4 id=\"符号\"><a href=\"#符号\" class=\"headerlink\" title=\"符号\"></a>符号</h4><p>符号是ES6的新特性，它是一种新的数据类型，代表一个唯一的标志，符号一经创建就是独一无二的，他不会匹配其他任何符号。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const red = Symbol()</span><br><span class=\"line\">const oranger = Symbol(&quot;The color of a sunset!&quot;)</span><br><span class=\"line\">red === oranger //false</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"null和undefined\"><a href=\"#null和undefined\" class=\"headerlink\" title=\"null和undefined\"></a>null和undefined</h4><p>js的两种特殊类型，null和undefined，他们俩都有一个唯一的值，分别为null和undefined，这两者都代表不存在。<br>一般来说，null是给开发者用的，而undefined是给js用的，用来表示未赋值的内容。当需要表示一个变量的值是<code>未知</code>或者不适用的时候，常见的做法是null。<code>当声明的变量没有赋值的时候，变量会有一个默认值undefined</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let currentTime  //隐含值undefined</span><br><span class=\"line\">const taget = null  //target为null，代表还不知道,const声明要赋值</span><br><span class=\"line\">currentTime = 19.7</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>对象与基本类型不太一致，基本类型只能代表一个值，而对象可以代表多个值或者复杂的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对象的内容成为属性，属性由键和值组成。对象还可以包含函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.size = function () &#123;</span><br><span class=\"line\">    return &apos;xxxx&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过delete来删除属性<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete obj.size  //返回true</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"日期\"><a href=\"#日期\" class=\"headerlink\" title=\"日期\"></a>日期</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const now = new Date()</span><br><span class=\"line\">const hallween = new Date(2019, 2, 18) //月份中0开始</span><br><span class=\"line\">const time_now = new Date(2019, 9, 31, 19, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">time_now.getFullYear() //2019</span><br><span class=\"line\">time_now.getMonth()  //9</span><br><span class=\"line\">time_now.getDate()  //31</span><br><span class=\"line\">time_now.getDay()  //对着英文的0=Sunday,1=Monday</span><br><span class=\"line\">time_now.getHours()  //19</span><br><span class=\"line\">time_now.getMinutes()  //0</span><br><span class=\"line\">time_now.getSeconds()  //0</span><br><span class=\"line\">time_now.getMillseconds() //0</span><br></pre></td></tr></table></figure>\n<h4 id=\"映射和集合\"><a href=\"#映射和集合\" class=\"headerlink\" title=\"映射和集合\"></a>映射和集合</h4><p>ES6引入了Map和Set，及他们的弱引用类型WeakMap和WeakSet</p>\n<h4 id=\"数据转化\"><a href=\"#数据转化\" class=\"headerlink\" title=\"数据转化\"></a>数据转化</h4><h5 id=\"转化为数字\"><a href=\"#转化为数字\" class=\"headerlink\" title=\"转化为数字\"></a>转化为数字</h5><p>字符串转化为数字<br>1.使用Number<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const numStr = &quot;33.3&quot;</span><br><span class=\"line\">const num = Number(numStr) //如果字符串不符合数字格式返回NaN</span><br></pre></td></tr></table></figure></p>\n<p>2.使用ParseInt和ParseFloat,其可以跟进制<br>3.日期转化为数字<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const d = new Date()</span><br><span class=\"line\">const ts = d.valueOf() //返回毫秒数，距utc时间</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"转化为字符串\"><a href=\"#转化为字符串\" class=\"headerlink\" title=\"转化为字符串\"></a>转化为字符串</h5><p>js的任何对象都有toString()方法，数组的比较实用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, true, &apos;hello&apos;]</span><br><span class=\"line\">arr.toString() // &quot;1,true,hello&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"真值和假值\"><a href=\"#真值和假值\" class=\"headerlink\" title=\"真值和假值\"></a>真值和假值</h4><p>下面的值在js都为false</p>\n<ul>\n<li>undefined</li>\n<li>null</li>\n<li>false</li>\n<li>0 </li>\n<li>NaN</li>\n<li>‘’<br>以下为部分真值：</li>\n<li>所有对象(包括valueOf()返回的false对象)</li>\n<li>所有数组包括空数组</li>\n<li>仅仅包含空格的字符串</li>\n<li>字符串”false”</li>\n</ul>\n<h4 id=\"短路求值\"><a href=\"#短路求值\" class=\"headerlink\" title=\"短路求值\"></a>短路求值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const skip = true</span><br><span class=\"line\">let x = 0</span><br><span class=\"line\">const result = skip || x++  //true,由于为true，那么直接返回而不计算x++,若为false，两个都执行则result为0，</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const doit = false</span><br><span class=\"line\">let x = 0</span><br><span class=\"line\">const result = doit &amp;&amp; x++ //false，如果doit为true,结果还是result=0,而不是false？</span><br></pre></td></tr></table></figure>\n<h4 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h4><ul>\n<li>x++:后置自增运算符，给x的值加1，并在x增加前计算它的值</li>\n<li>++x:前置自增运算符，给x的值加1，并计算他的值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x = 2</span><br><span class=\"line\">const r1 = x++ + x++  //分解第一个x++,在x的值变为3，那么x++是计算自增前的值，即为(2+3)，结果为5，而x为4.</span><br><span class=\"line\">const r2 = ++x + ++x  //分解第一个++x，x的值变为5，为(5+6) =11 ,x的值为6</span><br><span class=\"line\">const r3 = x++ + ++x  //分解第一个x++,x的值变为7，x++计算之前，(6+8)=14, x的值为8</span><br><span class=\"line\"></span><br><span class=\"line\">let y = 10</span><br><span class=\"line\">const z = y++ ;z为10;y为11</span><br></pre></td></tr></table></figure>\n<h4 id=\"数字的比较\"><a href=\"#数字的比较\" class=\"headerlink\" title=\"数字的比较\"></a>数字的比较</h4><p>例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let n = 0</span><br><span class=\"line\">while(true) &#123;</span><br><span class=\"line\">    n += 0.1</span><br><span class=\"line\">    if(n === 0.3) &#123;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(n)</span><br></pre></td></tr></table></figure></p>\n<p>这里跳过0.3，由于0.1不能精确代表一个双精度值。可使用Number.EPSILON,代表一个非常小的数字<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let n = 0</span><br><span class=\"line\">while (true) &#123;</span><br><span class=\"line\">    n += 0.1</span><br><span class=\"line\">    if (Math.abs(n - 0.3) &lt; Numbers.EPSILON) &#123;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"类判断运算符\"><a href=\"#类判断运算符\" class=\"headerlink\" title=\"类判断运算符\"></a>类判断运算符</h4><ul>\n<li>typeof(undefined): “undefined”</li>\n<li>typeof(null): “object” //没办法</li>\n<li>typeof({}): “object”</li>\n<li>typeof(true): “boolean”</li>\n<li>typeof(1): “number”</li>\n<li>typeof(“”): “string”</li>\n<li>typeof(Symbol()): “symbol”</li>\n<li>typeof(function(){}): “function”</li>\n</ul>\n<h4 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let v, v0;</span><br><span class=\"line\">v = v0 = 9.8 //链式赋值，先给v0赋值9.8，然后给v赋值9.8</span><br></pre></td></tr></table></figure>\n<h4 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h4><p>前文已写过</p>"},{"title":"mysql学习","date":"2018-12-20T13:18:40.000Z","_content":"\n## <center>mysql学习</center>\n\n### mysql安装\n\n1.首先是安装mysql，我自己数在ubuntu服务器下面。步骤如下：\n\n```\nsudo apt-get install mysql-server\nsudo apt-get install mysql-client\nsudo apt-get install libmysqlclient-dev\n```\n\n安装完毕后，一般情况下都是输入命令\n\n```\nmysql -v\n```\n显示出版本即代表安装成功.mysql端口占用的3306端口，查看方法如下。\n\n```\nsudo netstat -anpt | grep mysql\n```\n<!--more -->\n### mysql编辑配置文件\n\n2.编辑位于/etc/mysql/mysql.conf.d/mysqld.cnf\n\n```\nsudo vim /etc/mysql/mysql.conf.d/mysqld.cnf\n```\n\n注释掉bind-address=127.0.0.1。这样远程也可以访问了。退出。\n\n```\nsudo service mysql restart\n```\n### 进入mysql的命令行\n\n3.进入mysql服务\n\n```\nmysql -u root -p\n```\n\n会提示输入密码，输入即可。ok,但是我们最好还是新建一个用户,mysql不区分大小写，我一般用小写。\n\n```\ncereate user 'username'@'host' identified by 'password'\n```\n\n- username: 你创建的用户名\n- host: 指定你从那个主机可以登录，本地用户可以设为localhost，如果想让用户从任意远程主机登录，可以设为通配符%。\n- password: 该用户的登录密码\n\n```\ncreate user 'wind'@'%' identified by 'password'  #新建用户\ndrop user 'wind'@'%';  #删除用户\n```\n### 创建mysql新用户\n\n4.此时我们创建完新的用户了，我们可以看一下当前的数据库。\n\n```\nshow databases; #mysql语句均是以;作为结束\ncreate testdb;  #随便创建一个名为testdb的数据库\n```\n\n此时我们是没有任务数据库的。参照易佰教程，我们可以导入数据。\n加入我们sql数据文件存放于/home/guoxy/Desktop/mysql/yibai.sql\n\n```\nsource /home/guoxy/Desktop/mysql/yibai.sql\n```\n\n便会创建名为yibaidb的数据库。\n\n```\nshow databases;  #会显示我们的yibai.db\nuse yibaidb;  #会显示database change\n```\n\n我们想看看这个yibaidb的数据表是啥样的。\n```\n\nshow tables;  #会显示所有的数据表的名字\n\n```\n假如我们想修改某个表的字段名字。\n```\nalter table 表名 旧字段名 新字段名 新数据类型;\n```\n### 为新建用户分配数据库\n\n5.上述的操作均是在root用户下操作，为了安全我们应当为新建的wind用户分配一个数据库\n\n```\ngrant all on yibaidb.* to 'wind'@'%';  #给权限\nrevoke all on yibaidb.* to 'wind'@'%'; #撤销权限\n```\n\n这表明把yibaidb的所有的表的权限都赋给了wind用户。\n\n### 新建用户的登录\n\n6.此时我们可以退出root用户登录wind用户\n\n```\nmysql -u wind -p \n```\n\n输入密码进入，查看数据库及数据表\n\n```\nshow databases;\nuse yibaidb;\nshow tables;\n```\n\n如果想查看表的字段，在show tables;之后会看到表名，\n\n```\ndesc tablename;\n```\n\n便可以看到表的字段类型。    \n\n### 自己如何建立数据表\n\n7.自己新建table的方法:如新建person表和favourite_food表。\n\n```\nCREATE TABLE person\n(person_id SMALLINT UNSIGNED,\nfname VARCHAR(20),\nlname VARCHAR(20),\ngender ENUM('M','F'),\nbirth_data DATE,\nstreet VARCHAR(20),\ncity VARCHAR(20),\ncountry VARCHAR(20),\npostal_code VARCHAR(20),\nCONSTRAINT pk_person PRIMARY KEY (person_id)\n);\n\nCREATE TABLE favorite_food\n(person_id SMALLINT UNSIGNED,\nfood VARCHAR(20),\nCONSTRAINT pk_favorite_food PRIMARY KEY (person_id, food),\nCONSTRAINT fk_favorite_food_person_id FOREIGN KEY (person_id)\nREFERENCES person (person_id)\n);\n```\n### mysql的查询语句的使用\n\n8.mysql的查询，之前自己做过django的网站，用的是封装好sql的查询语言，不过sql的也不难理解，一般来说都是select 表的字段名 from 表 where 条件。便可以显示出来\n\n```\nselect * from preson where name='libai';\n```\n\n从person表找出所有名字为libai的人。\n两个表的查询,连接了employee表和department表，且employ表简写为e，department表简写为d\n\n```\nselect e.emp_id, e.fname, e.lname, d.name from employee as e inner join department as d\n on e.dept_id=d.dept_id\n```\n\n有时候我们想把一些表的字段名提取出来单独存下来，方便以后的查询。\n\n```\ncreate view employee_vm as select emp_id, fname, lname, year(start_date) as start_year from employee\n```\n\n这时，\n\n```\nshow tables;\n```\n\n会发现多了一个employee_vm的表，其中的数据便是我们选择的部分。    \n用in操作符来代表多个或的连接。\n\n```\nselect account_id, producr_cd, cust_id, acail_balance from accont where\nproduct_cd in ('CHK','SAV','CD','MM')\n```\n\n等同于\n\n```\nselect account_id, producr_cd, cust_id, acail_balance from accont where\nproduct_cd='CHK' or product_cd='SAV' or producr_cd='CD' or product_cd='MM'\n```\n\n可以看出方便了很多。    \nmysql也可以通过正则来查询，个人正则不是特别了解，只记住点简单的。此外mysql查询可以通过%和_来查询，前者代表通配符，即多个字符，而_只代表一个字符。例如\n\n```\nselect lname from employee where lname like '_a%e%';\n```\n\n表明查找lname第二字符为a并且后面至少存在一个e的名字。具体的查询方法也看了一些，就不一一详细叙述了，后面继续学习。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/mysql学习.md","raw":"---\ntitle: mysql学习\ndate: 2018-12-20 21:18:40\ntags: mysql\ncategories: mysql\n---\n\n## <center>mysql学习</center>\n\n### mysql安装\n\n1.首先是安装mysql，我自己数在ubuntu服务器下面。步骤如下：\n\n```\nsudo apt-get install mysql-server\nsudo apt-get install mysql-client\nsudo apt-get install libmysqlclient-dev\n```\n\n安装完毕后，一般情况下都是输入命令\n\n```\nmysql -v\n```\n显示出版本即代表安装成功.mysql端口占用的3306端口，查看方法如下。\n\n```\nsudo netstat -anpt | grep mysql\n```\n<!--more -->\n### mysql编辑配置文件\n\n2.编辑位于/etc/mysql/mysql.conf.d/mysqld.cnf\n\n```\nsudo vim /etc/mysql/mysql.conf.d/mysqld.cnf\n```\n\n注释掉bind-address=127.0.0.1。这样远程也可以访问了。退出。\n\n```\nsudo service mysql restart\n```\n### 进入mysql的命令行\n\n3.进入mysql服务\n\n```\nmysql -u root -p\n```\n\n会提示输入密码，输入即可。ok,但是我们最好还是新建一个用户,mysql不区分大小写，我一般用小写。\n\n```\ncereate user 'username'@'host' identified by 'password'\n```\n\n- username: 你创建的用户名\n- host: 指定你从那个主机可以登录，本地用户可以设为localhost，如果想让用户从任意远程主机登录，可以设为通配符%。\n- password: 该用户的登录密码\n\n```\ncreate user 'wind'@'%' identified by 'password'  #新建用户\ndrop user 'wind'@'%';  #删除用户\n```\n### 创建mysql新用户\n\n4.此时我们创建完新的用户了，我们可以看一下当前的数据库。\n\n```\nshow databases; #mysql语句均是以;作为结束\ncreate testdb;  #随便创建一个名为testdb的数据库\n```\n\n此时我们是没有任务数据库的。参照易佰教程，我们可以导入数据。\n加入我们sql数据文件存放于/home/guoxy/Desktop/mysql/yibai.sql\n\n```\nsource /home/guoxy/Desktop/mysql/yibai.sql\n```\n\n便会创建名为yibaidb的数据库。\n\n```\nshow databases;  #会显示我们的yibai.db\nuse yibaidb;  #会显示database change\n```\n\n我们想看看这个yibaidb的数据表是啥样的。\n```\n\nshow tables;  #会显示所有的数据表的名字\n\n```\n假如我们想修改某个表的字段名字。\n```\nalter table 表名 旧字段名 新字段名 新数据类型;\n```\n### 为新建用户分配数据库\n\n5.上述的操作均是在root用户下操作，为了安全我们应当为新建的wind用户分配一个数据库\n\n```\ngrant all on yibaidb.* to 'wind'@'%';  #给权限\nrevoke all on yibaidb.* to 'wind'@'%'; #撤销权限\n```\n\n这表明把yibaidb的所有的表的权限都赋给了wind用户。\n\n### 新建用户的登录\n\n6.此时我们可以退出root用户登录wind用户\n\n```\nmysql -u wind -p \n```\n\n输入密码进入，查看数据库及数据表\n\n```\nshow databases;\nuse yibaidb;\nshow tables;\n```\n\n如果想查看表的字段，在show tables;之后会看到表名，\n\n```\ndesc tablename;\n```\n\n便可以看到表的字段类型。    \n\n### 自己如何建立数据表\n\n7.自己新建table的方法:如新建person表和favourite_food表。\n\n```\nCREATE TABLE person\n(person_id SMALLINT UNSIGNED,\nfname VARCHAR(20),\nlname VARCHAR(20),\ngender ENUM('M','F'),\nbirth_data DATE,\nstreet VARCHAR(20),\ncity VARCHAR(20),\ncountry VARCHAR(20),\npostal_code VARCHAR(20),\nCONSTRAINT pk_person PRIMARY KEY (person_id)\n);\n\nCREATE TABLE favorite_food\n(person_id SMALLINT UNSIGNED,\nfood VARCHAR(20),\nCONSTRAINT pk_favorite_food PRIMARY KEY (person_id, food),\nCONSTRAINT fk_favorite_food_person_id FOREIGN KEY (person_id)\nREFERENCES person (person_id)\n);\n```\n### mysql的查询语句的使用\n\n8.mysql的查询，之前自己做过django的网站，用的是封装好sql的查询语言，不过sql的也不难理解，一般来说都是select 表的字段名 from 表 where 条件。便可以显示出来\n\n```\nselect * from preson where name='libai';\n```\n\n从person表找出所有名字为libai的人。\n两个表的查询,连接了employee表和department表，且employ表简写为e，department表简写为d\n\n```\nselect e.emp_id, e.fname, e.lname, d.name from employee as e inner join department as d\n on e.dept_id=d.dept_id\n```\n\n有时候我们想把一些表的字段名提取出来单独存下来，方便以后的查询。\n\n```\ncreate view employee_vm as select emp_id, fname, lname, year(start_date) as start_year from employee\n```\n\n这时，\n\n```\nshow tables;\n```\n\n会发现多了一个employee_vm的表，其中的数据便是我们选择的部分。    \n用in操作符来代表多个或的连接。\n\n```\nselect account_id, producr_cd, cust_id, acail_balance from accont where\nproduct_cd in ('CHK','SAV','CD','MM')\n```\n\n等同于\n\n```\nselect account_id, producr_cd, cust_id, acail_balance from accont where\nproduct_cd='CHK' or product_cd='SAV' or producr_cd='CD' or product_cd='MM'\n```\n\n可以看出方便了很多。    \nmysql也可以通过正则来查询，个人正则不是特别了解，只记住点简单的。此外mysql查询可以通过%和_来查询，前者代表通配符，即多个字符，而_只代表一个字符。例如\n\n```\nselect lname from employee where lname like '_a%e%';\n```\n\n表明查找lname第二字符为a并且后面至少存在一个e的名字。具体的查询方法也看了一些，就不一一详细叙述了，后面继续学习。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"mysql学习","published":1,"updated":"2022-05-20T02:24:20.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7i000plae1b3zpt3r2","content":"<h2 id=\"mysql学习\"><a href=\"#mysql学习\" class=\"headerlink\" title=\"mysql学习\"></a><center>mysql学习</center></h2><h3 id=\"mysql安装\"><a href=\"#mysql安装\" class=\"headerlink\" title=\"mysql安装\"></a>mysql安装</h3><p>1.首先是安装mysql，我自己数在ubuntu服务器下面。步骤如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install mysql-server</span><br><span class=\"line\">sudo apt-get install mysql-client</span><br><span class=\"line\">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>\n<p>安装完毕后，一般情况下都是输入命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -v</span><br></pre></td></tr></table></figure>\n<p>显示出版本即代表安装成功.mysql端口占用的3306端口，查看方法如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo netstat -anpt | grep mysql</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"mysql编辑配置文件\"><a href=\"#mysql编辑配置文件\" class=\"headerlink\" title=\"mysql编辑配置文件\"></a>mysql编辑配置文件</h3><p>2.编辑位于/etc/mysql/mysql.conf.d/mysqld.cnf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>\n<p>注释掉bind-address=127.0.0.1。这样远程也可以访问了。退出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service mysql restart</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入mysql的命令行\"><a href=\"#进入mysql的命令行\" class=\"headerlink\" title=\"进入mysql的命令行\"></a>进入mysql的命令行</h3><p>3.进入mysql服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br></pre></td></tr></table></figure>\n<p>会提示输入密码，输入即可。ok,但是我们最好还是新建一个用户,mysql不区分大小写，我一般用小写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cereate user &apos;username&apos;@&apos;host&apos; identified by &apos;password&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>username: 你创建的用户名</li>\n<li>host: 指定你从那个主机可以登录，本地用户可以设为localhost，如果想让用户从任意远程主机登录，可以设为通配符%。</li>\n<li>password: 该用户的登录密码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create user &apos;wind&apos;@&apos;%&apos; identified by &apos;password&apos;  #新建用户</span><br><span class=\"line\">drop user &apos;wind&apos;@&apos;%&apos;;  #删除用户</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建mysql新用户\"><a href=\"#创建mysql新用户\" class=\"headerlink\" title=\"创建mysql新用户\"></a>创建mysql新用户</h3><p>4.此时我们创建完新的用户了，我们可以看一下当前的数据库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show databases; #mysql语句均是以;作为结束</span><br><span class=\"line\">create testdb;  #随便创建一个名为testdb的数据库</span><br></pre></td></tr></table></figure>\n<p>此时我们是没有任务数据库的。参照易佰教程，我们可以导入数据。<br>加入我们sql数据文件存放于/home/guoxy/Desktop/mysql/yibai.sql</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source /home/guoxy/Desktop/mysql/yibai.sql</span><br></pre></td></tr></table></figure>\n<p>便会创建名为yibaidb的数据库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show databases;  #会显示我们的yibai.db</span><br><span class=\"line\">use yibaidb;  #会显示database change</span><br></pre></td></tr></table></figure>\n<p>我们想看看这个yibaidb的数据表是啥样的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">show tables;  #会显示所有的数据表的名字</span><br></pre></td></tr></table></figure></p>\n<p>假如我们想修改某个表的字段名字。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table 表名 旧字段名 新字段名 新数据类型;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"为新建用户分配数据库\"><a href=\"#为新建用户分配数据库\" class=\"headerlink\" title=\"为新建用户分配数据库\"></a>为新建用户分配数据库</h3><p>5.上述的操作均是在root用户下操作，为了安全我们应当为新建的wind用户分配一个数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grant all on yibaidb.* to &apos;wind&apos;@&apos;%&apos;;  #给权限</span><br><span class=\"line\">revoke all on yibaidb.* to &apos;wind&apos;@&apos;%&apos;; #撤销权限</span><br></pre></td></tr></table></figure>\n<p>这表明把yibaidb的所有的表的权限都赋给了wind用户。</p>\n<h3 id=\"新建用户的登录\"><a href=\"#新建用户的登录\" class=\"headerlink\" title=\"新建用户的登录\"></a>新建用户的登录</h3><p>6.此时我们可以退出root用户登录wind用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u wind -p</span><br></pre></td></tr></table></figure>\n<p>输入密码进入，查看数据库及数据表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show databases;</span><br><span class=\"line\">use yibaidb;</span><br><span class=\"line\">show tables;</span><br></pre></td></tr></table></figure>\n<p>如果想查看表的字段，在show tables;之后会看到表名，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">desc tablename;</span><br></pre></td></tr></table></figure>\n<p>便可以看到表的字段类型。    </p>\n<h3 id=\"自己如何建立数据表\"><a href=\"#自己如何建立数据表\" class=\"headerlink\" title=\"自己如何建立数据表\"></a>自己如何建立数据表</h3><p>7.自己新建table的方法:如新建person表和favourite_food表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE person</span><br><span class=\"line\">(person_id SMALLINT UNSIGNED,</span><br><span class=\"line\">fname VARCHAR(20),</span><br><span class=\"line\">lname VARCHAR(20),</span><br><span class=\"line\">gender ENUM(&apos;M&apos;,&apos;F&apos;),</span><br><span class=\"line\">birth_data DATE,</span><br><span class=\"line\">street VARCHAR(20),</span><br><span class=\"line\">city VARCHAR(20),</span><br><span class=\"line\">country VARCHAR(20),</span><br><span class=\"line\">postal_code VARCHAR(20),</span><br><span class=\"line\">CONSTRAINT pk_person PRIMARY KEY (person_id)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE favorite_food</span><br><span class=\"line\">(person_id SMALLINT UNSIGNED,</span><br><span class=\"line\">food VARCHAR(20),</span><br><span class=\"line\">CONSTRAINT pk_favorite_food PRIMARY KEY (person_id, food),</span><br><span class=\"line\">CONSTRAINT fk_favorite_food_person_id FOREIGN KEY (person_id)</span><br><span class=\"line\">REFERENCES person (person_id)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"mysql的查询语句的使用\"><a href=\"#mysql的查询语句的使用\" class=\"headerlink\" title=\"mysql的查询语句的使用\"></a>mysql的查询语句的使用</h3><p>8.mysql的查询，之前自己做过django的网站，用的是封装好sql的查询语言，不过sql的也不难理解，一般来说都是select 表的字段名 from 表 where 条件。便可以显示出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from preson where name=&apos;libai&apos;;</span><br></pre></td></tr></table></figure>\n<p>从person表找出所有名字为libai的人。<br>两个表的查询,连接了employee表和department表，且employ表简写为e，department表简写为d</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.emp_id, e.fname, e.lname, d.name from employee as e inner join department as d</span><br><span class=\"line\"> on e.dept_id=d.dept_id</span><br></pre></td></tr></table></figure>\n<p>有时候我们想把一些表的字段名提取出来单独存下来，方便以后的查询。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create view employee_vm as select emp_id, fname, lname, year(start_date) as start_year from employee</span><br></pre></td></tr></table></figure>\n<p>这时，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show tables;</span><br></pre></td></tr></table></figure>\n<p>会发现多了一个employee_vm的表，其中的数据便是我们选择的部分。<br>用in操作符来代表多个或的连接。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id, producr_cd, cust_id, acail_balance from accont where</span><br><span class=\"line\">product_cd in (&apos;CHK&apos;,&apos;SAV&apos;,&apos;CD&apos;,&apos;MM&apos;)</span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id, producr_cd, cust_id, acail_balance from accont where</span><br><span class=\"line\">product_cd=&apos;CHK&apos; or product_cd=&apos;SAV&apos; or producr_cd=&apos;CD&apos; or product_cd=&apos;MM&apos;</span><br></pre></td></tr></table></figure>\n<p>可以看出方便了很多。<br>mysql也可以通过正则来查询，个人正则不是特别了解，只记住点简单的。此外mysql查询可以通过%和<em>来查询，前者代表通配符，即多个字符，而</em>只代表一个字符。例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select lname from employee where lname like &apos;_a%e%&apos;;</span><br></pre></td></tr></table></figure>\n<p>表明查找lname第二字符为a并且后面至少存在一个e的名字。具体的查询方法也看了一些，就不一一详细叙述了，后面继续学习。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"mysql学习\"><a href=\"#mysql学习\" class=\"headerlink\" title=\"mysql学习\"></a><center>mysql学习</center></h2><h3 id=\"mysql安装\"><a href=\"#mysql安装\" class=\"headerlink\" title=\"mysql安装\"></a>mysql安装</h3><p>1.首先是安装mysql，我自己数在ubuntu服务器下面。步骤如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install mysql-server</span><br><span class=\"line\">sudo apt-get install mysql-client</span><br><span class=\"line\">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>\n<p>安装完毕后，一般情况下都是输入命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -v</span><br></pre></td></tr></table></figure>\n<p>显示出版本即代表安装成功.mysql端口占用的3306端口，查看方法如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo netstat -anpt | grep mysql</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"mysql编辑配置文件\"><a href=\"#mysql编辑配置文件\" class=\"headerlink\" title=\"mysql编辑配置文件\"></a>mysql编辑配置文件</h3><p>2.编辑位于/etc/mysql/mysql.conf.d/mysqld.cnf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>\n<p>注释掉bind-address=127.0.0.1。这样远程也可以访问了。退出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service mysql restart</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入mysql的命令行\"><a href=\"#进入mysql的命令行\" class=\"headerlink\" title=\"进入mysql的命令行\"></a>进入mysql的命令行</h3><p>3.进入mysql服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br></pre></td></tr></table></figure>\n<p>会提示输入密码，输入即可。ok,但是我们最好还是新建一个用户,mysql不区分大小写，我一般用小写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cereate user &apos;username&apos;@&apos;host&apos; identified by &apos;password&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>username: 你创建的用户名</li>\n<li>host: 指定你从那个主机可以登录，本地用户可以设为localhost，如果想让用户从任意远程主机登录，可以设为通配符%。</li>\n<li>password: 该用户的登录密码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create user &apos;wind&apos;@&apos;%&apos; identified by &apos;password&apos;  #新建用户</span><br><span class=\"line\">drop user &apos;wind&apos;@&apos;%&apos;;  #删除用户</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建mysql新用户\"><a href=\"#创建mysql新用户\" class=\"headerlink\" title=\"创建mysql新用户\"></a>创建mysql新用户</h3><p>4.此时我们创建完新的用户了，我们可以看一下当前的数据库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show databases; #mysql语句均是以;作为结束</span><br><span class=\"line\">create testdb;  #随便创建一个名为testdb的数据库</span><br></pre></td></tr></table></figure>\n<p>此时我们是没有任务数据库的。参照易佰教程，我们可以导入数据。<br>加入我们sql数据文件存放于/home/guoxy/Desktop/mysql/yibai.sql</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source /home/guoxy/Desktop/mysql/yibai.sql</span><br></pre></td></tr></table></figure>\n<p>便会创建名为yibaidb的数据库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show databases;  #会显示我们的yibai.db</span><br><span class=\"line\">use yibaidb;  #会显示database change</span><br></pre></td></tr></table></figure>\n<p>我们想看看这个yibaidb的数据表是啥样的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">show tables;  #会显示所有的数据表的名字</span><br></pre></td></tr></table></figure></p>\n<p>假如我们想修改某个表的字段名字。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table 表名 旧字段名 新字段名 新数据类型;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"为新建用户分配数据库\"><a href=\"#为新建用户分配数据库\" class=\"headerlink\" title=\"为新建用户分配数据库\"></a>为新建用户分配数据库</h3><p>5.上述的操作均是在root用户下操作，为了安全我们应当为新建的wind用户分配一个数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grant all on yibaidb.* to &apos;wind&apos;@&apos;%&apos;;  #给权限</span><br><span class=\"line\">revoke all on yibaidb.* to &apos;wind&apos;@&apos;%&apos;; #撤销权限</span><br></pre></td></tr></table></figure>\n<p>这表明把yibaidb的所有的表的权限都赋给了wind用户。</p>\n<h3 id=\"新建用户的登录\"><a href=\"#新建用户的登录\" class=\"headerlink\" title=\"新建用户的登录\"></a>新建用户的登录</h3><p>6.此时我们可以退出root用户登录wind用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u wind -p</span><br></pre></td></tr></table></figure>\n<p>输入密码进入，查看数据库及数据表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show databases;</span><br><span class=\"line\">use yibaidb;</span><br><span class=\"line\">show tables;</span><br></pre></td></tr></table></figure>\n<p>如果想查看表的字段，在show tables;之后会看到表名，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">desc tablename;</span><br></pre></td></tr></table></figure>\n<p>便可以看到表的字段类型。    </p>\n<h3 id=\"自己如何建立数据表\"><a href=\"#自己如何建立数据表\" class=\"headerlink\" title=\"自己如何建立数据表\"></a>自己如何建立数据表</h3><p>7.自己新建table的方法:如新建person表和favourite_food表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE person</span><br><span class=\"line\">(person_id SMALLINT UNSIGNED,</span><br><span class=\"line\">fname VARCHAR(20),</span><br><span class=\"line\">lname VARCHAR(20),</span><br><span class=\"line\">gender ENUM(&apos;M&apos;,&apos;F&apos;),</span><br><span class=\"line\">birth_data DATE,</span><br><span class=\"line\">street VARCHAR(20),</span><br><span class=\"line\">city VARCHAR(20),</span><br><span class=\"line\">country VARCHAR(20),</span><br><span class=\"line\">postal_code VARCHAR(20),</span><br><span class=\"line\">CONSTRAINT pk_person PRIMARY KEY (person_id)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE favorite_food</span><br><span class=\"line\">(person_id SMALLINT UNSIGNED,</span><br><span class=\"line\">food VARCHAR(20),</span><br><span class=\"line\">CONSTRAINT pk_favorite_food PRIMARY KEY (person_id, food),</span><br><span class=\"line\">CONSTRAINT fk_favorite_food_person_id FOREIGN KEY (person_id)</span><br><span class=\"line\">REFERENCES person (person_id)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"mysql的查询语句的使用\"><a href=\"#mysql的查询语句的使用\" class=\"headerlink\" title=\"mysql的查询语句的使用\"></a>mysql的查询语句的使用</h3><p>8.mysql的查询，之前自己做过django的网站，用的是封装好sql的查询语言，不过sql的也不难理解，一般来说都是select 表的字段名 from 表 where 条件。便可以显示出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from preson where name=&apos;libai&apos;;</span><br></pre></td></tr></table></figure>\n<p>从person表找出所有名字为libai的人。<br>两个表的查询,连接了employee表和department表，且employ表简写为e，department表简写为d</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.emp_id, e.fname, e.lname, d.name from employee as e inner join department as d</span><br><span class=\"line\"> on e.dept_id=d.dept_id</span><br></pre></td></tr></table></figure>\n<p>有时候我们想把一些表的字段名提取出来单独存下来，方便以后的查询。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create view employee_vm as select emp_id, fname, lname, year(start_date) as start_year from employee</span><br></pre></td></tr></table></figure>\n<p>这时，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show tables;</span><br></pre></td></tr></table></figure>\n<p>会发现多了一个employee_vm的表，其中的数据便是我们选择的部分。<br>用in操作符来代表多个或的连接。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id, producr_cd, cust_id, acail_balance from accont where</span><br><span class=\"line\">product_cd in (&apos;CHK&apos;,&apos;SAV&apos;,&apos;CD&apos;,&apos;MM&apos;)</span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id, producr_cd, cust_id, acail_balance from accont where</span><br><span class=\"line\">product_cd=&apos;CHK&apos; or product_cd=&apos;SAV&apos; or producr_cd=&apos;CD&apos; or product_cd=&apos;MM&apos;</span><br></pre></td></tr></table></figure>\n<p>可以看出方便了很多。<br>mysql也可以通过正则来查询，个人正则不是特别了解，只记住点简单的。此外mysql查询可以通过%和<em>来查询，前者代表通配符，即多个字符，而</em>只代表一个字符。例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select lname from employee where lname like &apos;_a%e%&apos;;</span><br></pre></td></tr></table></figure>\n<p>表明查找lname第二字符为a并且后面至少存在一个e的名字。具体的查询方法也看了一些，就不一一详细叙述了，后面继续学习。</p>"},{"title":"hexo部署到服务器","date":"2022-05-20T05:38:05.000Z","_content":"\n### hexo部署到服务器的过程记录\n\n  重启了很久之前用的博客，并将其部署到自己的腾讯云服务器上。\n1. 由于我们使用git部署，需要在服务器上将本地电脑下的`~/./ssh/id_ras.pub`复制到服务器上的`./ssh/authorized_keys`文件下。这样可以进行免密登录。\n2. 服务器上在家目录`~/project`下新建俩文件夹`hexo`和`repo`，其中`repo`是git自动deploy的关键。\n   1. 在`repo`下输入命令`git init --bare hexo.git`。\n   2. 在`hexo.git/hooks`新建`post-update`，并输入以下。\n   ```\n   #!/bin/bash\n   git --work-tree=/home/xyguo/project/hexo --git-dir=/home/xyguo/project/repo/hexo.git checkout -f    \n   ```\n3. nginx配置相应的文件。其中配置https文件放到了`/var/ssl/blog`目录下。\n4. `service nginx restart`重启nginx。\n   \n#### 问题记录\n  本地`hexo g -d`时候，记得使用`node12`14会报错，查了一下是hexo和node@14不兼容。\n  参考地址：[将hexo部署到服务器](https://hjxlog.com/posts/20191130a1.html)\n","source":"_posts/hexo部署.md","raw":"---\ntitle: hexo部署到服务器\ndate: 2022-05-20 13:38:05\ntags: 服务器部署 hexo \n---\n\n### hexo部署到服务器的过程记录\n\n  重启了很久之前用的博客，并将其部署到自己的腾讯云服务器上。\n1. 由于我们使用git部署，需要在服务器上将本地电脑下的`~/./ssh/id_ras.pub`复制到服务器上的`./ssh/authorized_keys`文件下。这样可以进行免密登录。\n2. 服务器上在家目录`~/project`下新建俩文件夹`hexo`和`repo`，其中`repo`是git自动deploy的关键。\n   1. 在`repo`下输入命令`git init --bare hexo.git`。\n   2. 在`hexo.git/hooks`新建`post-update`，并输入以下。\n   ```\n   #!/bin/bash\n   git --work-tree=/home/xyguo/project/hexo --git-dir=/home/xyguo/project/repo/hexo.git checkout -f    \n   ```\n3. nginx配置相应的文件。其中配置https文件放到了`/var/ssl/blog`目录下。\n4. `service nginx restart`重启nginx。\n   \n#### 问题记录\n  本地`hexo g -d`时候，记得使用`node12`14会报错，查了一下是hexo和node@14不兼容。\n  参考地址：[将hexo部署到服务器](https://hjxlog.com/posts/20191130a1.html)\n","slug":"hexo部署","published":1,"updated":"2022-05-20T06:01:53.695Z","_id":"cl3e0vh7j000slae1sc7mo7lg","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"hexo部署到服务器的过程记录\"><a href=\"#hexo部署到服务器的过程记录\" class=\"headerlink\" title=\"hexo部署到服务器的过程记录\"></a>hexo部署到服务器的过程记录</h3><p>  重启了很久之前用的博客，并将其部署到自己的腾讯云服务器上。</p>\n<ol>\n<li>由于我们使用git部署，需要在服务器上将本地电脑下的<code>~/./ssh/id_ras.pub</code>复制到服务器上的<code>./ssh/authorized_keys</code>文件下。这样可以进行免密登录。</li>\n<li><p>服务器上在家目录<code>~/project</code>下新建俩文件夹<code>hexo</code>和<code>repo</code>，其中<code>repo</code>是git自动deploy的关键。</p>\n<ol>\n<li>在<code>repo</code>下输入命令<code>git init --bare hexo.git</code>。</li>\n<li>在<code>hexo.git/hooks</code>新建<code>post-update</code>，并输入以下。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">git --work-tree=/home/xyguo/project/hexo --git-dir=/home/xyguo/project/repo/hexo.git checkout -f</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>nginx配置相应的文件。其中配置https文件放到了<code>/var/ssl/blog</code>目录下。</p>\n</li>\n<li><code>service nginx restart</code>重启nginx。</li>\n</ol>\n<h4 id=\"问题记录\"><a href=\"#问题记录\" class=\"headerlink\" title=\"问题记录\"></a>问题记录</h4><p>  本地<code>hexo g -d</code>时候，记得使用<code>node12</code>14会报错，查了一下是hexo和node@14不兼容。<br>  参考地址：<a href=\"https://hjxlog.com/posts/20191130a1.html\" target=\"_blank\" rel=\"noopener\">将hexo部署到服务器</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"hexo部署到服务器的过程记录\"><a href=\"#hexo部署到服务器的过程记录\" class=\"headerlink\" title=\"hexo部署到服务器的过程记录\"></a>hexo部署到服务器的过程记录</h3><p>  重启了很久之前用的博客，并将其部署到自己的腾讯云服务器上。</p>\n<ol>\n<li>由于我们使用git部署，需要在服务器上将本地电脑下的<code>~/./ssh/id_ras.pub</code>复制到服务器上的<code>./ssh/authorized_keys</code>文件下。这样可以进行免密登录。</li>\n<li><p>服务器上在家目录<code>~/project</code>下新建俩文件夹<code>hexo</code>和<code>repo</code>，其中<code>repo</code>是git自动deploy的关键。</p>\n<ol>\n<li>在<code>repo</code>下输入命令<code>git init --bare hexo.git</code>。</li>\n<li>在<code>hexo.git/hooks</code>新建<code>post-update</code>，并输入以下。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">git --work-tree=/home/xyguo/project/hexo --git-dir=/home/xyguo/project/repo/hexo.git checkout -f</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>nginx配置相应的文件。其中配置https文件放到了<code>/var/ssl/blog</code>目录下。</p>\n</li>\n<li><code>service nginx restart</code>重启nginx。</li>\n</ol>\n<h4 id=\"问题记录\"><a href=\"#问题记录\" class=\"headerlink\" title=\"问题记录\"></a>问题记录</h4><p>  本地<code>hexo g -d</code>时候，记得使用<code>node12</code>14会报错，查了一下是hexo和node@14不兼容。<br>  参考地址：<a href=\"https://hjxlog.com/posts/20191130a1.html\" target=\"_blank\" rel=\"noopener\">将hexo部署到服务器</a></p>\n"},{"title":"es6的函数","date":"2018-12-12T02:33:09.000Z","_content":"## <center>es6函数</center>\n### 1.函数的默认值\n```\nfunction log(x, y) {\n    y = y ||　'world';\n    console.log(x, y)\n}\nlog('Hello');   //Hello world\nlog('Hello', 'world');      //Hello World\nlog('hello','') //Hello world\n```\n上述缺点，在检查函数`log`的参数ｙ没有赋值，没有的话指定为world，缺点是y赋值false,就会像最后一个即使赋值为空，那么也会显示world．\n\nes6可以为参数设置默认值:\n```\nfunction log(x, y='world') {\n    this.x = x;\n    this.y = y;\n}\nlog('Hello');   //Hello world\nlog('Hello', 'world');      //Hello World\nlog('hello','') //Hello world\n```\n此外，参数变量是默认声明的，函数体内无法用let或const再次声明，否则报错.    \n<!--more -->\n### 2.与结构赋值相结合    \n```\nfunction foo({x ,y = 5}) {\n    console.log(x,y)\n}\nfoo({});    //undefined 5\nfoo({x: 1});    //1 5\nfoo({x: 1 ,y: 2});  1 2\nfoo()；  // x of undefined\n```\n最后一个没有为foo提供参数,所以为undefined.\n另一个例子:\n```\nfunction fetch(url, {body='', method='GET', header= {} }){\n    console.log(method);\n}\nfetch ('http://example.com', {}); //\"GET\"\nfetch ('http://example.com'); //报错\n\nfunction fetch(url, {body='', method='GET', header= {}= {} }){\n    console.log(method);\n}\n//没有第二个参数,默认值会生效\nfetch ('http://example.com'); //\"GET\"\n```\n\n\n","source":"_posts/es6函数.mkd","raw":"---\ntitle: es6的函数\ndate: 2018-12-12 10:33:09\ntags: javascript\ncategories: javascript\n---\n## <center>es6函数</center>\n### 1.函数的默认值\n```\nfunction log(x, y) {\n    y = y ||　'world';\n    console.log(x, y)\n}\nlog('Hello');   //Hello world\nlog('Hello', 'world');      //Hello World\nlog('hello','') //Hello world\n```\n上述缺点，在检查函数`log`的参数ｙ没有赋值，没有的话指定为world，缺点是y赋值false,就会像最后一个即使赋值为空，那么也会显示world．\n\nes6可以为参数设置默认值:\n```\nfunction log(x, y='world') {\n    this.x = x;\n    this.y = y;\n}\nlog('Hello');   //Hello world\nlog('Hello', 'world');      //Hello World\nlog('hello','') //Hello world\n```\n此外，参数变量是默认声明的，函数体内无法用let或const再次声明，否则报错.    \n<!--more -->\n### 2.与结构赋值相结合    \n```\nfunction foo({x ,y = 5}) {\n    console.log(x,y)\n}\nfoo({});    //undefined 5\nfoo({x: 1});    //1 5\nfoo({x: 1 ,y: 2});  1 2\nfoo()；  // x of undefined\n```\n最后一个没有为foo提供参数,所以为undefined.\n另一个例子:\n```\nfunction fetch(url, {body='', method='GET', header= {} }){\n    console.log(method);\n}\nfetch ('http://example.com', {}); //\"GET\"\nfetch ('http://example.com'); //报错\n\nfunction fetch(url, {body='', method='GET', header= {}= {} }){\n    console.log(method);\n}\n//没有第二个参数,默认值会生效\nfetch ('http://example.com'); //\"GET\"\n```\n\n\n","slug":"es6函数","published":1,"updated":"2022-05-20T02:24:20.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7k000wlae1903ajx5j","content":"<h2 id=\"es6函数\"><a href=\"#es6函数\" class=\"headerlink\" title=\"es6函数\"></a><center>es6函数</center></h2><h3 id=\"1-函数的默认值\"><a href=\"#1-函数的默认值\" class=\"headerlink\" title=\"1.函数的默认值\"></a>1.函数的默认值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log(x, y) &#123;</span><br><span class=\"line\">    y = y ||　&apos;world&apos;;</span><br><span class=\"line\">    console.log(x, y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(&apos;Hello&apos;);   //Hello world</span><br><span class=\"line\">log(&apos;Hello&apos;, &apos;world&apos;);      //Hello World</span><br><span class=\"line\">log(&apos;hello&apos;,&apos;&apos;) //Hello world</span><br></pre></td></tr></table></figure>\n<p>上述缺点，在检查函数<code>log</code>的参数ｙ没有赋值，没有的话指定为world，缺点是y赋值false,就会像最后一个即使赋值为空，那么也会显示world．</p>\n<p>es6可以为参数设置默认值:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log(x, y=&apos;world&apos;) &#123;</span><br><span class=\"line\">    this.x = x;</span><br><span class=\"line\">    this.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(&apos;Hello&apos;);   //Hello world</span><br><span class=\"line\">log(&apos;Hello&apos;, &apos;world&apos;);      //Hello World</span><br><span class=\"line\">log(&apos;hello&apos;,&apos;&apos;) //Hello world</span><br></pre></td></tr></table></figure></p>\n<p>此外，参数变量是默认声明的，函数体内无法用let或const再次声明，否则报错.<br><a id=\"more\"></a></p>\n<h3 id=\"2-与结构赋值相结合\"><a href=\"#2-与结构赋值相结合\" class=\"headerlink\" title=\"2.与结构赋值相结合\"></a>2.与结构赋值相结合</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(&#123;x ,y = 5&#125;) &#123;</span><br><span class=\"line\">    console.log(x,y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(&#123;&#125;);    //undefined 5</span><br><span class=\"line\">foo(&#123;x: 1&#125;);    //1 5</span><br><span class=\"line\">foo(&#123;x: 1 ,y: 2&#125;);  1 2</span><br><span class=\"line\">foo()；  // x of undefined</span><br></pre></td></tr></table></figure>\n<p>最后一个没有为foo提供参数,所以为undefined.<br>另一个例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fetch(url, &#123;body=&apos;&apos;, method=&apos;GET&apos;, header= &#123;&#125; &#125;)&#123;</span><br><span class=\"line\">    console.log(method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fetch (&apos;http://example.com&apos;, &#123;&#125;); //&quot;GET&quot;</span><br><span class=\"line\">fetch (&apos;http://example.com&apos;); //报错</span><br><span class=\"line\"></span><br><span class=\"line\">function fetch(url, &#123;body=&apos;&apos;, method=&apos;GET&apos;, header= &#123;&#125;= &#123;&#125; &#125;)&#123;</span><br><span class=\"line\">    console.log(method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//没有第二个参数,默认值会生效</span><br><span class=\"line\">fetch (&apos;http://example.com&apos;); //&quot;GET&quot;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"es6函数\"><a href=\"#es6函数\" class=\"headerlink\" title=\"es6函数\"></a><center>es6函数</center></h2><h3 id=\"1-函数的默认值\"><a href=\"#1-函数的默认值\" class=\"headerlink\" title=\"1.函数的默认值\"></a>1.函数的默认值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log(x, y) &#123;</span><br><span class=\"line\">    y = y ||　&apos;world&apos;;</span><br><span class=\"line\">    console.log(x, y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(&apos;Hello&apos;);   //Hello world</span><br><span class=\"line\">log(&apos;Hello&apos;, &apos;world&apos;);      //Hello World</span><br><span class=\"line\">log(&apos;hello&apos;,&apos;&apos;) //Hello world</span><br></pre></td></tr></table></figure>\n<p>上述缺点，在检查函数<code>log</code>的参数ｙ没有赋值，没有的话指定为world，缺点是y赋值false,就会像最后一个即使赋值为空，那么也会显示world．</p>\n<p>es6可以为参数设置默认值:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log(x, y=&apos;world&apos;) &#123;</span><br><span class=\"line\">    this.x = x;</span><br><span class=\"line\">    this.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">log(&apos;Hello&apos;);   //Hello world</span><br><span class=\"line\">log(&apos;Hello&apos;, &apos;world&apos;);      //Hello World</span><br><span class=\"line\">log(&apos;hello&apos;,&apos;&apos;) //Hello world</span><br></pre></td></tr></table></figure></p>\n<p>此外，参数变量是默认声明的，函数体内无法用let或const再次声明，否则报错.<br>","more":"</p>\n<h3 id=\"2-与结构赋值相结合\"><a href=\"#2-与结构赋值相结合\" class=\"headerlink\" title=\"2.与结构赋值相结合\"></a>2.与结构赋值相结合</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(&#123;x ,y = 5&#125;) &#123;</span><br><span class=\"line\">    console.log(x,y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(&#123;&#125;);    //undefined 5</span><br><span class=\"line\">foo(&#123;x: 1&#125;);    //1 5</span><br><span class=\"line\">foo(&#123;x: 1 ,y: 2&#125;);  1 2</span><br><span class=\"line\">foo()；  // x of undefined</span><br></pre></td></tr></table></figure>\n<p>最后一个没有为foo提供参数,所以为undefined.<br>另一个例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fetch(url, &#123;body=&apos;&apos;, method=&apos;GET&apos;, header= &#123;&#125; &#125;)&#123;</span><br><span class=\"line\">    console.log(method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fetch (&apos;http://example.com&apos;, &#123;&#125;); //&quot;GET&quot;</span><br><span class=\"line\">fetch (&apos;http://example.com&apos;); //报错</span><br><span class=\"line\"></span><br><span class=\"line\">function fetch(url, &#123;body=&apos;&apos;, method=&apos;GET&apos;, header= &#123;&#125;= &#123;&#125; &#125;)&#123;</span><br><span class=\"line\">    console.log(method);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//没有第二个参数,默认值会生效</span><br><span class=\"line\">fetch (&apos;http://example.com&apos;); //&quot;GET&quot;</span><br></pre></td></tr></table></figure></p>"},{"title":"es6的promise函数","date":"2018-12-18T02:33:09.000Z","_content":"\n## <center>promise</center>\npromise是异步编程的一种解决方案，比起传统的解决方案--回调函数和事件更合理和强大。    \n所谓promise，简单的说是一个容器，里面保存着未来才会结束的事件(通常是一个异步操作)    \npromise的特点:\n- 对象的状态不受外界影响，promise对象代表一个异步操作，有三种状态:pending(进行中),fulfilled(已成功),rejected(已失效)。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作无法改变这个状态。这也是promise的由来。\n- 一旦状态改变，就不会再变，任何时候都可以得到这个结果，promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变成rejected。只要这两种状态发生，状态就凝固了，不会再变了，会一直保持这个结果，这个结果就成为resolved(已定型)。如果改变已经发生了，你在对promise添加回调函数，也会立即得到这个结果。这与事件Event不同，事件的特点是如果你错过了它，再去监听，是得不到结果的。\n- promise也有一些缺点，首先取消promise，一旦建立就会立即执行，无法中途取消，其次如果不设置回调函数，promise内部抛出的错误不会反映到外部，第三，当初与oending状态，无法得知目前处于哪一个阶段(刚刚开始还是即将完成)\n<!--more -->\n### 基本用法\n```\nconst promise = new Promise(function(resolve, reject){\n    //...some code\n    if(/* 异步操作成功 */){\n        resolve(value)\n    } else {\n        reject(error)\n    }\n})\n```\nresolve的作用是，将promise的对象从状态pending变为resolved，在异步操作成功时候调用，并将异步操作的结果作为参数传递出去；reject的作用是，再promise的状态由pending变为rejectd，在异步操作失败时候调用，并将异步操作的报出的错误，作为参数传递出去。   \npromise实例生成以后，可以用then方法分别指定resolved和rejected状态的回调函数。    \n```\npromise.then(function(value){\n    //success\n    },function(error){\n    //failure\n    })\n```\npromise实例生成以后，可以接受两个回调函数作为参数，第一个回调函数是promise对象变为resolved时候调用，第二个是回调函数是promise变为reject时调用，第二个函数是可选的的，二者均接受promise对象传出的值作为参数。    \n例子：\n```\nfunction timeout(ms){\n    return new Promise((resolve, reject) => {\n        setTimeout(resolve, ms, 'done')\n    });\n}\ntimeout(100).then((value) => {\n    console.log(value)\n})\n```\n上述代码中timeout方法返回了一个promise实例，表示一段时间才会发生的结果，过了指定的时间，promise的实例状态变为resolved，就会触发then方法绑定的回调函数。\n继续举例\n```\nlet promise = new Promise((resolve, reject) => {\n    console.log('promise');\n    resolve();\n})\npromise.then(function() {\n    console.log('resolved')\n})\nconsole.log('xxxx')\n输出结果:\n// promise\n// xxxx\n// resolved\n```\n上述代码中，promise建立后立即执行，首先输出promise，然后，.then方法指定的回调函数，将在当前脚本所有的同步任务执行完才会执行，所以resolved最后输出。\n继续举例：\n```\nfunction loadImage(url){\n    retutn new Promise(function(resolve, reject) {\n        const image = new Image();\n        image.onload = function() {\n            resolve(image)\n        }\n        image.onerror = function() {\n            reject(new Error('could not load image at' + url))\n        }\n        image.src = url\n    })\n}\n```\n异步加载图片，如果加载成功，则调用resolve方法，否则调用reject方法\n\n多个promise的实例：\n```\nconst p1 = new Promise(function(resolve, reject) {\n    setTimeout(()=>{\n        reject(new Error('fail'), 3000)\n    })\n})\nconst p2 = new Promise(function(resolve, reject) {\n    setTimeout(() => {\n        resolve(p1), 1000\n    })\n})\np2.then(result => console.log(result))\n    .catch(error => console.log(error))\n//Error: fail\n```\n### .then方法，链式调用\n```\ngetJson(\"/posts.json\").then(\n    post => getJson(post.commentURL)\n).then(\n    comments => console.log('resolved:',comments)\n    err => console.log('reject:',err)\n)\n```\n上面是链式调用，从/post.json获取数据，成功后再用getJosn函数获取comment的url传入第二个.then作为参数，成功则打印评论，失误则打印错误。一般来说用catch方法捕获错误。\n```\nconst promise = new Promise(function(resolve, reject) {\n    throw new Error('test')\n})\npromise.catch((error) => {\n    console.log(error)\n})\n```\npromise会吃掉内部的错误，例子如下：\n```\nconst someAsyncThing = function() {\n    return new Promise((resolve, reject) => {\n        //这里x并没有定义\n        resolve (x+2)\n    })\n}\nsomeAsyncThing()\n.catch( (error) => {\n    console.log(error)\n})\n.then(() => {\n    console.log('carry on')\n})\n//ReferenceError: x is not defined\n    at Promise (<anonymous>:4:18)\n    at new Promise (<anonymous>)\n    at someAsyncThing (<anonymous>:2:12)\n    at <anonymous>:7:1\nVM193:12 carry on\n```\n这里在X没有定义的情况下，首先捕捉了错误，即使x未定义仍然运行.then函数输出了carry on \n\n\n### Promise.finally\nfinally 指定不敢Pormise的对象最后的结果如何，都会执行的操作\n```\npromise\n.then(result => {..})\n.catch(result => {...})\n.finally(result => {...})\n```\n\n### Promise.all\npromise.all方法讲对个promise实例，包装成一个promise实例。\n```\nconst p = Promise.all([p1, p2, p3])\n```\n上面代码中，promise会接受一个数组作为参数，p1, p2, p3都是Promise的实例，promise.all的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise的实例。\np的状态有p1,p2,p3确定：    \n- 只有p1, p2, p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1, p2, p3的返回值组成一个数组，作为参数传递给p的回调函数。\n- 只要p1, p2, p3有一个被reject，p的状态则变为reject，此时第一个被reject的返回值会作为参数，传递给p的回调函数。\n具体例子如下：\n```\n//这里并不觉得是6个promise的实例\nconst promises = [2,3,5,6,11,13].map(function(id) {\n    return getJson('/post/' + id + '.json')\n})\nPromise.all(promises).then( (posts) => {\n    .....\n}).catch((error) => {\n    .....\n})\n\n```\n再举个栗子更好理解的:\n```\nconst databasePromise = connectDatabase();\nconst booksPromise = databasePromise\n    ,then(findAllBook)\nconst userPromise = databasePromise\n    .then(getCurrentUser)\nPromise.all([bookPromise, userPromise])\n    .then(([book, user]) => {\n        pickTopRecommentaction(book, user)\n    })\n```\n这里，bookPromise和userPromise是两个异步操作，只有等到他们的结果都返回了，才会去执行pickTopRecommentaction这个回调函数。需要注意的如果作为参数的promise的实例被reject了，那么不会触发Promise.all的catch方法。\n例子：\n```\nconst p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result)\n.catch(e => e);\n\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('报错了');\n})\n.then(result => result)\n.catch(e => e);\n\nPromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// [\"hello\", Error: 报错了]\n```\n上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。    \n若p2未定义catch方法：\n```\nconst p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result);\n\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('报错了');\n})\n.then(result => result);\n\nPromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// Error: 报错了\n```\n首先，p2会reject，所以reject的返回值会作为参数给Promise.all，同事调用Promise.all的catch方法。\n\n### Promise.race\nconst p = Promise.race([p1, p2, p3])\n上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。\n\nPromise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。\n\n下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。\n```\nconst p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n]);\n\np\n.then(console.log)\n.catch(console.error);\n```\n","source":"_posts/promise.mkd","raw":"---\ntitle: es6的promise函数\ndate: 2018-12-18 10:33:09\ntags: javascript\ncategories: javascript\n---\n\n## <center>promise</center>\npromise是异步编程的一种解决方案，比起传统的解决方案--回调函数和事件更合理和强大。    \n所谓promise，简单的说是一个容器，里面保存着未来才会结束的事件(通常是一个异步操作)    \npromise的特点:\n- 对象的状态不受外界影响，promise对象代表一个异步操作，有三种状态:pending(进行中),fulfilled(已成功),rejected(已失效)。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作无法改变这个状态。这也是promise的由来。\n- 一旦状态改变，就不会再变，任何时候都可以得到这个结果，promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变成rejected。只要这两种状态发生，状态就凝固了，不会再变了，会一直保持这个结果，这个结果就成为resolved(已定型)。如果改变已经发生了，你在对promise添加回调函数，也会立即得到这个结果。这与事件Event不同，事件的特点是如果你错过了它，再去监听，是得不到结果的。\n- promise也有一些缺点，首先取消promise，一旦建立就会立即执行，无法中途取消，其次如果不设置回调函数，promise内部抛出的错误不会反映到外部，第三，当初与oending状态，无法得知目前处于哪一个阶段(刚刚开始还是即将完成)\n<!--more -->\n### 基本用法\n```\nconst promise = new Promise(function(resolve, reject){\n    //...some code\n    if(/* 异步操作成功 */){\n        resolve(value)\n    } else {\n        reject(error)\n    }\n})\n```\nresolve的作用是，将promise的对象从状态pending变为resolved，在异步操作成功时候调用，并将异步操作的结果作为参数传递出去；reject的作用是，再promise的状态由pending变为rejectd，在异步操作失败时候调用，并将异步操作的报出的错误，作为参数传递出去。   \npromise实例生成以后，可以用then方法分别指定resolved和rejected状态的回调函数。    \n```\npromise.then(function(value){\n    //success\n    },function(error){\n    //failure\n    })\n```\npromise实例生成以后，可以接受两个回调函数作为参数，第一个回调函数是promise对象变为resolved时候调用，第二个是回调函数是promise变为reject时调用，第二个函数是可选的的，二者均接受promise对象传出的值作为参数。    \n例子：\n```\nfunction timeout(ms){\n    return new Promise((resolve, reject) => {\n        setTimeout(resolve, ms, 'done')\n    });\n}\ntimeout(100).then((value) => {\n    console.log(value)\n})\n```\n上述代码中timeout方法返回了一个promise实例，表示一段时间才会发生的结果，过了指定的时间，promise的实例状态变为resolved，就会触发then方法绑定的回调函数。\n继续举例\n```\nlet promise = new Promise((resolve, reject) => {\n    console.log('promise');\n    resolve();\n})\npromise.then(function() {\n    console.log('resolved')\n})\nconsole.log('xxxx')\n输出结果:\n// promise\n// xxxx\n// resolved\n```\n上述代码中，promise建立后立即执行，首先输出promise，然后，.then方法指定的回调函数，将在当前脚本所有的同步任务执行完才会执行，所以resolved最后输出。\n继续举例：\n```\nfunction loadImage(url){\n    retutn new Promise(function(resolve, reject) {\n        const image = new Image();\n        image.onload = function() {\n            resolve(image)\n        }\n        image.onerror = function() {\n            reject(new Error('could not load image at' + url))\n        }\n        image.src = url\n    })\n}\n```\n异步加载图片，如果加载成功，则调用resolve方法，否则调用reject方法\n\n多个promise的实例：\n```\nconst p1 = new Promise(function(resolve, reject) {\n    setTimeout(()=>{\n        reject(new Error('fail'), 3000)\n    })\n})\nconst p2 = new Promise(function(resolve, reject) {\n    setTimeout(() => {\n        resolve(p1), 1000\n    })\n})\np2.then(result => console.log(result))\n    .catch(error => console.log(error))\n//Error: fail\n```\n### .then方法，链式调用\n```\ngetJson(\"/posts.json\").then(\n    post => getJson(post.commentURL)\n).then(\n    comments => console.log('resolved:',comments)\n    err => console.log('reject:',err)\n)\n```\n上面是链式调用，从/post.json获取数据，成功后再用getJosn函数获取comment的url传入第二个.then作为参数，成功则打印评论，失误则打印错误。一般来说用catch方法捕获错误。\n```\nconst promise = new Promise(function(resolve, reject) {\n    throw new Error('test')\n})\npromise.catch((error) => {\n    console.log(error)\n})\n```\npromise会吃掉内部的错误，例子如下：\n```\nconst someAsyncThing = function() {\n    return new Promise((resolve, reject) => {\n        //这里x并没有定义\n        resolve (x+2)\n    })\n}\nsomeAsyncThing()\n.catch( (error) => {\n    console.log(error)\n})\n.then(() => {\n    console.log('carry on')\n})\n//ReferenceError: x is not defined\n    at Promise (<anonymous>:4:18)\n    at new Promise (<anonymous>)\n    at someAsyncThing (<anonymous>:2:12)\n    at <anonymous>:7:1\nVM193:12 carry on\n```\n这里在X没有定义的情况下，首先捕捉了错误，即使x未定义仍然运行.then函数输出了carry on \n\n\n### Promise.finally\nfinally 指定不敢Pormise的对象最后的结果如何，都会执行的操作\n```\npromise\n.then(result => {..})\n.catch(result => {...})\n.finally(result => {...})\n```\n\n### Promise.all\npromise.all方法讲对个promise实例，包装成一个promise实例。\n```\nconst p = Promise.all([p1, p2, p3])\n```\n上面代码中，promise会接受一个数组作为参数，p1, p2, p3都是Promise的实例，promise.all的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise的实例。\np的状态有p1,p2,p3确定：    \n- 只有p1, p2, p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1, p2, p3的返回值组成一个数组，作为参数传递给p的回调函数。\n- 只要p1, p2, p3有一个被reject，p的状态则变为reject，此时第一个被reject的返回值会作为参数，传递给p的回调函数。\n具体例子如下：\n```\n//这里并不觉得是6个promise的实例\nconst promises = [2,3,5,6,11,13].map(function(id) {\n    return getJson('/post/' + id + '.json')\n})\nPromise.all(promises).then( (posts) => {\n    .....\n}).catch((error) => {\n    .....\n})\n\n```\n再举个栗子更好理解的:\n```\nconst databasePromise = connectDatabase();\nconst booksPromise = databasePromise\n    ,then(findAllBook)\nconst userPromise = databasePromise\n    .then(getCurrentUser)\nPromise.all([bookPromise, userPromise])\n    .then(([book, user]) => {\n        pickTopRecommentaction(book, user)\n    })\n```\n这里，bookPromise和userPromise是两个异步操作，只有等到他们的结果都返回了，才会去执行pickTopRecommentaction这个回调函数。需要注意的如果作为参数的promise的实例被reject了，那么不会触发Promise.all的catch方法。\n例子：\n```\nconst p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result)\n.catch(e => e);\n\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('报错了');\n})\n.then(result => result)\n.catch(e => e);\n\nPromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// [\"hello\", Error: 报错了]\n```\n上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。    \n若p2未定义catch方法：\n```\nconst p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result);\n\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('报错了');\n})\n.then(result => result);\n\nPromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// Error: 报错了\n```\n首先，p2会reject，所以reject的返回值会作为参数给Promise.all，同事调用Promise.all的catch方法。\n\n### Promise.race\nconst p = Promise.race([p1, p2, p3])\n上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。\n\nPromise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。\n\n下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。\n```\nconst p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n]);\n\np\n.then(console.log)\n.catch(console.error);\n```\n","slug":"promise","published":1,"updated":"2022-05-20T02:24:20.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7k000zlae1f7j93k0c","content":"<h2 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a><center>promise</center></h2><p>promise是异步编程的一种解决方案，比起传统的解决方案–回调函数和事件更合理和强大。<br>所谓promise，简单的说是一个容器，里面保存着未来才会结束的事件(通常是一个异步操作)<br>promise的特点:</p>\n<ul>\n<li>对象的状态不受外界影响，promise对象代表一个异步操作，有三种状态:pending(进行中),fulfilled(已成功),rejected(已失效)。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作无法改变这个状态。这也是promise的由来。</li>\n<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果，promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变成rejected。只要这两种状态发生，状态就凝固了，不会再变了，会一直保持这个结果，这个结果就成为resolved(已定型)。如果改变已经发生了，你在对promise添加回调函数，也会立即得到这个结果。这与事件Event不同，事件的特点是如果你错过了它，再去监听，是得不到结果的。</li>\n<li>promise也有一些缺点，首先取消promise，一旦建立就会立即执行，无法中途取消，其次如果不设置回调函数，promise内部抛出的错误不会反映到外部，第三，当初与oending状态，无法得知目前处于哪一个阶段(刚刚开始还是即将完成)<a id=\"more\"></a>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise = new Promise(function(resolve, reject)&#123;</span><br><span class=\"line\">    //...some code</span><br><span class=\"line\">    if(/* 异步操作成功 */)&#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>resolve的作用是，将promise的对象从状态pending变为resolved，在异步操作成功时候调用，并将异步操作的结果作为参数传递出去；reject的作用是，再promise的状态由pending变为rejectd，在异步操作失败时候调用，并将异步操作的报出的错误，作为参数传递出去。<br>promise实例生成以后，可以用then方法分别指定resolved和rejected状态的回调函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value)&#123;</span><br><span class=\"line\">    //success</span><br><span class=\"line\">    &#125;,function(error)&#123;</span><br><span class=\"line\">    //failure</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>promise实例生成以后，可以接受两个回调函数作为参数，第一个回调函数是promise对象变为resolved时候调用，第二个是回调函数是promise变为reject时调用，第二个函数是可选的的，二者均接受promise对象传出的值作为参数。<br>例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function timeout(ms)&#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">        setTimeout(resolve, ms, &apos;done&apos;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">timeout(100).then((value) =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>上述代码中timeout方法返回了一个promise实例，表示一段时间才会发生的结果，过了指定的时间，promise的实例状态变为resolved，就会触发then方法绑定的回调函数。<br>继续举例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;promise&apos;);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(function() &#123;</span><br><span class=\"line\">    console.log(&apos;resolved&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(&apos;xxxx&apos;)</span><br><span class=\"line\">输出结果:</span><br><span class=\"line\">// promise</span><br><span class=\"line\">// xxxx</span><br><span class=\"line\">// resolved</span><br></pre></td></tr></table></figure></p>\n<p>上述代码中，promise建立后立即执行，首先输出promise，然后，.then方法指定的回调函数，将在当前脚本所有的同步任务执行完才会执行，所以resolved最后输出。<br>继续举例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function loadImage(url)&#123;</span><br><span class=\"line\">    retutn new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">        const image = new Image();</span><br><span class=\"line\">        image.onload = function() &#123;</span><br><span class=\"line\">            resolve(image)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        image.onerror = function() &#123;</span><br><span class=\"line\">            reject(new Error(&apos;could not load image at&apos; + url))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        image.src = url</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>异步加载图片，如果加载成功，则调用resolve方法，否则调用reject方法</p>\n<p>多个promise的实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p1 = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        reject(new Error(&apos;fail&apos;), 3000)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">const p2 = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        resolve(p1), 1000</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p2.then(result =&gt; console.log(result))</span><br><span class=\"line\">    .catch(error =&gt; console.log(error))</span><br><span class=\"line\">//Error: fail</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"then方法，链式调用\"><a href=\"#then方法，链式调用\" class=\"headerlink\" title=\".then方法，链式调用\"></a>.then方法，链式调用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJson(&quot;/posts.json&quot;).then(</span><br><span class=\"line\">    post =&gt; getJson(post.commentURL)</span><br><span class=\"line\">).then(</span><br><span class=\"line\">    comments =&gt; console.log(&apos;resolved:&apos;,comments)</span><br><span class=\"line\">    err =&gt; console.log(&apos;reject:&apos;,err)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>上面是链式调用，从/post.json获取数据，成功后再用getJosn函数获取comment的url传入第二个.then作为参数，成功则打印评论，失误则打印错误。一般来说用catch方法捕获错误。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">    throw new Error(&apos;test&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.catch((error) =&gt; &#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>promise会吃掉内部的错误，例子如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const someAsyncThing = function() &#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">        //这里x并没有定义</span><br><span class=\"line\">        resolve (x+2)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">someAsyncThing()</span><br><span class=\"line\">.catch( (error) =&gt; &#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;carry on&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//ReferenceError: x is not defined</span><br><span class=\"line\">    at Promise (&lt;anonymous&gt;:4:18)</span><br><span class=\"line\">    at new Promise (&lt;anonymous&gt;)</span><br><span class=\"line\">    at someAsyncThing (&lt;anonymous&gt;:2:12)</span><br><span class=\"line\">    at &lt;anonymous&gt;:7:1</span><br><span class=\"line\">VM193:12 carry on</span><br></pre></td></tr></table></figure></p>\n<p>这里在X没有定义的情况下，首先捕捉了错误，即使x未定义仍然运行.then函数输出了carry on </p>\n<h3 id=\"Promise-finally\"><a href=\"#Promise-finally\" class=\"headerlink\" title=\"Promise.finally\"></a>Promise.finally</h3><p>finally 指定不敢Pormise的对象最后的结果如何，都会执行的操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">.then(result =&gt; &#123;..&#125;)</span><br><span class=\"line\">.catch(result =&gt; &#123;...&#125;)</span><br><span class=\"line\">.finally(result =&gt; &#123;...&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><p>promise.all方法讲对个promise实例，包装成一个promise实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = Promise.all([p1, p2, p3])</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，promise会接受一个数组作为参数，p1, p2, p3都是Promise的实例，promise.all的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise的实例。<br>p的状态有p1,p2,p3确定：    </p>\n<ul>\n<li>只有p1, p2, p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1, p2, p3的返回值组成一个数组，作为参数传递给p的回调函数。</li>\n<li>只要p1, p2, p3有一个被reject，p的状态则变为reject，此时第一个被reject的返回值会作为参数，传递给p的回调函数。<br>具体例子如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这里并不觉得是6个promise的实例</span><br><span class=\"line\">const promises = [2,3,5,6,11,13].map(function(id) &#123;</span><br><span class=\"line\">    return getJson(&apos;/post/&apos; + id + &apos;.json&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Promise.all(promises).then( (posts) =&gt; &#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">&#125;).catch((error) =&gt; &#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>再举个栗子更好理解的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const databasePromise = connectDatabase();</span><br><span class=\"line\">const booksPromise = databasePromise</span><br><span class=\"line\">    ,then(findAllBook)</span><br><span class=\"line\">const userPromise = databasePromise</span><br><span class=\"line\">    .then(getCurrentUser)</span><br><span class=\"line\">Promise.all([bookPromise, userPromise])</span><br><span class=\"line\">    .then(([book, user]) =&gt; &#123;</span><br><span class=\"line\">        pickTopRecommentaction(book, user)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这里，bookPromise和userPromise是两个异步操作，只有等到他们的结果都返回了，才会去执行pickTopRecommentaction这个回调函数。需要注意的如果作为参数的promise的实例被reject了，那么不会触发Promise.all的catch方法。<br>例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  resolve(&apos;hello&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(result =&gt; result)</span><br><span class=\"line\">.catch(e =&gt; e);</span><br><span class=\"line\"></span><br><span class=\"line\">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  throw new Error(&apos;报错了&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(result =&gt; result)</span><br><span class=\"line\">.catch(e =&gt; e);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([p1, p2])</span><br><span class=\"line\">.then(result =&gt; console.log(result))</span><br><span class=\"line\">.catch(e =&gt; console.log(e));</span><br><span class=\"line\">// [&quot;hello&quot;, Error: 报错了]</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。<br>若p2未定义catch方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  resolve(&apos;hello&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(result =&gt; result);</span><br><span class=\"line\"></span><br><span class=\"line\">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  throw new Error(&apos;报错了&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(result =&gt; result);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([p1, p2])</span><br><span class=\"line\">.then(result =&gt; console.log(result))</span><br><span class=\"line\">.catch(e =&gt; console.log(e));</span><br><span class=\"line\">// Error: 报错了</span><br></pre></td></tr></table></figure></p>\n<p>首先，p2会reject，所以reject的返回值会作为参数给Promise.all，同事调用Promise.all的catch方法。</p>\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race\"></a>Promise.race</h3><p>const p = Promise.race([p1, p2, p3])<br>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>\n<p>Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p>\n<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = Promise.race([</span><br><span class=\"line\">  fetch(&apos;/resource-that-may-take-a-while&apos;),</span><br><span class=\"line\">  new Promise(function (resolve, reject) &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">p</span><br><span class=\"line\">.then(console.log)</span><br><span class=\"line\">.catch(console.error);</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a><center>promise</center></h2><p>promise是异步编程的一种解决方案，比起传统的解决方案–回调函数和事件更合理和强大。<br>所谓promise，简单的说是一个容器，里面保存着未来才会结束的事件(通常是一个异步操作)<br>promise的特点:</p>\n<ul>\n<li>对象的状态不受外界影响，promise对象代表一个异步操作，有三种状态:pending(进行中),fulfilled(已成功),rejected(已失效)。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作无法改变这个状态。这也是promise的由来。</li>\n<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果，promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变成rejected。只要这两种状态发生，状态就凝固了，不会再变了，会一直保持这个结果，这个结果就成为resolved(已定型)。如果改变已经发生了，你在对promise添加回调函数，也会立即得到这个结果。这与事件Event不同，事件的特点是如果你错过了它，再去监听，是得不到结果的。</li>\n<li>promise也有一些缺点，首先取消promise，一旦建立就会立即执行，无法中途取消，其次如果不设置回调函数，promise内部抛出的错误不会反映到外部，第三，当初与oending状态，无法得知目前处于哪一个阶段(刚刚开始还是即将完成)","more":"<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise = new Promise(function(resolve, reject)&#123;</span><br><span class=\"line\">    //...some code</span><br><span class=\"line\">    if(/* 异步操作成功 */)&#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>resolve的作用是，将promise的对象从状态pending变为resolved，在异步操作成功时候调用，并将异步操作的结果作为参数传递出去；reject的作用是，再promise的状态由pending变为rejectd，在异步操作失败时候调用，并将异步操作的报出的错误，作为参数传递出去。<br>promise实例生成以后，可以用then方法分别指定resolved和rejected状态的回调函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value)&#123;</span><br><span class=\"line\">    //success</span><br><span class=\"line\">    &#125;,function(error)&#123;</span><br><span class=\"line\">    //failure</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>promise实例生成以后，可以接受两个回调函数作为参数，第一个回调函数是promise对象变为resolved时候调用，第二个是回调函数是promise变为reject时调用，第二个函数是可选的的，二者均接受promise对象传出的值作为参数。<br>例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function timeout(ms)&#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">        setTimeout(resolve, ms, &apos;done&apos;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">timeout(100).then((value) =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>上述代码中timeout方法返回了一个promise实例，表示一段时间才会发生的结果，过了指定的时间，promise的实例状态变为resolved，就会触发then方法绑定的回调函数。<br>继续举例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;promise&apos;);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(function() &#123;</span><br><span class=\"line\">    console.log(&apos;resolved&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(&apos;xxxx&apos;)</span><br><span class=\"line\">输出结果:</span><br><span class=\"line\">// promise</span><br><span class=\"line\">// xxxx</span><br><span class=\"line\">// resolved</span><br></pre></td></tr></table></figure></p>\n<p>上述代码中，promise建立后立即执行，首先输出promise，然后，.then方法指定的回调函数，将在当前脚本所有的同步任务执行完才会执行，所以resolved最后输出。<br>继续举例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function loadImage(url)&#123;</span><br><span class=\"line\">    retutn new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">        const image = new Image();</span><br><span class=\"line\">        image.onload = function() &#123;</span><br><span class=\"line\">            resolve(image)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        image.onerror = function() &#123;</span><br><span class=\"line\">            reject(new Error(&apos;could not load image at&apos; + url))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        image.src = url</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>异步加载图片，如果加载成功，则调用resolve方法，否则调用reject方法</p>\n<p>多个promise的实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p1 = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        reject(new Error(&apos;fail&apos;), 3000)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">const p2 = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        resolve(p1), 1000</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p2.then(result =&gt; console.log(result))</span><br><span class=\"line\">    .catch(error =&gt; console.log(error))</span><br><span class=\"line\">//Error: fail</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"then方法，链式调用\"><a href=\"#then方法，链式调用\" class=\"headerlink\" title=\".then方法，链式调用\"></a>.then方法，链式调用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJson(&quot;/posts.json&quot;).then(</span><br><span class=\"line\">    post =&gt; getJson(post.commentURL)</span><br><span class=\"line\">).then(</span><br><span class=\"line\">    comments =&gt; console.log(&apos;resolved:&apos;,comments)</span><br><span class=\"line\">    err =&gt; console.log(&apos;reject:&apos;,err)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>上面是链式调用，从/post.json获取数据，成功后再用getJosn函数获取comment的url传入第二个.then作为参数，成功则打印评论，失误则打印错误。一般来说用catch方法捕获错误。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">    throw new Error(&apos;test&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.catch((error) =&gt; &#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>promise会吃掉内部的错误，例子如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const someAsyncThing = function() &#123;</span><br><span class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">        //这里x并没有定义</span><br><span class=\"line\">        resolve (x+2)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">someAsyncThing()</span><br><span class=\"line\">.catch( (error) =&gt; &#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;carry on&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//ReferenceError: x is not defined</span><br><span class=\"line\">    at Promise (&lt;anonymous&gt;:4:18)</span><br><span class=\"line\">    at new Promise (&lt;anonymous&gt;)</span><br><span class=\"line\">    at someAsyncThing (&lt;anonymous&gt;:2:12)</span><br><span class=\"line\">    at &lt;anonymous&gt;:7:1</span><br><span class=\"line\">VM193:12 carry on</span><br></pre></td></tr></table></figure></p>\n<p>这里在X没有定义的情况下，首先捕捉了错误，即使x未定义仍然运行.then函数输出了carry on </p>\n<h3 id=\"Promise-finally\"><a href=\"#Promise-finally\" class=\"headerlink\" title=\"Promise.finally\"></a>Promise.finally</h3><p>finally 指定不敢Pormise的对象最后的结果如何，都会执行的操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">.then(result =&gt; &#123;..&#125;)</span><br><span class=\"line\">.catch(result =&gt; &#123;...&#125;)</span><br><span class=\"line\">.finally(result =&gt; &#123;...&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><p>promise.all方法讲对个promise实例，包装成一个promise实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = Promise.all([p1, p2, p3])</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，promise会接受一个数组作为参数，p1, p2, p3都是Promise的实例，promise.all的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise的实例。<br>p的状态有p1,p2,p3确定：    </p>\n<ul>\n<li>只有p1, p2, p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1, p2, p3的返回值组成一个数组，作为参数传递给p的回调函数。</li>\n<li>只要p1, p2, p3有一个被reject，p的状态则变为reject，此时第一个被reject的返回值会作为参数，传递给p的回调函数。<br>具体例子如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这里并不觉得是6个promise的实例</span><br><span class=\"line\">const promises = [2,3,5,6,11,13].map(function(id) &#123;</span><br><span class=\"line\">    return getJson(&apos;/post/&apos; + id + &apos;.json&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Promise.all(promises).then( (posts) =&gt; &#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">&#125;).catch((error) =&gt; &#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>再举个栗子更好理解的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const databasePromise = connectDatabase();</span><br><span class=\"line\">const booksPromise = databasePromise</span><br><span class=\"line\">    ,then(findAllBook)</span><br><span class=\"line\">const userPromise = databasePromise</span><br><span class=\"line\">    .then(getCurrentUser)</span><br><span class=\"line\">Promise.all([bookPromise, userPromise])</span><br><span class=\"line\">    .then(([book, user]) =&gt; &#123;</span><br><span class=\"line\">        pickTopRecommentaction(book, user)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这里，bookPromise和userPromise是两个异步操作，只有等到他们的结果都返回了，才会去执行pickTopRecommentaction这个回调函数。需要注意的如果作为参数的promise的实例被reject了，那么不会触发Promise.all的catch方法。<br>例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  resolve(&apos;hello&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(result =&gt; result)</span><br><span class=\"line\">.catch(e =&gt; e);</span><br><span class=\"line\"></span><br><span class=\"line\">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  throw new Error(&apos;报错了&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(result =&gt; result)</span><br><span class=\"line\">.catch(e =&gt; e);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([p1, p2])</span><br><span class=\"line\">.then(result =&gt; console.log(result))</span><br><span class=\"line\">.catch(e =&gt; console.log(e));</span><br><span class=\"line\">// [&quot;hello&quot;, Error: 报错了]</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。<br>若p2未定义catch方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  resolve(&apos;hello&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(result =&gt; result);</span><br><span class=\"line\"></span><br><span class=\"line\">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  throw new Error(&apos;报错了&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(result =&gt; result);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([p1, p2])</span><br><span class=\"line\">.then(result =&gt; console.log(result))</span><br><span class=\"line\">.catch(e =&gt; console.log(e));</span><br><span class=\"line\">// Error: 报错了</span><br></pre></td></tr></table></figure></p>\n<p>首先，p2会reject，所以reject的返回值会作为参数给Promise.all，同事调用Promise.all的catch方法。</p>\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race\"></a>Promise.race</h3><p>const p = Promise.race([p1, p2, p3])<br>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>\n<p>Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</p>\n<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = Promise.race([</span><br><span class=\"line\">  fetch(&apos;/resource-that-may-take-a-while&apos;),</span><br><span class=\"line\">  new Promise(function (resolve, reject) &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">p</span><br><span class=\"line\">.then(console.log)</span><br><span class=\"line\">.catch(console.error);</span><br></pre></td></tr></table></figure></p>"},{"layout":"posts","title":"python装饰器","date":"2019-03-15T01:26:48.000Z","_content":"\n### 转:一种自顶而下的python装饰器的设计方法\n\n昨天阅读了一篇关于装饰器的文章，读了感觉写的挺好的，自己在记录一遍加深印象。\n\n#### python装饰器原理\n\npython装饰器的常规写法:\n```\n@decorator\ndef func(8args, **kwargs)\n    so_something()\n```\n这种写法只是一种语法糖，使得代码看起来更加简洁，在python解释器内部，函数`func`的调用被转换为下面的方式.\n```\n>>>func(a, ,b, c='value')\n>>>decorated_func = decorator(func)\n>>>decorated_func(a, b, c='value')\n```\n<!--more -->\n#### 简单装饰器\n\n简单的装饰器不带任何参数，例如，我们把装饰器命名为`timethis`\n```\n@timethis\ndef func(*args, **kwargs):\n    pass\n```\n根据上文的分解，我们可以写出装饰器的模板代码\n```\ndef timethis(func):\n    def wrapper(*args, **kwargs):\n        pass\n    return wrapper\n```\n如此，装饰器的框架搭建好了，需要丰富下函数的逻辑。对于被装饰的`func`的调用，相当于对wrapper的调用。\n```\ndef timethis(func)\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return wrapper\n```\n我们可以丰富函数`wrapper`的逻辑，我们的需求是打印`func`的调用时间,在'func'前后调用计时。\n```\ndef timethis(func):\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(func.__name__, end-start)\n        return result\n    return wrapper\n```\n至此，完成一个打印函数事件的装饰器，不过在`func.__name__`这里，我们会返回wrapper，只需要在加上`@wrap(func)`即可返回正确的名称。测试一下\n\n```\n@timethis\ndef fibonacci(n):\n    a = b = 1\n    while n > 2:\n        a, b = b, a+b\n        n -= 1\n    return b\nfibonacci(100)\n```\n\n#### 带参数的装饰器\n\n上面的装饰器简单些，不带参数，我们常看到带有参数的装饰器。\n```\n@logged(debug, name='example', message='message')\ndef func(*args, **kwargs):\n    pass\n```\n`logged`返回一个装饰器，这个装饰器再去装饰`func`函数，因此`logged`的模板应为:\n```\ndef logged(level, name=None, message=None):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            pass\n        return wrapper\n    return decorator\n```\n可见`wrapper`是最终被调用的函数,我们可以丰富`decorator`和`wrapper`这两个函数。\n```\nfrom functools import wraps\ndef logged(level, name=None, message=None):\n    def decorator(func):\n        logname = name if name else func.__module__\n        logmsg = message if message else func.__name__\n        @wraps\n        def wrapper(*args, kwargs):\n            print(level, logname, logmsg)\n            result = func(*args, **kwargs)\n        return wrapper\n    return decorator\n```\n例子如下:\n```\nfrom functools import wraps\n    ...: def logged(level, name=None, message=None):\n    ...:     def decorator(func):\n    ...:         logname = name if name else func.__module__\n    ...:         logmsg = message if message else func.__name__\n    ...:         @wraps(func)\n    ...:         def wrapper(*args, **kwargs):\n    ...:             print(level, logname, logmsg)\n    ...:             result = func(*args, **kwargs)\n    ...:             return result\n    ...:         return wrapper\n    ...:     return decorator\n\n@logged('info', name='aaa', message='bbb')\ndef test(a,b):\n    return a+b\n    \ntest(1,3)\n输出: info aaa bbb\nout 4\n```\n\n#### 多功能装饰器\n\n```\n@logged\ndef func(*args, **args):\n    pass\n    \n@logged(level, name='example', message='example')\ndef func(*args, **kwargs):\n    pass\n```\n根据前面的分析，带有参数的装饰器和不带参数的装饰器是不同的，不带参数的装饰器返回的是被装饰的函数，而带参数的装饰器返回的是不带参数的装饰器(不太准确，被传递的func也算作参数),然后再返回被装饰的函数，多了一层相当于。需要用到`partial`。\n```\nfrom functools import wraps, partial\n\ndef logged(func=None, level='debug', name=None, message=None):\n    if func is None:\n        reutrn partial(logged, level=level, name=name, message=message)\n    logname = name if name else func.__module__\n    logmsg = message if message else func.__name__\n    \n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print(level, lgoname, logmsg)\n        return func(*args, **kwargs)\n    return wrapper\n    \n```\n这个装饰器以带参数的形式使用，这里的第一个参数`func`\n值为`None`,此时我们用`partial`反返回了一个其他参数的固定装饰器，这个装饰器与不带参数的简单装饰器一样。\n```\n #使用@logged装饰\n>>>func(a, b, c)\n>>> decorated_func = logged(func)  #可见func不为空\n>>> decorated_func(a, b, c)\n\n #使用@logged(level=level, name='example', message='message' )\n 相当于\n>>> decorator = logged(level=level, name='example', message='message')\n>>> decorated_func = decorator(func)\n>>> decorated_fun(a,b,c)\n\n #例子如下\n@logged\ndef test(a,b):\n   reutrn a+b\ntest(1,2)\n输出: None, __main__ test, 第一个是level默认为None\n\n@logged(level='aa', name='bb', message='cc')\ndef test(a,b):\n    return a+b\n    \ntest(3,4)\n输出: aa,bb,cc\n```\n例子    \n设计一个装饰器函数retry,当被装饰的函数抛出指定的异常时候，函数会被重新调用，直到达到最大调用次数才重新抛出指定的异常，使用示例如下\n```\n@retry(times=10, traced_exception=ValueError,reraised_exception=CustomException)\ndef test():\n    pass\n```\n其中，traced_exception为监控的异常，可以为None(默认),异常类，或者一个异常类的列表，如果为None，则监听所有的异常；如果指定了异常类，若函数调用抛出指定的异常，重新调用函数，直至返回成功或者达到最大尝试次数，此时重新抛出原异常(reraised_exception的值为None），或者抛出有reraised_exception指定的异常。\n\n```\ndef retry(times=10, traced_exception=None, reraised_exception=None):\n    def decorator(func)\n        @wraps\n        def wrapper(*args, **kwargs):\n            n = times\n            traced_all =  traced_exption is None\n            traced_spec = traced_exption is not None\n            while True:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    traced = traced_spec and isinstance(e, traced_exception)    \n                    reached_limits = n == 0\n                    if not(trace_all or  traced) or reached_limits:\n                        if reraise_exception is not None:\n                            raise reraise_exception\n                        raise\n                    n -= 1\n        return wrapper\n    return decorator\n```\n","source":"_posts/python装饰器.md","raw":"---\nlayout: posts\ntitle: python装饰器\ndate: 2019-03-15 09:26:48\ntags: python\ncategories: python\n---\n\n### 转:一种自顶而下的python装饰器的设计方法\n\n昨天阅读了一篇关于装饰器的文章，读了感觉写的挺好的，自己在记录一遍加深印象。\n\n#### python装饰器原理\n\npython装饰器的常规写法:\n```\n@decorator\ndef func(8args, **kwargs)\n    so_something()\n```\n这种写法只是一种语法糖，使得代码看起来更加简洁，在python解释器内部，函数`func`的调用被转换为下面的方式.\n```\n>>>func(a, ,b, c='value')\n>>>decorated_func = decorator(func)\n>>>decorated_func(a, b, c='value')\n```\n<!--more -->\n#### 简单装饰器\n\n简单的装饰器不带任何参数，例如，我们把装饰器命名为`timethis`\n```\n@timethis\ndef func(*args, **kwargs):\n    pass\n```\n根据上文的分解，我们可以写出装饰器的模板代码\n```\ndef timethis(func):\n    def wrapper(*args, **kwargs):\n        pass\n    return wrapper\n```\n如此，装饰器的框架搭建好了，需要丰富下函数的逻辑。对于被装饰的`func`的调用，相当于对wrapper的调用。\n```\ndef timethis(func)\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return wrapper\n```\n我们可以丰富函数`wrapper`的逻辑，我们的需求是打印`func`的调用时间,在'func'前后调用计时。\n```\ndef timethis(func):\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(func.__name__, end-start)\n        return result\n    return wrapper\n```\n至此，完成一个打印函数事件的装饰器，不过在`func.__name__`这里，我们会返回wrapper，只需要在加上`@wrap(func)`即可返回正确的名称。测试一下\n\n```\n@timethis\ndef fibonacci(n):\n    a = b = 1\n    while n > 2:\n        a, b = b, a+b\n        n -= 1\n    return b\nfibonacci(100)\n```\n\n#### 带参数的装饰器\n\n上面的装饰器简单些，不带参数，我们常看到带有参数的装饰器。\n```\n@logged(debug, name='example', message='message')\ndef func(*args, **kwargs):\n    pass\n```\n`logged`返回一个装饰器，这个装饰器再去装饰`func`函数，因此`logged`的模板应为:\n```\ndef logged(level, name=None, message=None):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            pass\n        return wrapper\n    return decorator\n```\n可见`wrapper`是最终被调用的函数,我们可以丰富`decorator`和`wrapper`这两个函数。\n```\nfrom functools import wraps\ndef logged(level, name=None, message=None):\n    def decorator(func):\n        logname = name if name else func.__module__\n        logmsg = message if message else func.__name__\n        @wraps\n        def wrapper(*args, kwargs):\n            print(level, logname, logmsg)\n            result = func(*args, **kwargs)\n        return wrapper\n    return decorator\n```\n例子如下:\n```\nfrom functools import wraps\n    ...: def logged(level, name=None, message=None):\n    ...:     def decorator(func):\n    ...:         logname = name if name else func.__module__\n    ...:         logmsg = message if message else func.__name__\n    ...:         @wraps(func)\n    ...:         def wrapper(*args, **kwargs):\n    ...:             print(level, logname, logmsg)\n    ...:             result = func(*args, **kwargs)\n    ...:             return result\n    ...:         return wrapper\n    ...:     return decorator\n\n@logged('info', name='aaa', message='bbb')\ndef test(a,b):\n    return a+b\n    \ntest(1,3)\n输出: info aaa bbb\nout 4\n```\n\n#### 多功能装饰器\n\n```\n@logged\ndef func(*args, **args):\n    pass\n    \n@logged(level, name='example', message='example')\ndef func(*args, **kwargs):\n    pass\n```\n根据前面的分析，带有参数的装饰器和不带参数的装饰器是不同的，不带参数的装饰器返回的是被装饰的函数，而带参数的装饰器返回的是不带参数的装饰器(不太准确，被传递的func也算作参数),然后再返回被装饰的函数，多了一层相当于。需要用到`partial`。\n```\nfrom functools import wraps, partial\n\ndef logged(func=None, level='debug', name=None, message=None):\n    if func is None:\n        reutrn partial(logged, level=level, name=name, message=message)\n    logname = name if name else func.__module__\n    logmsg = message if message else func.__name__\n    \n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print(level, lgoname, logmsg)\n        return func(*args, **kwargs)\n    return wrapper\n    \n```\n这个装饰器以带参数的形式使用，这里的第一个参数`func`\n值为`None`,此时我们用`partial`反返回了一个其他参数的固定装饰器，这个装饰器与不带参数的简单装饰器一样。\n```\n #使用@logged装饰\n>>>func(a, b, c)\n>>> decorated_func = logged(func)  #可见func不为空\n>>> decorated_func(a, b, c)\n\n #使用@logged(level=level, name='example', message='message' )\n 相当于\n>>> decorator = logged(level=level, name='example', message='message')\n>>> decorated_func = decorator(func)\n>>> decorated_fun(a,b,c)\n\n #例子如下\n@logged\ndef test(a,b):\n   reutrn a+b\ntest(1,2)\n输出: None, __main__ test, 第一个是level默认为None\n\n@logged(level='aa', name='bb', message='cc')\ndef test(a,b):\n    return a+b\n    \ntest(3,4)\n输出: aa,bb,cc\n```\n例子    \n设计一个装饰器函数retry,当被装饰的函数抛出指定的异常时候，函数会被重新调用，直到达到最大调用次数才重新抛出指定的异常，使用示例如下\n```\n@retry(times=10, traced_exception=ValueError,reraised_exception=CustomException)\ndef test():\n    pass\n```\n其中，traced_exception为监控的异常，可以为None(默认),异常类，或者一个异常类的列表，如果为None，则监听所有的异常；如果指定了异常类，若函数调用抛出指定的异常，重新调用函数，直至返回成功或者达到最大尝试次数，此时重新抛出原异常(reraised_exception的值为None），或者抛出有reraised_exception指定的异常。\n\n```\ndef retry(times=10, traced_exception=None, reraised_exception=None):\n    def decorator(func)\n        @wraps\n        def wrapper(*args, **kwargs):\n            n = times\n            traced_all =  traced_exption is None\n            traced_spec = traced_exption is not None\n            while True:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    traced = traced_spec and isinstance(e, traced_exception)    \n                    reached_limits = n == 0\n                    if not(trace_all or  traced) or reached_limits:\n                        if reraise_exception is not None:\n                            raise reraise_exception\n                        raise\n                    n -= 1\n        return wrapper\n    return decorator\n```\n","slug":"python装饰器","published":1,"updated":"2022-05-20T02:24:20.542Z","comments":1,"photos":[],"link":"","_id":"cl3e0vh7l0014lae1av9wai81","content":"<h3 id=\"转-一种自顶而下的python装饰器的设计方法\"><a href=\"#转-一种自顶而下的python装饰器的设计方法\" class=\"headerlink\" title=\"转:一种自顶而下的python装饰器的设计方法\"></a>转:一种自顶而下的python装饰器的设计方法</h3><p>昨天阅读了一篇关于装饰器的文章，读了感觉写的挺好的，自己在记录一遍加深印象。</p>\n<h4 id=\"python装饰器原理\"><a href=\"#python装饰器原理\" class=\"headerlink\" title=\"python装饰器原理\"></a>python装饰器原理</h4><p>python装饰器的常规写法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@decorator</span><br><span class=\"line\">def func(8args, **kwargs)</span><br><span class=\"line\">    so_something()</span><br></pre></td></tr></table></figure></p>\n<p>这种写法只是一种语法糖，使得代码看起来更加简洁，在python解释器内部，函数<code>func</code>的调用被转换为下面的方式.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;func(a, ,b, c=&apos;value&apos;)</span><br><span class=\"line\">&gt;&gt;&gt;decorated_func = decorator(func)</span><br><span class=\"line\">&gt;&gt;&gt;decorated_func(a, b, c=&apos;value&apos;)</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h4 id=\"简单装饰器\"><a href=\"#简单装饰器\" class=\"headerlink\" title=\"简单装饰器\"></a>简单装饰器</h4><p>简单的装饰器不带任何参数，例如，我们把装饰器命名为<code>timethis</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@timethis</span><br><span class=\"line\">def func(*args, **kwargs):</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure></p>\n<p>根据上文的分解，我们可以写出装饰器的模板代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def timethis(func):</span><br><span class=\"line\">    def wrapper(*args, **kwargs):</span><br><span class=\"line\">        pass</span><br><span class=\"line\">    return wrapper</span><br></pre></td></tr></table></figure></p>\n<p>如此，装饰器的框架搭建好了，需要丰富下函数的逻辑。对于被装饰的<code>func</code>的调用，相当于对wrapper的调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def timethis(func)</span><br><span class=\"line\">    def wrapper(*args, **kwargs):</span><br><span class=\"line\">        result = func(*args, **kwargs)</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    return wrapper</span><br></pre></td></tr></table></figure></p>\n<p>我们可以丰富函数<code>wrapper</code>的逻辑，我们的需求是打印<code>func</code>的调用时间,在’func’前后调用计时。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def timethis(func):</span><br><span class=\"line\">    def wrapper(*args, **kwargs):</span><br><span class=\"line\">        start = time.time()</span><br><span class=\"line\">        result = func(*args, **kwargs)</span><br><span class=\"line\">        end = time.time()</span><br><span class=\"line\">        print(func.__name__, end-start)</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    return wrapper</span><br></pre></td></tr></table></figure></p>\n<p>至此，完成一个打印函数事件的装饰器，不过在<code>func.__name__</code>这里，我们会返回wrapper，只需要在加上<code>@wrap(func)</code>即可返回正确的名称。测试一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@timethis</span><br><span class=\"line\">def fibonacci(n):</span><br><span class=\"line\">    a = b = 1</span><br><span class=\"line\">    while n &gt; 2:</span><br><span class=\"line\">        a, b = b, a+b</span><br><span class=\"line\">        n -= 1</span><br><span class=\"line\">    return b</span><br><span class=\"line\">fibonacci(100)</span><br></pre></td></tr></table></figure>\n<h4 id=\"带参数的装饰器\"><a href=\"#带参数的装饰器\" class=\"headerlink\" title=\"带参数的装饰器\"></a>带参数的装饰器</h4><p>上面的装饰器简单些，不带参数，我们常看到带有参数的装饰器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@logged(debug, name=&apos;example&apos;, message=&apos;message&apos;)</span><br><span class=\"line\">def func(*args, **kwargs):</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure></p>\n<p><code>logged</code>返回一个装饰器，这个装饰器再去装饰<code>func</code>函数，因此<code>logged</code>的模板应为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def logged(level, name=None, message=None):</span><br><span class=\"line\">    def decorator(func):</span><br><span class=\"line\">        @wraps(func)</span><br><span class=\"line\">        def wrapper(*args, **kwargs):</span><br><span class=\"line\">            pass</span><br><span class=\"line\">        return wrapper</span><br><span class=\"line\">    return decorator</span><br></pre></td></tr></table></figure></p>\n<p>可见<code>wrapper</code>是最终被调用的函数,我们可以丰富<code>decorator</code>和<code>wrapper</code>这两个函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import wraps</span><br><span class=\"line\">def logged(level, name=None, message=None):</span><br><span class=\"line\">    def decorator(func):</span><br><span class=\"line\">        logname = name if name else func.__module__</span><br><span class=\"line\">        logmsg = message if message else func.__name__</span><br><span class=\"line\">        @wraps</span><br><span class=\"line\">        def wrapper(*args, kwargs):</span><br><span class=\"line\">            print(level, logname, logmsg)</span><br><span class=\"line\">            result = func(*args, **kwargs)</span><br><span class=\"line\">        return wrapper</span><br><span class=\"line\">    return decorator</span><br></pre></td></tr></table></figure></p>\n<p>例子如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import wraps</span><br><span class=\"line\">    ...: def logged(level, name=None, message=None):</span><br><span class=\"line\">    ...:     def decorator(func):</span><br><span class=\"line\">    ...:         logname = name if name else func.__module__</span><br><span class=\"line\">    ...:         logmsg = message if message else func.__name__</span><br><span class=\"line\">    ...:         @wraps(func)</span><br><span class=\"line\">    ...:         def wrapper(*args, **kwargs):</span><br><span class=\"line\">    ...:             print(level, logname, logmsg)</span><br><span class=\"line\">    ...:             result = func(*args, **kwargs)</span><br><span class=\"line\">    ...:             return result</span><br><span class=\"line\">    ...:         return wrapper</span><br><span class=\"line\">    ...:     return decorator</span><br><span class=\"line\"></span><br><span class=\"line\">@logged(&apos;info&apos;, name=&apos;aaa&apos;, message=&apos;bbb&apos;)</span><br><span class=\"line\">def test(a,b):</span><br><span class=\"line\">    return a+b</span><br><span class=\"line\">    </span><br><span class=\"line\">test(1,3)</span><br><span class=\"line\">输出: info aaa bbb</span><br><span class=\"line\">out 4</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"多功能装饰器\"><a href=\"#多功能装饰器\" class=\"headerlink\" title=\"多功能装饰器\"></a>多功能装饰器</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@logged</span><br><span class=\"line\">def func(*args, **args):</span><br><span class=\"line\">    pass</span><br><span class=\"line\">    </span><br><span class=\"line\">@logged(level, name=&apos;example&apos;, message=&apos;example&apos;)</span><br><span class=\"line\">def func(*args, **kwargs):</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>\n<p>根据前面的分析，带有参数的装饰器和不带参数的装饰器是不同的，不带参数的装饰器返回的是被装饰的函数，而带参数的装饰器返回的是不带参数的装饰器(不太准确，被传递的func也算作参数),然后再返回被装饰的函数，多了一层相当于。需要用到<code>partial</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import wraps, partial</span><br><span class=\"line\"></span><br><span class=\"line\">def logged(func=None, level=&apos;debug&apos;, name=None, message=None):</span><br><span class=\"line\">    if func is None:</span><br><span class=\"line\">        reutrn partial(logged, level=level, name=name, message=message)</span><br><span class=\"line\">    logname = name if name else func.__module__</span><br><span class=\"line\">    logmsg = message if message else func.__name__</span><br><span class=\"line\">    </span><br><span class=\"line\">    @wraps(func)</span><br><span class=\"line\">    def wrapper(*args, **kwargs):</span><br><span class=\"line\">        print(level, lgoname, logmsg)</span><br><span class=\"line\">        return func(*args, **kwargs)</span><br><span class=\"line\">    return wrapper</span><br></pre></td></tr></table></figure></p>\n<p>这个装饰器以带参数的形式使用，这里的第一个参数<code>func</code><br>值为<code>None</code>,此时我们用<code>partial</code>反返回了一个其他参数的固定装饰器，这个装饰器与不带参数的简单装饰器一样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> #使用@logged装饰</span><br><span class=\"line\">&gt;&gt;&gt;func(a, b, c)</span><br><span class=\"line\">&gt;&gt;&gt; decorated_func = logged(func)  #可见func不为空</span><br><span class=\"line\">&gt;&gt;&gt; decorated_func(a, b, c)</span><br><span class=\"line\"></span><br><span class=\"line\"> #使用@logged(level=level, name=&apos;example&apos;, message=&apos;message&apos; )</span><br><span class=\"line\"> 相当于</span><br><span class=\"line\">&gt;&gt;&gt; decorator = logged(level=level, name=&apos;example&apos;, message=&apos;message&apos;)</span><br><span class=\"line\">&gt;&gt;&gt; decorated_func = decorator(func)</span><br><span class=\"line\">&gt;&gt;&gt; decorated_fun(a,b,c)</span><br><span class=\"line\"></span><br><span class=\"line\"> #例子如下</span><br><span class=\"line\">@logged</span><br><span class=\"line\">def test(a,b):</span><br><span class=\"line\">   reutrn a+b</span><br><span class=\"line\">test(1,2)</span><br><span class=\"line\">输出: None, __main__ test, 第一个是level默认为None</span><br><span class=\"line\"></span><br><span class=\"line\">@logged(level=&apos;aa&apos;, name=&apos;bb&apos;, message=&apos;cc&apos;)</span><br><span class=\"line\">def test(a,b):</span><br><span class=\"line\">    return a+b</span><br><span class=\"line\">    </span><br><span class=\"line\">test(3,4)</span><br><span class=\"line\">输出: aa,bb,cc</span><br></pre></td></tr></table></figure></p>\n<p>例子<br>设计一个装饰器函数retry,当被装饰的函数抛出指定的异常时候，函数会被重新调用，直到达到最大调用次数才重新抛出指定的异常，使用示例如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@retry(times=10, traced_exception=ValueError,reraised_exception=CustomException)</span><br><span class=\"line\">def test():</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure></p>\n<p>其中，traced_exception为监控的异常，可以为None(默认),异常类，或者一个异常类的列表，如果为None，则监听所有的异常；如果指定了异常类，若函数调用抛出指定的异常，重新调用函数，直至返回成功或者达到最大尝试次数，此时重新抛出原异常(reraised_exception的值为None），或者抛出有reraised_exception指定的异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def retry(times=10, traced_exception=None, reraised_exception=None):</span><br><span class=\"line\">    def decorator(func)</span><br><span class=\"line\">        @wraps</span><br><span class=\"line\">        def wrapper(*args, **kwargs):</span><br><span class=\"line\">            n = times</span><br><span class=\"line\">            traced_all =  traced_exption is None</span><br><span class=\"line\">            traced_spec = traced_exption is not None</span><br><span class=\"line\">            while True:</span><br><span class=\"line\">                try:</span><br><span class=\"line\">                    return func(*args, **kwargs)</span><br><span class=\"line\">                except Exception as e:</span><br><span class=\"line\">                    traced = traced_spec and isinstance(e, traced_exception)    </span><br><span class=\"line\">                    reached_limits = n == 0</span><br><span class=\"line\">                    if not(trace_all or  traced) or reached_limits:</span><br><span class=\"line\">                        if reraise_exception is not None:</span><br><span class=\"line\">                            raise reraise_exception</span><br><span class=\"line\">                        raise</span><br><span class=\"line\">                    n -= 1</span><br><span class=\"line\">        return wrapper</span><br><span class=\"line\">    return decorator</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"转-一种自顶而下的python装饰器的设计方法\"><a href=\"#转-一种自顶而下的python装饰器的设计方法\" class=\"headerlink\" title=\"转:一种自顶而下的python装饰器的设计方法\"></a>转:一种自顶而下的python装饰器的设计方法</h3><p>昨天阅读了一篇关于装饰器的文章，读了感觉写的挺好的，自己在记录一遍加深印象。</p>\n<h4 id=\"python装饰器原理\"><a href=\"#python装饰器原理\" class=\"headerlink\" title=\"python装饰器原理\"></a>python装饰器原理</h4><p>python装饰器的常规写法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@decorator</span><br><span class=\"line\">def func(8args, **kwargs)</span><br><span class=\"line\">    so_something()</span><br></pre></td></tr></table></figure></p>\n<p>这种写法只是一种语法糖，使得代码看起来更加简洁，在python解释器内部，函数<code>func</code>的调用被转换为下面的方式.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;func(a, ,b, c=&apos;value&apos;)</span><br><span class=\"line\">&gt;&gt;&gt;decorated_func = decorator(func)</span><br><span class=\"line\">&gt;&gt;&gt;decorated_func(a, b, c=&apos;value&apos;)</span><br></pre></td></tr></table></figure></p>","more":"<h4 id=\"简单装饰器\"><a href=\"#简单装饰器\" class=\"headerlink\" title=\"简单装饰器\"></a>简单装饰器</h4><p>简单的装饰器不带任何参数，例如，我们把装饰器命名为<code>timethis</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@timethis</span><br><span class=\"line\">def func(*args, **kwargs):</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure></p>\n<p>根据上文的分解，我们可以写出装饰器的模板代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def timethis(func):</span><br><span class=\"line\">    def wrapper(*args, **kwargs):</span><br><span class=\"line\">        pass</span><br><span class=\"line\">    return wrapper</span><br></pre></td></tr></table></figure></p>\n<p>如此，装饰器的框架搭建好了，需要丰富下函数的逻辑。对于被装饰的<code>func</code>的调用，相当于对wrapper的调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def timethis(func)</span><br><span class=\"line\">    def wrapper(*args, **kwargs):</span><br><span class=\"line\">        result = func(*args, **kwargs)</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    return wrapper</span><br></pre></td></tr></table></figure></p>\n<p>我们可以丰富函数<code>wrapper</code>的逻辑，我们的需求是打印<code>func</code>的调用时间,在’func’前后调用计时。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def timethis(func):</span><br><span class=\"line\">    def wrapper(*args, **kwargs):</span><br><span class=\"line\">        start = time.time()</span><br><span class=\"line\">        result = func(*args, **kwargs)</span><br><span class=\"line\">        end = time.time()</span><br><span class=\"line\">        print(func.__name__, end-start)</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    return wrapper</span><br></pre></td></tr></table></figure></p>\n<p>至此，完成一个打印函数事件的装饰器，不过在<code>func.__name__</code>这里，我们会返回wrapper，只需要在加上<code>@wrap(func)</code>即可返回正确的名称。测试一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@timethis</span><br><span class=\"line\">def fibonacci(n):</span><br><span class=\"line\">    a = b = 1</span><br><span class=\"line\">    while n &gt; 2:</span><br><span class=\"line\">        a, b = b, a+b</span><br><span class=\"line\">        n -= 1</span><br><span class=\"line\">    return b</span><br><span class=\"line\">fibonacci(100)</span><br></pre></td></tr></table></figure>\n<h4 id=\"带参数的装饰器\"><a href=\"#带参数的装饰器\" class=\"headerlink\" title=\"带参数的装饰器\"></a>带参数的装饰器</h4><p>上面的装饰器简单些，不带参数，我们常看到带有参数的装饰器。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@logged(debug, name=&apos;example&apos;, message=&apos;message&apos;)</span><br><span class=\"line\">def func(*args, **kwargs):</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure></p>\n<p><code>logged</code>返回一个装饰器，这个装饰器再去装饰<code>func</code>函数，因此<code>logged</code>的模板应为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def logged(level, name=None, message=None):</span><br><span class=\"line\">    def decorator(func):</span><br><span class=\"line\">        @wraps(func)</span><br><span class=\"line\">        def wrapper(*args, **kwargs):</span><br><span class=\"line\">            pass</span><br><span class=\"line\">        return wrapper</span><br><span class=\"line\">    return decorator</span><br></pre></td></tr></table></figure></p>\n<p>可见<code>wrapper</code>是最终被调用的函数,我们可以丰富<code>decorator</code>和<code>wrapper</code>这两个函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import wraps</span><br><span class=\"line\">def logged(level, name=None, message=None):</span><br><span class=\"line\">    def decorator(func):</span><br><span class=\"line\">        logname = name if name else func.__module__</span><br><span class=\"line\">        logmsg = message if message else func.__name__</span><br><span class=\"line\">        @wraps</span><br><span class=\"line\">        def wrapper(*args, kwargs):</span><br><span class=\"line\">            print(level, logname, logmsg)</span><br><span class=\"line\">            result = func(*args, **kwargs)</span><br><span class=\"line\">        return wrapper</span><br><span class=\"line\">    return decorator</span><br></pre></td></tr></table></figure></p>\n<p>例子如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import wraps</span><br><span class=\"line\">    ...: def logged(level, name=None, message=None):</span><br><span class=\"line\">    ...:     def decorator(func):</span><br><span class=\"line\">    ...:         logname = name if name else func.__module__</span><br><span class=\"line\">    ...:         logmsg = message if message else func.__name__</span><br><span class=\"line\">    ...:         @wraps(func)</span><br><span class=\"line\">    ...:         def wrapper(*args, **kwargs):</span><br><span class=\"line\">    ...:             print(level, logname, logmsg)</span><br><span class=\"line\">    ...:             result = func(*args, **kwargs)</span><br><span class=\"line\">    ...:             return result</span><br><span class=\"line\">    ...:         return wrapper</span><br><span class=\"line\">    ...:     return decorator</span><br><span class=\"line\"></span><br><span class=\"line\">@logged(&apos;info&apos;, name=&apos;aaa&apos;, message=&apos;bbb&apos;)</span><br><span class=\"line\">def test(a,b):</span><br><span class=\"line\">    return a+b</span><br><span class=\"line\">    </span><br><span class=\"line\">test(1,3)</span><br><span class=\"line\">输出: info aaa bbb</span><br><span class=\"line\">out 4</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"多功能装饰器\"><a href=\"#多功能装饰器\" class=\"headerlink\" title=\"多功能装饰器\"></a>多功能装饰器</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@logged</span><br><span class=\"line\">def func(*args, **args):</span><br><span class=\"line\">    pass</span><br><span class=\"line\">    </span><br><span class=\"line\">@logged(level, name=&apos;example&apos;, message=&apos;example&apos;)</span><br><span class=\"line\">def func(*args, **kwargs):</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>\n<p>根据前面的分析，带有参数的装饰器和不带参数的装饰器是不同的，不带参数的装饰器返回的是被装饰的函数，而带参数的装饰器返回的是不带参数的装饰器(不太准确，被传递的func也算作参数),然后再返回被装饰的函数，多了一层相当于。需要用到<code>partial</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import wraps, partial</span><br><span class=\"line\"></span><br><span class=\"line\">def logged(func=None, level=&apos;debug&apos;, name=None, message=None):</span><br><span class=\"line\">    if func is None:</span><br><span class=\"line\">        reutrn partial(logged, level=level, name=name, message=message)</span><br><span class=\"line\">    logname = name if name else func.__module__</span><br><span class=\"line\">    logmsg = message if message else func.__name__</span><br><span class=\"line\">    </span><br><span class=\"line\">    @wraps(func)</span><br><span class=\"line\">    def wrapper(*args, **kwargs):</span><br><span class=\"line\">        print(level, lgoname, logmsg)</span><br><span class=\"line\">        return func(*args, **kwargs)</span><br><span class=\"line\">    return wrapper</span><br></pre></td></tr></table></figure></p>\n<p>这个装饰器以带参数的形式使用，这里的第一个参数<code>func</code><br>值为<code>None</code>,此时我们用<code>partial</code>反返回了一个其他参数的固定装饰器，这个装饰器与不带参数的简单装饰器一样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> #使用@logged装饰</span><br><span class=\"line\">&gt;&gt;&gt;func(a, b, c)</span><br><span class=\"line\">&gt;&gt;&gt; decorated_func = logged(func)  #可见func不为空</span><br><span class=\"line\">&gt;&gt;&gt; decorated_func(a, b, c)</span><br><span class=\"line\"></span><br><span class=\"line\"> #使用@logged(level=level, name=&apos;example&apos;, message=&apos;message&apos; )</span><br><span class=\"line\"> 相当于</span><br><span class=\"line\">&gt;&gt;&gt; decorator = logged(level=level, name=&apos;example&apos;, message=&apos;message&apos;)</span><br><span class=\"line\">&gt;&gt;&gt; decorated_func = decorator(func)</span><br><span class=\"line\">&gt;&gt;&gt; decorated_fun(a,b,c)</span><br><span class=\"line\"></span><br><span class=\"line\"> #例子如下</span><br><span class=\"line\">@logged</span><br><span class=\"line\">def test(a,b):</span><br><span class=\"line\">   reutrn a+b</span><br><span class=\"line\">test(1,2)</span><br><span class=\"line\">输出: None, __main__ test, 第一个是level默认为None</span><br><span class=\"line\"></span><br><span class=\"line\">@logged(level=&apos;aa&apos;, name=&apos;bb&apos;, message=&apos;cc&apos;)</span><br><span class=\"line\">def test(a,b):</span><br><span class=\"line\">    return a+b</span><br><span class=\"line\">    </span><br><span class=\"line\">test(3,4)</span><br><span class=\"line\">输出: aa,bb,cc</span><br></pre></td></tr></table></figure></p>\n<p>例子<br>设计一个装饰器函数retry,当被装饰的函数抛出指定的异常时候，函数会被重新调用，直到达到最大调用次数才重新抛出指定的异常，使用示例如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@retry(times=10, traced_exception=ValueError,reraised_exception=CustomException)</span><br><span class=\"line\">def test():</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure></p>\n<p>其中，traced_exception为监控的异常，可以为None(默认),异常类，或者一个异常类的列表，如果为None，则监听所有的异常；如果指定了异常类，若函数调用抛出指定的异常，重新调用函数，直至返回成功或者达到最大尝试次数，此时重新抛出原异常(reraised_exception的值为None），或者抛出有reraised_exception指定的异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def retry(times=10, traced_exception=None, reraised_exception=None):</span><br><span class=\"line\">    def decorator(func)</span><br><span class=\"line\">        @wraps</span><br><span class=\"line\">        def wrapper(*args, **kwargs):</span><br><span class=\"line\">            n = times</span><br><span class=\"line\">            traced_all =  traced_exption is None</span><br><span class=\"line\">            traced_spec = traced_exption is not None</span><br><span class=\"line\">            while True:</span><br><span class=\"line\">                try:</span><br><span class=\"line\">                    return func(*args, **kwargs)</span><br><span class=\"line\">                except Exception as e:</span><br><span class=\"line\">                    traced = traced_spec and isinstance(e, traced_exception)    </span><br><span class=\"line\">                    reached_limits = n == 0</span><br><span class=\"line\">                    if not(trace_all or  traced) or reached_limits:</span><br><span class=\"line\">                        if reraise_exception is not None:</span><br><span class=\"line\">                            raise reraise_exception</span><br><span class=\"line\">                        raise</span><br><span class=\"line\">                    n -= 1</span><br><span class=\"line\">        return wrapper</span><br><span class=\"line\">    return decorator</span><br></pre></td></tr></table></figure>"},{"title":"python协程","date":"2019-01-16T12:25:31.000Z","_content":"线程和进程的操作是由程序出发系统接口，最后的执行者是系统，协程的操作则是程序员。\n\n协程存在的意义:对于多线程应用，cpu通过切片的方式来切换线程间的执行，线程切换时需要耗时(保存状态，下次继续)。协程，则只用一个线程，在一个线程中规定代码块的执行顺序。\n\n协程适用的场景:当程序中存在大量不需要cpu的操作时(io)，适用于协程。\n\nevent loop是协程执行的控制点，如果希望执行协程，就需要用到他们。\n\nevent loop提供了如下特性:\n- 注册，执行，取消延时调用(异步函数)\n- 创建用于通信的client与server协议(工具)\n- 创建和别的程序通信的子进程和协议(工具)\n- 把函数送入线程池\n\n<!-- more -->\n```\nimport asyncio\n\nasync def cor1():\n    print('cor1 start')\n    await cor2()\n    print('cor1 end')\n    \nasync def cor2():\n    print('cor2')\n    \nloop = asyncio.get_event_loop() #async启动默认的event loop\nloop.run_until_complete(cor1())  #这个函数是阻塞执行的，直到所有的异步函数执行完成\nloop.close() #关闭event loop\n\n输出:\ncor1 start\ncor2\ncor1 end\n```\n\n#### 1.greenlet\n```\nimport greenlet\n \n \ndef fun1():\n    print(\"12\")\n    gr2.switch()\n    print(\"56\")\n    gr2.switch()\n \ndef fun2():\n    print(\"34\")\n    gr1.switch()\n    print(\"78\")\n \n \ngr1 = greenlet.greenlet(fun1)\ngr2 = greenlet.greenlet(fun2)\ngr1.switch()\n\n输出:\n12\n34\n56\n78\n```\n\n#### 2.gevent\n```\nimport gevent\n \ndef fun1():\n    print(\"www.baidu.com\")   # 第一步\n    gevent.sleep(0)\n    print(\"end the baidu.com\")  # 第三步\n \ndef fun2():\n    print(\"www.zhihu.com\")   # 第二步\n    gevent.sleep(0)\n    print(\"end th zhihu.com\")  # 第四步\n \ngevent.joinall([\n    gevent.spawn(fun1),\n    gevent.spawn(fun2),\n])\n\n输出:\nwww.baidu.com\nwww.zhihu.com\nend the baidu.com\nend th zhihu.com\n```\n\n### io操作\nIO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。\n\n比如打开一个网页，网络io操作，我们需要先发送数据(output)去访问网页的服务器，然后接受网页的数据(input)。\n\nIO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据.\n\n由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法\n\n第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；\n\n另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。\n\n很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/python协程.md","raw":"---\ntitle: python协程\ndate: 2019-01-16 20:25:31\ntags: python\ncategories: python\n---\n线程和进程的操作是由程序出发系统接口，最后的执行者是系统，协程的操作则是程序员。\n\n协程存在的意义:对于多线程应用，cpu通过切片的方式来切换线程间的执行，线程切换时需要耗时(保存状态，下次继续)。协程，则只用一个线程，在一个线程中规定代码块的执行顺序。\n\n协程适用的场景:当程序中存在大量不需要cpu的操作时(io)，适用于协程。\n\nevent loop是协程执行的控制点，如果希望执行协程，就需要用到他们。\n\nevent loop提供了如下特性:\n- 注册，执行，取消延时调用(异步函数)\n- 创建用于通信的client与server协议(工具)\n- 创建和别的程序通信的子进程和协议(工具)\n- 把函数送入线程池\n\n<!-- more -->\n```\nimport asyncio\n\nasync def cor1():\n    print('cor1 start')\n    await cor2()\n    print('cor1 end')\n    \nasync def cor2():\n    print('cor2')\n    \nloop = asyncio.get_event_loop() #async启动默认的event loop\nloop.run_until_complete(cor1())  #这个函数是阻塞执行的，直到所有的异步函数执行完成\nloop.close() #关闭event loop\n\n输出:\ncor1 start\ncor2\ncor1 end\n```\n\n#### 1.greenlet\n```\nimport greenlet\n \n \ndef fun1():\n    print(\"12\")\n    gr2.switch()\n    print(\"56\")\n    gr2.switch()\n \ndef fun2():\n    print(\"34\")\n    gr1.switch()\n    print(\"78\")\n \n \ngr1 = greenlet.greenlet(fun1)\ngr2 = greenlet.greenlet(fun2)\ngr1.switch()\n\n输出:\n12\n34\n56\n78\n```\n\n#### 2.gevent\n```\nimport gevent\n \ndef fun1():\n    print(\"www.baidu.com\")   # 第一步\n    gevent.sleep(0)\n    print(\"end the baidu.com\")  # 第三步\n \ndef fun2():\n    print(\"www.zhihu.com\")   # 第二步\n    gevent.sleep(0)\n    print(\"end th zhihu.com\")  # 第四步\n \ngevent.joinall([\n    gevent.spawn(fun1),\n    gevent.spawn(fun2),\n])\n\n输出:\nwww.baidu.com\nwww.zhihu.com\nend the baidu.com\nend th zhihu.com\n```\n\n### io操作\nIO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。\n\n比如打开一个网页，网络io操作，我们需要先发送数据(output)去访问网页的服务器，然后接受网页的数据(input)。\n\nIO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据.\n\n由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法\n\n第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；\n\n另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。\n\n很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"python协程","published":1,"updated":"2022-05-20T02:24:20.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7l0017lae12tegnvnr","content":"<p>线程和进程的操作是由程序出发系统接口，最后的执行者是系统，协程的操作则是程序员。</p>\n<p>协程存在的意义:对于多线程应用，cpu通过切片的方式来切换线程间的执行，线程切换时需要耗时(保存状态，下次继续)。协程，则只用一个线程，在一个线程中规定代码块的执行顺序。</p>\n<p>协程适用的场景:当程序中存在大量不需要cpu的操作时(io)，适用于协程。</p>\n<p>event loop是协程执行的控制点，如果希望执行协程，就需要用到他们。</p>\n<p>event loop提供了如下特性:</p>\n<ul>\n<li>注册，执行，取消延时调用(异步函数)</li>\n<li>创建用于通信的client与server协议(工具)</li>\n<li>创建和别的程序通信的子进程和协议(工具)</li>\n<li>把函数送入线程池</li>\n</ul>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import asyncio</span><br><span class=\"line\"></span><br><span class=\"line\">async def cor1():</span><br><span class=\"line\">    print(&apos;cor1 start&apos;)</span><br><span class=\"line\">    await cor2()</span><br><span class=\"line\">    print(&apos;cor1 end&apos;)</span><br><span class=\"line\">    </span><br><span class=\"line\">async def cor2():</span><br><span class=\"line\">    print(&apos;cor2&apos;)</span><br><span class=\"line\">    </span><br><span class=\"line\">loop = asyncio.get_event_loop() #async启动默认的event loop</span><br><span class=\"line\">loop.run_until_complete(cor1())  #这个函数是阻塞执行的，直到所有的异步函数执行完成</span><br><span class=\"line\">loop.close() #关闭event loop</span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">cor1 start</span><br><span class=\"line\">cor2</span><br><span class=\"line\">cor1 end</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-greenlet\"><a href=\"#1-greenlet\" class=\"headerlink\" title=\"1.greenlet\"></a>1.greenlet</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import greenlet</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">def fun1():</span><br><span class=\"line\">    print(&quot;12&quot;)</span><br><span class=\"line\">    gr2.switch()</span><br><span class=\"line\">    print(&quot;56&quot;)</span><br><span class=\"line\">    gr2.switch()</span><br><span class=\"line\"> </span><br><span class=\"line\">def fun2():</span><br><span class=\"line\">    print(&quot;34&quot;)</span><br><span class=\"line\">    gr1.switch()</span><br><span class=\"line\">    print(&quot;78&quot;)</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">gr1 = greenlet.greenlet(fun1)</span><br><span class=\"line\">gr2 = greenlet.greenlet(fun2)</span><br><span class=\"line\">gr1.switch()</span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">12</span><br><span class=\"line\">34</span><br><span class=\"line\">56</span><br><span class=\"line\">78</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-gevent\"><a href=\"#2-gevent\" class=\"headerlink\" title=\"2.gevent\"></a>2.gevent</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import gevent</span><br><span class=\"line\"> </span><br><span class=\"line\">def fun1():</span><br><span class=\"line\">    print(&quot;www.baidu.com&quot;)   # 第一步</span><br><span class=\"line\">    gevent.sleep(0)</span><br><span class=\"line\">    print(&quot;end the baidu.com&quot;)  # 第三步</span><br><span class=\"line\"> </span><br><span class=\"line\">def fun2():</span><br><span class=\"line\">    print(&quot;www.zhihu.com&quot;)   # 第二步</span><br><span class=\"line\">    gevent.sleep(0)</span><br><span class=\"line\">    print(&quot;end th zhihu.com&quot;)  # 第四步</span><br><span class=\"line\"> </span><br><span class=\"line\">gevent.joinall([</span><br><span class=\"line\">    gevent.spawn(fun1),</span><br><span class=\"line\">    gevent.spawn(fun2),</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">www.baidu.com</span><br><span class=\"line\">www.zhihu.com</span><br><span class=\"line\">end the baidu.com</span><br><span class=\"line\">end th zhihu.com</span><br></pre></td></tr></table></figure>\n<h3 id=\"io操作\"><a href=\"#io操作\" class=\"headerlink\" title=\"io操作\"></a>io操作</h3><p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。</p>\n<p>比如打开一个网页，网络io操作，我们需要先发送数据(output)去访问网页的服务器，然后接受网页的数据(input)。</p>\n<p>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据.</p>\n<p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法</p>\n<p>第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；</p>\n<p>另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。</p>\n<p>很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。</p>\n","site":{"data":{}},"excerpt":"<p>线程和进程的操作是由程序出发系统接口，最后的执行者是系统，协程的操作则是程序员。</p>\n<p>协程存在的意义:对于多线程应用，cpu通过切片的方式来切换线程间的执行，线程切换时需要耗时(保存状态，下次继续)。协程，则只用一个线程，在一个线程中规定代码块的执行顺序。</p>\n<p>协程适用的场景:当程序中存在大量不需要cpu的操作时(io)，适用于协程。</p>\n<p>event loop是协程执行的控制点，如果希望执行协程，就需要用到他们。</p>\n<p>event loop提供了如下特性:</p>\n<ul>\n<li>注册，执行，取消延时调用(异步函数)</li>\n<li>创建用于通信的client与server协议(工具)</li>\n<li>创建和别的程序通信的子进程和协议(工具)</li>\n<li>把函数送入线程池</li>\n</ul>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import asyncio</span><br><span class=\"line\"></span><br><span class=\"line\">async def cor1():</span><br><span class=\"line\">    print(&apos;cor1 start&apos;)</span><br><span class=\"line\">    await cor2()</span><br><span class=\"line\">    print(&apos;cor1 end&apos;)</span><br><span class=\"line\">    </span><br><span class=\"line\">async def cor2():</span><br><span class=\"line\">    print(&apos;cor2&apos;)</span><br><span class=\"line\">    </span><br><span class=\"line\">loop = asyncio.get_event_loop() #async启动默认的event loop</span><br><span class=\"line\">loop.run_until_complete(cor1())  #这个函数是阻塞执行的，直到所有的异步函数执行完成</span><br><span class=\"line\">loop.close() #关闭event loop</span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">cor1 start</span><br><span class=\"line\">cor2</span><br><span class=\"line\">cor1 end</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-greenlet\"><a href=\"#1-greenlet\" class=\"headerlink\" title=\"1.greenlet\"></a>1.greenlet</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import greenlet</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">def fun1():</span><br><span class=\"line\">    print(&quot;12&quot;)</span><br><span class=\"line\">    gr2.switch()</span><br><span class=\"line\">    print(&quot;56&quot;)</span><br><span class=\"line\">    gr2.switch()</span><br><span class=\"line\"> </span><br><span class=\"line\">def fun2():</span><br><span class=\"line\">    print(&quot;34&quot;)</span><br><span class=\"line\">    gr1.switch()</span><br><span class=\"line\">    print(&quot;78&quot;)</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">gr1 = greenlet.greenlet(fun1)</span><br><span class=\"line\">gr2 = greenlet.greenlet(fun2)</span><br><span class=\"line\">gr1.switch()</span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">12</span><br><span class=\"line\">34</span><br><span class=\"line\">56</span><br><span class=\"line\">78</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-gevent\"><a href=\"#2-gevent\" class=\"headerlink\" title=\"2.gevent\"></a>2.gevent</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import gevent</span><br><span class=\"line\"> </span><br><span class=\"line\">def fun1():</span><br><span class=\"line\">    print(&quot;www.baidu.com&quot;)   # 第一步</span><br><span class=\"line\">    gevent.sleep(0)</span><br><span class=\"line\">    print(&quot;end the baidu.com&quot;)  # 第三步</span><br><span class=\"line\"> </span><br><span class=\"line\">def fun2():</span><br><span class=\"line\">    print(&quot;www.zhihu.com&quot;)   # 第二步</span><br><span class=\"line\">    gevent.sleep(0)</span><br><span class=\"line\">    print(&quot;end th zhihu.com&quot;)  # 第四步</span><br><span class=\"line\"> </span><br><span class=\"line\">gevent.joinall([</span><br><span class=\"line\">    gevent.spawn(fun1),</span><br><span class=\"line\">    gevent.spawn(fun2),</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">www.baidu.com</span><br><span class=\"line\">www.zhihu.com</span><br><span class=\"line\">end the baidu.com</span><br><span class=\"line\">end th zhihu.com</span><br></pre></td></tr></table></figure>\n<h3 id=\"io操作\"><a href=\"#io操作\" class=\"headerlink\" title=\"io操作\"></a>io操作</h3><p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。</p>\n<p>比如打开一个网页，网络io操作，我们需要先发送数据(output)去访问网页的服务器，然后接受网页的数据(input)。</p>\n<p>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据.</p>\n<p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法</p>\n<p>第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；</p>\n<p>另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。</p>\n<p>很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。</p>"},{"title":"python进程","date":"2019-01-16T04:02:16.000Z","_content":"#### 1.multiprocessing模块\n直接从侧面用multiprocess替换线程使用GIL的方式，由于这一点，multiprocessing模块可以让程序员在给定的机器上充分使用cpu，在multiprocessing中，通过multiprocessing对象生成进程，然后调用其start()方法。\n```\nfrom multiprocessing import Process\n\ndef func(name):\n    print('hello', name)\n    \nif __name__ == '__main__':\n    p = Process(target=func, args=('guoguoguo',))\n    p.start()\n    p.join()\n```\n<!-- more -->\n在使用并发设计的时候尽可能的避免数据共享，尤其使用多进程的时候，如果真的需要共享数据，multiprocessing提供了两种方式：\n#### 1.1 multiprocessing，Array，Value\n数据可以使用value或者Array存在共享内存中。\n```\nfrom multiprocessing import Array,Value,Process\n \ndef func(a,b):\n    a.value = 3.333333333333333\n    for i in range(len(b)):\n        print(-b[i])\n        b[i] = -b[i]\n        print('b[i]',b[i])\n \n \nif __name__ == \"__main__\":\n    num = Value('d',0.0)\n    arr = Array('i',range(11))\n \n \n    c = Process(target=func,args=(num,arr))\n    d= Process(target=func,args=(num,arr))\n    c.start()\n    d.start()\n    c.join()\n    d.join()\n \n    print(num.value)\n    for i in arr:\n        print(i)\n```\n\n#### 1.2multiprocessing, Manager\n由manager()返回的manager提供list，dict，Namespace，Lock，RLock，Semmaphore，BoundedSemaphore,Condition,Event,Barrier,Queue,Value,Array类型的支持。\n```\nfrom multiprocessing import Process, Manager\n\ndef func(d, l):\n    d['name'] = 'zhangchunhua'\n    d['age'] = 21\n    d['job'] = 'teacher'\n    l.reverse()\n    \nif __name__ == '__main__':\n    with Manager() as man:\n        d = man.dict()\n        l = man.list(range(10))\n        print(l)\n        p = Process(target=func, args=(d, l))\n        p.start()\n        p.join()\n        print(d)\n        print(l)\n```\n\n#### 2.进程池\nPoll类描述了一个工作进程池，投几种不同的方法让任务卸载工作进程。\n\n进程池内部维护一个进程序列，当使用时去进程池获取一个进程，如果进程池没有可以使用的进程，那么程序就会等待，直到进程池中有可用的进程为止。\n\n我们可以用Poll类来创建一个进程池，展开提交的任务给进程池，例\n```\nfrom multiprocessing import Process,Manager,Pool\n\ndef f1(i):\n    time.sleep(0.5)\n    print(i)\n    return i+100\n\nif __name__ == '__main__':\n    pool = Pool(5)\n    for i in range(1,31):\n        pool.apply(func=f1, args=(i,))\n        \n    pool.close()\n    pool.join()\n\n###apply_async\ndef f1(i):\n    time.sleep(0.5)\n    print(i)\n    return i+100\n\ndef f2(arg):\n    print(arg)\n    \nif __name__ == '__main__':\n    pool = Pool(5)\n    for i in range(1,31):\n        pool.apply_async(func=f1, args=(i,), callback=f2)\n    pool.close()\n    pool.join()\n```\n一个进程池对象可以控制工作进程池那些工作可以被提交，它支持超时和回调的异步结果，有一个类似map的实现。\n\n- processes:使用的工作进程的数量，如果为processess是None，那么使用os.cpu_count()返回的数量。\n- initializer: 如果initializer为None，那么每一个工作进程在开始时候会调用initializer(*initargs)\n- maxtasksperchild:工作进程退出之前可以完成的任务数，完成后用一个新的工作进程来代替原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要pool存在工作进程就一直存活。\n- context: 用在制定工作进程启动时的上下文，一般使用multiprocesssing.Pool()或者一个context对象的Pool方法来创建一个池，两种方法都适当的设置了context。\n\n#### 2.1进程池方法\n- apply(func[, args[,kwds]]):使用arg和kwds参数调用func函数，结果返回前会一直阻塞，由于这个原因，apply_async()更适合并发执行，此外，func函数仅被pool中的一个进程运行。\n- apply_async:(func[,args[,kwds[,callback[,error_callback]]]]):apply()方法的一个变体，会返回一个结果对象。如果callback被指定，那么callback可以接受一个参数然后被调用，调用失败时，则用error_callback。callback硬背立即执行完成，否则处理结果的线程会被阻塞。\n- close():组织更多的任务提交到pool，待任务完成后，工作进程会退出。\n- terminate():不管任务是否完成，立即停止工作进程，在对pool进行垃圾回收的时候，会立即调用terminate\n- join():wait工作线程的退出，在调用join()前，必须调用close()或者terminate()，这样是因为被终止的进程需要被父进程调用wait(join等价于wait)，否则会成为僵尸进程。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/python进程.md","raw":"---\ntitle: python进程\ndate: 2019-01-16 12:02:16\ntags: python\ncategories: python\n---\n#### 1.multiprocessing模块\n直接从侧面用multiprocess替换线程使用GIL的方式，由于这一点，multiprocessing模块可以让程序员在给定的机器上充分使用cpu，在multiprocessing中，通过multiprocessing对象生成进程，然后调用其start()方法。\n```\nfrom multiprocessing import Process\n\ndef func(name):\n    print('hello', name)\n    \nif __name__ == '__main__':\n    p = Process(target=func, args=('guoguoguo',))\n    p.start()\n    p.join()\n```\n<!-- more -->\n在使用并发设计的时候尽可能的避免数据共享，尤其使用多进程的时候，如果真的需要共享数据，multiprocessing提供了两种方式：\n#### 1.1 multiprocessing，Array，Value\n数据可以使用value或者Array存在共享内存中。\n```\nfrom multiprocessing import Array,Value,Process\n \ndef func(a,b):\n    a.value = 3.333333333333333\n    for i in range(len(b)):\n        print(-b[i])\n        b[i] = -b[i]\n        print('b[i]',b[i])\n \n \nif __name__ == \"__main__\":\n    num = Value('d',0.0)\n    arr = Array('i',range(11))\n \n \n    c = Process(target=func,args=(num,arr))\n    d= Process(target=func,args=(num,arr))\n    c.start()\n    d.start()\n    c.join()\n    d.join()\n \n    print(num.value)\n    for i in arr:\n        print(i)\n```\n\n#### 1.2multiprocessing, Manager\n由manager()返回的manager提供list，dict，Namespace，Lock，RLock，Semmaphore，BoundedSemaphore,Condition,Event,Barrier,Queue,Value,Array类型的支持。\n```\nfrom multiprocessing import Process, Manager\n\ndef func(d, l):\n    d['name'] = 'zhangchunhua'\n    d['age'] = 21\n    d['job'] = 'teacher'\n    l.reverse()\n    \nif __name__ == '__main__':\n    with Manager() as man:\n        d = man.dict()\n        l = man.list(range(10))\n        print(l)\n        p = Process(target=func, args=(d, l))\n        p.start()\n        p.join()\n        print(d)\n        print(l)\n```\n\n#### 2.进程池\nPoll类描述了一个工作进程池，投几种不同的方法让任务卸载工作进程。\n\n进程池内部维护一个进程序列，当使用时去进程池获取一个进程，如果进程池没有可以使用的进程，那么程序就会等待，直到进程池中有可用的进程为止。\n\n我们可以用Poll类来创建一个进程池，展开提交的任务给进程池，例\n```\nfrom multiprocessing import Process,Manager,Pool\n\ndef f1(i):\n    time.sleep(0.5)\n    print(i)\n    return i+100\n\nif __name__ == '__main__':\n    pool = Pool(5)\n    for i in range(1,31):\n        pool.apply(func=f1, args=(i,))\n        \n    pool.close()\n    pool.join()\n\n###apply_async\ndef f1(i):\n    time.sleep(0.5)\n    print(i)\n    return i+100\n\ndef f2(arg):\n    print(arg)\n    \nif __name__ == '__main__':\n    pool = Pool(5)\n    for i in range(1,31):\n        pool.apply_async(func=f1, args=(i,), callback=f2)\n    pool.close()\n    pool.join()\n```\n一个进程池对象可以控制工作进程池那些工作可以被提交，它支持超时和回调的异步结果，有一个类似map的实现。\n\n- processes:使用的工作进程的数量，如果为processess是None，那么使用os.cpu_count()返回的数量。\n- initializer: 如果initializer为None，那么每一个工作进程在开始时候会调用initializer(*initargs)\n- maxtasksperchild:工作进程退出之前可以完成的任务数，完成后用一个新的工作进程来代替原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要pool存在工作进程就一直存活。\n- context: 用在制定工作进程启动时的上下文，一般使用multiprocesssing.Pool()或者一个context对象的Pool方法来创建一个池，两种方法都适当的设置了context。\n\n#### 2.1进程池方法\n- apply(func[, args[,kwds]]):使用arg和kwds参数调用func函数，结果返回前会一直阻塞，由于这个原因，apply_async()更适合并发执行，此外，func函数仅被pool中的一个进程运行。\n- apply_async:(func[,args[,kwds[,callback[,error_callback]]]]):apply()方法的一个变体，会返回一个结果对象。如果callback被指定，那么callback可以接受一个参数然后被调用，调用失败时，则用error_callback。callback硬背立即执行完成，否则处理结果的线程会被阻塞。\n- close():组织更多的任务提交到pool，待任务完成后，工作进程会退出。\n- terminate():不管任务是否完成，立即停止工作进程，在对pool进行垃圾回收的时候，会立即调用terminate\n- join():wait工作线程的退出，在调用join()前，必须调用close()或者terminate()，这样是因为被终止的进程需要被父进程调用wait(join等价于wait)，否则会成为僵尸进程。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"python进程","published":1,"updated":"2022-05-20T02:24:20.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7m001clae1w22vpdon","content":"<h4 id=\"1-multiprocessing模块\"><a href=\"#1-multiprocessing模块\" class=\"headerlink\" title=\"1.multiprocessing模块\"></a>1.multiprocessing模块</h4><p>直接从侧面用multiprocess替换线程使用GIL的方式，由于这一点，multiprocessing模块可以让程序员在给定的机器上充分使用cpu，在multiprocessing中，通过multiprocessing对象生成进程，然后调用其start()方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from multiprocessing import Process</span><br><span class=\"line\"></span><br><span class=\"line\">def func(name):</span><br><span class=\"line\">    print(&apos;hello&apos;, name)</span><br><span class=\"line\">    </span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    p = Process(target=func, args=(&apos;guoguoguo&apos;,))</span><br><span class=\"line\">    p.start()</span><br><span class=\"line\">    p.join()</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>在使用并发设计的时候尽可能的避免数据共享，尤其使用多进程的时候，如果真的需要共享数据，multiprocessing提供了两种方式：</p>\n<h4 id=\"1-1-multiprocessing，Array，Value\"><a href=\"#1-1-multiprocessing，Array，Value\" class=\"headerlink\" title=\"1.1 multiprocessing，Array，Value\"></a>1.1 multiprocessing，Array，Value</h4><p>数据可以使用value或者Array存在共享内存中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from multiprocessing import Array,Value,Process</span><br><span class=\"line\"> </span><br><span class=\"line\">def func(a,b):</span><br><span class=\"line\">    a.value = 3.333333333333333</span><br><span class=\"line\">    for i in range(len(b)):</span><br><span class=\"line\">        print(-b[i])</span><br><span class=\"line\">        b[i] = -b[i]</span><br><span class=\"line\">        print(&apos;b[i]&apos;,b[i])</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    num = Value(&apos;d&apos;,0.0)</span><br><span class=\"line\">    arr = Array(&apos;i&apos;,range(11))</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    c = Process(target=func,args=(num,arr))</span><br><span class=\"line\">    d= Process(target=func,args=(num,arr))</span><br><span class=\"line\">    c.start()</span><br><span class=\"line\">    d.start()</span><br><span class=\"line\">    c.join()</span><br><span class=\"line\">    d.join()</span><br><span class=\"line\"> </span><br><span class=\"line\">    print(num.value)</span><br><span class=\"line\">    for i in arr:</span><br><span class=\"line\">        print(i)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-2multiprocessing-Manager\"><a href=\"#1-2multiprocessing-Manager\" class=\"headerlink\" title=\"1.2multiprocessing, Manager\"></a>1.2multiprocessing, Manager</h4><p>由manager()返回的manager提供list，dict，Namespace，Lock，RLock，Semmaphore，BoundedSemaphore,Condition,Event,Barrier,Queue,Value,Array类型的支持。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from multiprocessing import Process, Manager</span><br><span class=\"line\"></span><br><span class=\"line\">def func(d, l):</span><br><span class=\"line\">    d[&apos;name&apos;] = &apos;zhangchunhua&apos;</span><br><span class=\"line\">    d[&apos;age&apos;] = 21</span><br><span class=\"line\">    d[&apos;job&apos;] = &apos;teacher&apos;</span><br><span class=\"line\">    l.reverse()</span><br><span class=\"line\">    </span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    with Manager() as man:</span><br><span class=\"line\">        d = man.dict()</span><br><span class=\"line\">        l = man.list(range(10))</span><br><span class=\"line\">        print(l)</span><br><span class=\"line\">        p = Process(target=func, args=(d, l))</span><br><span class=\"line\">        p.start()</span><br><span class=\"line\">        p.join()</span><br><span class=\"line\">        print(d)</span><br><span class=\"line\">        print(l)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-进程池\"><a href=\"#2-进程池\" class=\"headerlink\" title=\"2.进程池\"></a>2.进程池</h4><p>Poll类描述了一个工作进程池，投几种不同的方法让任务卸载工作进程。</p>\n<p>进程池内部维护一个进程序列，当使用时去进程池获取一个进程，如果进程池没有可以使用的进程，那么程序就会等待，直到进程池中有可用的进程为止。</p>\n<p>我们可以用Poll类来创建一个进程池，展开提交的任务给进程池，例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from multiprocessing import Process,Manager,Pool</span><br><span class=\"line\"></span><br><span class=\"line\">def f1(i):</span><br><span class=\"line\">    time.sleep(0.5)</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">    return i+100</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    pool = Pool(5)</span><br><span class=\"line\">    for i in range(1,31):</span><br><span class=\"line\">        pool.apply(func=f1, args=(i,))</span><br><span class=\"line\">        </span><br><span class=\"line\">    pool.close()</span><br><span class=\"line\">    pool.join()</span><br><span class=\"line\"></span><br><span class=\"line\">###apply_async</span><br><span class=\"line\">def f1(i):</span><br><span class=\"line\">    time.sleep(0.5)</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">    return i+100</span><br><span class=\"line\"></span><br><span class=\"line\">def f2(arg):</span><br><span class=\"line\">    print(arg)</span><br><span class=\"line\">    </span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    pool = Pool(5)</span><br><span class=\"line\">    for i in range(1,31):</span><br><span class=\"line\">        pool.apply_async(func=f1, args=(i,), callback=f2)</span><br><span class=\"line\">    pool.close()</span><br><span class=\"line\">    pool.join()</span><br></pre></td></tr></table></figure></p>\n<p>一个进程池对象可以控制工作进程池那些工作可以被提交，它支持超时和回调的异步结果，有一个类似map的实现。</p>\n<ul>\n<li>processes:使用的工作进程的数量，如果为processess是None，那么使用os.cpu_count()返回的数量。</li>\n<li>initializer: 如果initializer为None，那么每一个工作进程在开始时候会调用initializer(*initargs)</li>\n<li>maxtasksperchild:工作进程退出之前可以完成的任务数，完成后用一个新的工作进程来代替原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要pool存在工作进程就一直存活。</li>\n<li>context: 用在制定工作进程启动时的上下文，一般使用multiprocesssing.Pool()或者一个context对象的Pool方法来创建一个池，两种方法都适当的设置了context。</li>\n</ul>\n<h4 id=\"2-1进程池方法\"><a href=\"#2-1进程池方法\" class=\"headerlink\" title=\"2.1进程池方法\"></a>2.1进程池方法</h4><ul>\n<li>apply(func[, args[,kwds]]):使用arg和kwds参数调用func函数，结果返回前会一直阻塞，由于这个原因，apply_async()更适合并发执行，此外，func函数仅被pool中的一个进程运行。</li>\n<li>apply_async:(func[,args[,kwds[,callback[,error_callback]]]]):apply()方法的一个变体，会返回一个结果对象。如果callback被指定，那么callback可以接受一个参数然后被调用，调用失败时，则用error_callback。callback硬背立即执行完成，否则处理结果的线程会被阻塞。</li>\n<li>close():组织更多的任务提交到pool，待任务完成后，工作进程会退出。</li>\n<li>terminate():不管任务是否完成，立即停止工作进程，在对pool进行垃圾回收的时候，会立即调用terminate</li>\n<li>join():wait工作线程的退出，在调用join()前，必须调用close()或者terminate()，这样是因为被终止的进程需要被父进程调用wait(join等价于wait)，否则会成为僵尸进程。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-multiprocessing模块\"><a href=\"#1-multiprocessing模块\" class=\"headerlink\" title=\"1.multiprocessing模块\"></a>1.multiprocessing模块</h4><p>直接从侧面用multiprocess替换线程使用GIL的方式，由于这一点，multiprocessing模块可以让程序员在给定的机器上充分使用cpu，在multiprocessing中，通过multiprocessing对象生成进程，然后调用其start()方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from multiprocessing import Process</span><br><span class=\"line\"></span><br><span class=\"line\">def func(name):</span><br><span class=\"line\">    print(&apos;hello&apos;, name)</span><br><span class=\"line\">    </span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    p = Process(target=func, args=(&apos;guoguoguo&apos;,))</span><br><span class=\"line\">    p.start()</span><br><span class=\"line\">    p.join()</span><br></pre></td></tr></table></figure></p>","more":"<p>在使用并发设计的时候尽可能的避免数据共享，尤其使用多进程的时候，如果真的需要共享数据，multiprocessing提供了两种方式：</p>\n<h4 id=\"1-1-multiprocessing，Array，Value\"><a href=\"#1-1-multiprocessing，Array，Value\" class=\"headerlink\" title=\"1.1 multiprocessing，Array，Value\"></a>1.1 multiprocessing，Array，Value</h4><p>数据可以使用value或者Array存在共享内存中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from multiprocessing import Array,Value,Process</span><br><span class=\"line\"> </span><br><span class=\"line\">def func(a,b):</span><br><span class=\"line\">    a.value = 3.333333333333333</span><br><span class=\"line\">    for i in range(len(b)):</span><br><span class=\"line\">        print(-b[i])</span><br><span class=\"line\">        b[i] = -b[i]</span><br><span class=\"line\">        print(&apos;b[i]&apos;,b[i])</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    num = Value(&apos;d&apos;,0.0)</span><br><span class=\"line\">    arr = Array(&apos;i&apos;,range(11))</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    c = Process(target=func,args=(num,arr))</span><br><span class=\"line\">    d= Process(target=func,args=(num,arr))</span><br><span class=\"line\">    c.start()</span><br><span class=\"line\">    d.start()</span><br><span class=\"line\">    c.join()</span><br><span class=\"line\">    d.join()</span><br><span class=\"line\"> </span><br><span class=\"line\">    print(num.value)</span><br><span class=\"line\">    for i in arr:</span><br><span class=\"line\">        print(i)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-2multiprocessing-Manager\"><a href=\"#1-2multiprocessing-Manager\" class=\"headerlink\" title=\"1.2multiprocessing, Manager\"></a>1.2multiprocessing, Manager</h4><p>由manager()返回的manager提供list，dict，Namespace，Lock，RLock，Semmaphore，BoundedSemaphore,Condition,Event,Barrier,Queue,Value,Array类型的支持。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from multiprocessing import Process, Manager</span><br><span class=\"line\"></span><br><span class=\"line\">def func(d, l):</span><br><span class=\"line\">    d[&apos;name&apos;] = &apos;zhangchunhua&apos;</span><br><span class=\"line\">    d[&apos;age&apos;] = 21</span><br><span class=\"line\">    d[&apos;job&apos;] = &apos;teacher&apos;</span><br><span class=\"line\">    l.reverse()</span><br><span class=\"line\">    </span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    with Manager() as man:</span><br><span class=\"line\">        d = man.dict()</span><br><span class=\"line\">        l = man.list(range(10))</span><br><span class=\"line\">        print(l)</span><br><span class=\"line\">        p = Process(target=func, args=(d, l))</span><br><span class=\"line\">        p.start()</span><br><span class=\"line\">        p.join()</span><br><span class=\"line\">        print(d)</span><br><span class=\"line\">        print(l)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-进程池\"><a href=\"#2-进程池\" class=\"headerlink\" title=\"2.进程池\"></a>2.进程池</h4><p>Poll类描述了一个工作进程池，投几种不同的方法让任务卸载工作进程。</p>\n<p>进程池内部维护一个进程序列，当使用时去进程池获取一个进程，如果进程池没有可以使用的进程，那么程序就会等待，直到进程池中有可用的进程为止。</p>\n<p>我们可以用Poll类来创建一个进程池，展开提交的任务给进程池，例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from multiprocessing import Process,Manager,Pool</span><br><span class=\"line\"></span><br><span class=\"line\">def f1(i):</span><br><span class=\"line\">    time.sleep(0.5)</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">    return i+100</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    pool = Pool(5)</span><br><span class=\"line\">    for i in range(1,31):</span><br><span class=\"line\">        pool.apply(func=f1, args=(i,))</span><br><span class=\"line\">        </span><br><span class=\"line\">    pool.close()</span><br><span class=\"line\">    pool.join()</span><br><span class=\"line\"></span><br><span class=\"line\">###apply_async</span><br><span class=\"line\">def f1(i):</span><br><span class=\"line\">    time.sleep(0.5)</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">    return i+100</span><br><span class=\"line\"></span><br><span class=\"line\">def f2(arg):</span><br><span class=\"line\">    print(arg)</span><br><span class=\"line\">    </span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    pool = Pool(5)</span><br><span class=\"line\">    for i in range(1,31):</span><br><span class=\"line\">        pool.apply_async(func=f1, args=(i,), callback=f2)</span><br><span class=\"line\">    pool.close()</span><br><span class=\"line\">    pool.join()</span><br></pre></td></tr></table></figure></p>\n<p>一个进程池对象可以控制工作进程池那些工作可以被提交，它支持超时和回调的异步结果，有一个类似map的实现。</p>\n<ul>\n<li>processes:使用的工作进程的数量，如果为processess是None，那么使用os.cpu_count()返回的数量。</li>\n<li>initializer: 如果initializer为None，那么每一个工作进程在开始时候会调用initializer(*initargs)</li>\n<li>maxtasksperchild:工作进程退出之前可以完成的任务数，完成后用一个新的工作进程来代替原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要pool存在工作进程就一直存活。</li>\n<li>context: 用在制定工作进程启动时的上下文，一般使用multiprocesssing.Pool()或者一个context对象的Pool方法来创建一个池，两种方法都适当的设置了context。</li>\n</ul>\n<h4 id=\"2-1进程池方法\"><a href=\"#2-1进程池方法\" class=\"headerlink\" title=\"2.1进程池方法\"></a>2.1进程池方法</h4><ul>\n<li>apply(func[, args[,kwds]]):使用arg和kwds参数调用func函数，结果返回前会一直阻塞，由于这个原因，apply_async()更适合并发执行，此外，func函数仅被pool中的一个进程运行。</li>\n<li>apply_async:(func[,args[,kwds[,callback[,error_callback]]]]):apply()方法的一个变体，会返回一个结果对象。如果callback被指定，那么callback可以接受一个参数然后被调用，调用失败时，则用error_callback。callback硬背立即执行完成，否则处理结果的线程会被阻塞。</li>\n<li>close():组织更多的任务提交到pool，待任务完成后，工作进程会退出。</li>\n<li>terminate():不管任务是否完成，立即停止工作进程，在对pool进行垃圾回收的时候，会立即调用terminate</li>\n<li>join():wait工作线程的退出，在调用join()前，必须调用close()或者terminate()，这样是因为被终止的进程需要被父进程调用wait(join等价于wait)，否则会成为僵尸进程。</li>\n</ul>"},{"title":"python线程","date":"2019-01-16T04:01:00.000Z","_content":"### 进程与线程的关系\n\n线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时，该进程所产生的所有线程都会被强制清除并且退出。。线程可与属于同一进程的其他线程共享进程的全部资源。\n\n\n### python的线程\n\nThreading用于提供线程相关的操作，线程是应用程序中的最小单元。\n\n#### 1.threading模块\n\nthreading模块是对thread模块的二次封装，提供了更方便的api来处理线程。\n```\nimport threading\nimport time\ndef work(num):\n    time.sleep(1)\n    print(\"the number is {}\".format(num))\n   #return\n\nfor i in range(20):\n    t = threading.Thread(target=work, args=(i,), name=\"t{}\".format(i))\n    t.start()\n```\n<!-- more -->\n这里创建了20个线程，然后控制器就交给了cpu，cpu根据指定算法进行调度，分片执行命令。    \n方法说明:    \n1.t.start():激活线程    \n2.t.getName():获取线程名称    \n3.t.setName():设置线程名称    \n4.t.name:获取或者设置线程名称    \n5.t.is_alive():判断线程是否为激活状态    \n6.t.isAlive():判断线程是否为激活状态    \n7.t.setDaemon():设置为后台线程或者前台线程(默认为False),通过设定一个布尔值设置线程是否为守护线程，必须在start()方法之后才可以使用。如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕，无论后台线程成功与否，均停止。如果是前台线程，主线程执行完毕，前台线程也在执行，主线程执行完毕后，等待前台线程也执行完毕后，程序停止。    \n8.t.isDaemon():判断是否为守护线程    \n9.t.ident:获取线程的标识符，线程标识符是一个非零整数，只有在调用了start()方法之后属性才有效,否则返回None。    \n10.t.join():逐个执行每个线程，执行完毕后往下执行，该方法使得多线程无意义。    \n11.t.run():线程被cpu调度后自动执行run方法。\n\n#### 2.线程锁threading.RLock和threading.Lock\n\n由于线程之间是随机调度，并且每个线程可能执行n条执行后，cpu接着执行其他线程，为了保证数据的准确性，引入了锁的概念，可能出现的问题如下:    \n假如列表A的所有元素都为0,当一个线程从前向后打印所有元素，另一个线程从后向前修改列表的元素为1，那么输出的时候，列表的元素会一部分为0，一部分为1，导致了数据的不一致。锁的出现解决了这个问题。    \n```\nimport threading\nimport time\n\nglobal_num = 0\nlock = threading.RLock()\n\ndef Func():\n    lock.acquire()    #获得锁\n    global global_num\n    global_num += 1\n    time.sleep(1)\n    print(global_num)\n    lock.release()    #释放锁\n\nfor i in range(10):\n    t = threading.Thread(target=Func,)\n    t.start()\n```\n#### 3.thrading.RLock和thrading.Lock\nRLock允许在同一线程被多次require，而Lock却不允许，如果使用RLock，那么acquire和release必须成对出现。\n```\nimport threading\nlock = threading.Lock()\nlock.require()\nlock.acquire()  ##产生了死锁\nlock.release()\nloack.release()\n\nrlock = threading.RLock()\nrlock.require()\nrlock.require() #在同一线程内，程序不会堵塞\nrlock.release()\nrlock.release()\n```\n\n#### 4.threding.Event\n\npython线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法:set,wait,clear。    \n事件处理的机制:全局定义了一个`Flag`,如果`Flag`的值为False，那么当程序执行event.wait方法就会堵塞，如果`Flag`为True,那么event.wait方法时不会堵塞。\n\n- clear: 将`Flag`设置为False\n- set: 将`Flag`设置为True\n- Event.isSet():判断标识位是否为True\n```\nimport threading\n\ndef do(event):\n    print('start')\n    print('event:',event.isSet())\n    event.wait()\n    print('execute')\n    \nevent_obj = threading.Event()\nfor i in range(10):\n    #event_obj.set()\n    t = threading.Thread(target=do, args=(event_obj,))\n    t.start()\n    \nevent_obj.clear()\ninp = input(\"input:\")\nif inp == 'true':\n    event_obj.set()\n```\n当线程执行的时候，如果Flag为False，则线程会阻塞，若为True，线程不会阻塞，提供了本地和远程的并发性。\n\n#### 5.threading.Condition\n\n一个condition变量总是与某些类型的锁相关联，这个可以使用默认的情况创建一个，当几个condition变量必须共享变量和同一个锁的时候是很有用的，锁是condition对象的一部分，没有必要分别跟踪.    \n\ncondition变量服从上下文管理协议，with语句封闭之前可以取得和锁的联系，acquire()和release()会调用与锁相关的方法。   \n\n其他和锁关联的方法必须被调用,wait()方法会释放锁，当另一个线程使用notify()或者notify_all()唤醒它之前会一直阻塞，一旦被唤醒，wait()会重新获得 锁并返回。\n\nCondition实现了一个condition变量，这个condition变量\n允许一个或者多个线程等待，直到他们被另一个线程通知。如果lock参数，被给定一个非空的值，那么他必须是一个lock或者Rlock对象，他用来做底层锁，否则会创建一个新的Rlock对象，用来做底层锁。\n\n- wait(timeout=None):等待通知，或者等待设定的超时事件，当调用这个wait()方法时，如果调用他的线程没有得到锁，会抛出RuntimeError异常。wait()释放锁以后，在调用相同条件下的另一个进程用notify()或者notify_all()叫醒之前，会一直阻塞，wait()可指定超时时间。\n\n如果有等待的线程，notify()方法会唤醒一个在等待的condition变量的线程，notify_all()则会唤醒所有在等待的condition变量的线程。\n```\nimport threading\nimport time\n\ndef consumer(cond):\n    with cond:\n        print(\"consumer before wait\")\n        cond.wait()\n        print(\"consumer after wait\")\n\ndef producter(cond):\n    with cond:\n        print(\"producter beofre notifyAll\")\n        cond.notifyAll()\n        print(\"producter after notifyAll\")\n        \ncondition = threading.Condition()\nc1 = threading.Thread(name='c1', target=consumer, args=(condition,))\nc2 = threading.Thread(name='c2', target=consumer, args=(condition,))\np1 = threading.Thread(name='p1', target=producter, args=(condition,))\n\nc1.start()\ntime.sleep(2)\nc2.start()\ntime.sleep(2)\np1.start()\n\n输出:\nconsumer before wait\nconsumer before wait\nproducter beofre notifyAll\nproducter after notifyAll\nconsumer after wait\nconsumer after wait\n```\n\n#### 6.queue模块\n\nQueue就是队列，他是线程安全的，举例来说，我们去麦当劳吃饭，前台负责把做好的饭卖给顾客，顾客去前台领取做好的饭，这里的前台相当于我们的队列，厨师做好饭通过前台传递给顾客，所谓单项队列。这个模型也叫生产者-消费者模型。\n```\nimport queue\nimport threading\nimport time\n\nclass Threadingpool():\n    def __init__(self, max_num=10):\n        self.queue = queue.Queue(max_num)\n        for i in range(max_num):\n            self.queue.put(threading.Thread)\n    \n    def getThreading(self):\n        return self.queue.get()\n    \n    def addThreading(self):\n        return self.queue.put(threading.Thread)\n    \ndef func(p, i):\n    time.sleep(1)\n    print(i)\n    p.addThreading()\n    \nif __name__ == '__main__':\n    p = Threadingpool()\n    for i in range(11):\n        thread = p.getThreading()\n        print(thread)\n        t = thread(target= func, args=(p, i))\n        t.start()\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/python线程.md","raw":"---\ntitle: python线程\ndate: 2019-01-16 12:01:00\ntags: python\ncategories: python\n---\n### 进程与线程的关系\n\n线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时，该进程所产生的所有线程都会被强制清除并且退出。。线程可与属于同一进程的其他线程共享进程的全部资源。\n\n\n### python的线程\n\nThreading用于提供线程相关的操作，线程是应用程序中的最小单元。\n\n#### 1.threading模块\n\nthreading模块是对thread模块的二次封装，提供了更方便的api来处理线程。\n```\nimport threading\nimport time\ndef work(num):\n    time.sleep(1)\n    print(\"the number is {}\".format(num))\n   #return\n\nfor i in range(20):\n    t = threading.Thread(target=work, args=(i,), name=\"t{}\".format(i))\n    t.start()\n```\n<!-- more -->\n这里创建了20个线程，然后控制器就交给了cpu，cpu根据指定算法进行调度，分片执行命令。    \n方法说明:    \n1.t.start():激活线程    \n2.t.getName():获取线程名称    \n3.t.setName():设置线程名称    \n4.t.name:获取或者设置线程名称    \n5.t.is_alive():判断线程是否为激活状态    \n6.t.isAlive():判断线程是否为激活状态    \n7.t.setDaemon():设置为后台线程或者前台线程(默认为False),通过设定一个布尔值设置线程是否为守护线程，必须在start()方法之后才可以使用。如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕，无论后台线程成功与否，均停止。如果是前台线程，主线程执行完毕，前台线程也在执行，主线程执行完毕后，等待前台线程也执行完毕后，程序停止。    \n8.t.isDaemon():判断是否为守护线程    \n9.t.ident:获取线程的标识符，线程标识符是一个非零整数，只有在调用了start()方法之后属性才有效,否则返回None。    \n10.t.join():逐个执行每个线程，执行完毕后往下执行，该方法使得多线程无意义。    \n11.t.run():线程被cpu调度后自动执行run方法。\n\n#### 2.线程锁threading.RLock和threading.Lock\n\n由于线程之间是随机调度，并且每个线程可能执行n条执行后，cpu接着执行其他线程，为了保证数据的准确性，引入了锁的概念，可能出现的问题如下:    \n假如列表A的所有元素都为0,当一个线程从前向后打印所有元素，另一个线程从后向前修改列表的元素为1，那么输出的时候，列表的元素会一部分为0，一部分为1，导致了数据的不一致。锁的出现解决了这个问题。    \n```\nimport threading\nimport time\n\nglobal_num = 0\nlock = threading.RLock()\n\ndef Func():\n    lock.acquire()    #获得锁\n    global global_num\n    global_num += 1\n    time.sleep(1)\n    print(global_num)\n    lock.release()    #释放锁\n\nfor i in range(10):\n    t = threading.Thread(target=Func,)\n    t.start()\n```\n#### 3.thrading.RLock和thrading.Lock\nRLock允许在同一线程被多次require，而Lock却不允许，如果使用RLock，那么acquire和release必须成对出现。\n```\nimport threading\nlock = threading.Lock()\nlock.require()\nlock.acquire()  ##产生了死锁\nlock.release()\nloack.release()\n\nrlock = threading.RLock()\nrlock.require()\nrlock.require() #在同一线程内，程序不会堵塞\nrlock.release()\nrlock.release()\n```\n\n#### 4.threding.Event\n\npython线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法:set,wait,clear。    \n事件处理的机制:全局定义了一个`Flag`,如果`Flag`的值为False，那么当程序执行event.wait方法就会堵塞，如果`Flag`为True,那么event.wait方法时不会堵塞。\n\n- clear: 将`Flag`设置为False\n- set: 将`Flag`设置为True\n- Event.isSet():判断标识位是否为True\n```\nimport threading\n\ndef do(event):\n    print('start')\n    print('event:',event.isSet())\n    event.wait()\n    print('execute')\n    \nevent_obj = threading.Event()\nfor i in range(10):\n    #event_obj.set()\n    t = threading.Thread(target=do, args=(event_obj,))\n    t.start()\n    \nevent_obj.clear()\ninp = input(\"input:\")\nif inp == 'true':\n    event_obj.set()\n```\n当线程执行的时候，如果Flag为False，则线程会阻塞，若为True，线程不会阻塞，提供了本地和远程的并发性。\n\n#### 5.threading.Condition\n\n一个condition变量总是与某些类型的锁相关联，这个可以使用默认的情况创建一个，当几个condition变量必须共享变量和同一个锁的时候是很有用的，锁是condition对象的一部分，没有必要分别跟踪.    \n\ncondition变量服从上下文管理协议，with语句封闭之前可以取得和锁的联系，acquire()和release()会调用与锁相关的方法。   \n\n其他和锁关联的方法必须被调用,wait()方法会释放锁，当另一个线程使用notify()或者notify_all()唤醒它之前会一直阻塞，一旦被唤醒，wait()会重新获得 锁并返回。\n\nCondition实现了一个condition变量，这个condition变量\n允许一个或者多个线程等待，直到他们被另一个线程通知。如果lock参数，被给定一个非空的值，那么他必须是一个lock或者Rlock对象，他用来做底层锁，否则会创建一个新的Rlock对象，用来做底层锁。\n\n- wait(timeout=None):等待通知，或者等待设定的超时事件，当调用这个wait()方法时，如果调用他的线程没有得到锁，会抛出RuntimeError异常。wait()释放锁以后，在调用相同条件下的另一个进程用notify()或者notify_all()叫醒之前，会一直阻塞，wait()可指定超时时间。\n\n如果有等待的线程，notify()方法会唤醒一个在等待的condition变量的线程，notify_all()则会唤醒所有在等待的condition变量的线程。\n```\nimport threading\nimport time\n\ndef consumer(cond):\n    with cond:\n        print(\"consumer before wait\")\n        cond.wait()\n        print(\"consumer after wait\")\n\ndef producter(cond):\n    with cond:\n        print(\"producter beofre notifyAll\")\n        cond.notifyAll()\n        print(\"producter after notifyAll\")\n        \ncondition = threading.Condition()\nc1 = threading.Thread(name='c1', target=consumer, args=(condition,))\nc2 = threading.Thread(name='c2', target=consumer, args=(condition,))\np1 = threading.Thread(name='p1', target=producter, args=(condition,))\n\nc1.start()\ntime.sleep(2)\nc2.start()\ntime.sleep(2)\np1.start()\n\n输出:\nconsumer before wait\nconsumer before wait\nproducter beofre notifyAll\nproducter after notifyAll\nconsumer after wait\nconsumer after wait\n```\n\n#### 6.queue模块\n\nQueue就是队列，他是线程安全的，举例来说，我们去麦当劳吃饭，前台负责把做好的饭卖给顾客，顾客去前台领取做好的饭，这里的前台相当于我们的队列，厨师做好饭通过前台传递给顾客，所谓单项队列。这个模型也叫生产者-消费者模型。\n```\nimport queue\nimport threading\nimport time\n\nclass Threadingpool():\n    def __init__(self, max_num=10):\n        self.queue = queue.Queue(max_num)\n        for i in range(max_num):\n            self.queue.put(threading.Thread)\n    \n    def getThreading(self):\n        return self.queue.get()\n    \n    def addThreading(self):\n        return self.queue.put(threading.Thread)\n    \ndef func(p, i):\n    time.sleep(1)\n    print(i)\n    p.addThreading()\n    \nif __name__ == '__main__':\n    p = Threadingpool()\n    for i in range(11):\n        thread = p.getThreading()\n        print(thread)\n        t = thread(target= func, args=(p, i))\n        t.start()\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"python线程","published":1,"updated":"2022-05-20T02:24:20.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7n001flae1b8hmqk01","content":"<h3 id=\"进程与线程的关系\"><a href=\"#进程与线程的关系\" class=\"headerlink\" title=\"进程与线程的关系\"></a>进程与线程的关系</h3><p>线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时，该进程所产生的所有线程都会被强制清除并且退出。。线程可与属于同一进程的其他线程共享进程的全部资源。</p>\n<h3 id=\"python的线程\"><a href=\"#python的线程\" class=\"headerlink\" title=\"python的线程\"></a>python的线程</h3><p>Threading用于提供线程相关的操作，线程是应用程序中的最小单元。</p>\n<h4 id=\"1-threading模块\"><a href=\"#1-threading模块\" class=\"headerlink\" title=\"1.threading模块\"></a>1.threading模块</h4><p>threading模块是对thread模块的二次封装，提供了更方便的api来处理线程。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\">import time</span><br><span class=\"line\">def work(num):</span><br><span class=\"line\">    time.sleep(1)</span><br><span class=\"line\">    print(&quot;the number is &#123;&#125;&quot;.format(num))</span><br><span class=\"line\">   #return</span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(20):</span><br><span class=\"line\">    t = threading.Thread(target=work, args=(i,), name=&quot;t&#123;&#125;&quot;.format(i))</span><br><span class=\"line\">    t.start()</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>这里创建了20个线程，然后控制器就交给了cpu，cpu根据指定算法进行调度，分片执行命令。<br>方法说明:<br>1.t.start():激活线程<br>2.t.getName():获取线程名称<br>3.t.setName():设置线程名称<br>4.t.name:获取或者设置线程名称<br>5.t.is_alive():判断线程是否为激活状态<br>6.t.isAlive():判断线程是否为激活状态<br>7.t.setDaemon():设置为后台线程或者前台线程(默认为False),通过设定一个布尔值设置线程是否为守护线程，必须在start()方法之后才可以使用。如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕，无论后台线程成功与否，均停止。如果是前台线程，主线程执行完毕，前台线程也在执行，主线程执行完毕后，等待前台线程也执行完毕后，程序停止。<br>8.t.isDaemon():判断是否为守护线程<br>9.t.ident:获取线程的标识符，线程标识符是一个非零整数，只有在调用了start()方法之后属性才有效,否则返回None。<br>10.t.join():逐个执行每个线程，执行完毕后往下执行，该方法使得多线程无意义。<br>11.t.run():线程被cpu调度后自动执行run方法。</p>\n<h4 id=\"2-线程锁threading-RLock和threading-Lock\"><a href=\"#2-线程锁threading-RLock和threading-Lock\" class=\"headerlink\" title=\"2.线程锁threading.RLock和threading.Lock\"></a>2.线程锁threading.RLock和threading.Lock</h4><p>由于线程之间是随机调度，并且每个线程可能执行n条执行后，cpu接着执行其他线程，为了保证数据的准确性，引入了锁的概念，可能出现的问题如下:<br>假如列表A的所有元素都为0,当一个线程从前向后打印所有元素，另一个线程从后向前修改列表的元素为1，那么输出的时候，列表的元素会一部分为0，一部分为1，导致了数据的不一致。锁的出现解决了这个问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\">global_num = 0</span><br><span class=\"line\">lock = threading.RLock()</span><br><span class=\"line\"></span><br><span class=\"line\">def Func():</span><br><span class=\"line\">    lock.acquire()    #获得锁</span><br><span class=\"line\">    global global_num</span><br><span class=\"line\">    global_num += 1</span><br><span class=\"line\">    time.sleep(1)</span><br><span class=\"line\">    print(global_num)</span><br><span class=\"line\">    lock.release()    #释放锁</span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(10):</span><br><span class=\"line\">    t = threading.Thread(target=Func,)</span><br><span class=\"line\">    t.start()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-thrading-RLock和thrading-Lock\"><a href=\"#3-thrading-RLock和thrading-Lock\" class=\"headerlink\" title=\"3.thrading.RLock和thrading.Lock\"></a>3.thrading.RLock和thrading.Lock</h4><p>RLock允许在同一线程被多次require，而Lock却不允许，如果使用RLock，那么acquire和release必须成对出现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\">lock = threading.Lock()</span><br><span class=\"line\">lock.require()</span><br><span class=\"line\">lock.acquire()  ##产生了死锁</span><br><span class=\"line\">lock.release()</span><br><span class=\"line\">loack.release()</span><br><span class=\"line\"></span><br><span class=\"line\">rlock = threading.RLock()</span><br><span class=\"line\">rlock.require()</span><br><span class=\"line\">rlock.require() #在同一线程内，程序不会堵塞</span><br><span class=\"line\">rlock.release()</span><br><span class=\"line\">rlock.release()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-threding-Event\"><a href=\"#4-threding-Event\" class=\"headerlink\" title=\"4.threding.Event\"></a>4.threding.Event</h4><p>python线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法:set,wait,clear。<br>事件处理的机制:全局定义了一个<code>Flag</code>,如果<code>Flag</code>的值为False，那么当程序执行event.wait方法就会堵塞，如果<code>Flag</code>为True,那么event.wait方法时不会堵塞。</p>\n<ul>\n<li>clear: 将<code>Flag</code>设置为False</li>\n<li>set: 将<code>Flag</code>设置为True</li>\n<li>Event.isSet():判断标识位是否为True<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\"></span><br><span class=\"line\">def do(event):</span><br><span class=\"line\">    print(&apos;start&apos;)</span><br><span class=\"line\">    print(&apos;event:&apos;,event.isSet())</span><br><span class=\"line\">    event.wait()</span><br><span class=\"line\">    print(&apos;execute&apos;)</span><br><span class=\"line\">    </span><br><span class=\"line\">event_obj = threading.Event()</span><br><span class=\"line\">for i in range(10):</span><br><span class=\"line\">    #event_obj.set()</span><br><span class=\"line\">    t = threading.Thread(target=do, args=(event_obj,))</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\">    </span><br><span class=\"line\">event_obj.clear()</span><br><span class=\"line\">inp = input(&quot;input:&quot;)</span><br><span class=\"line\">if inp == &apos;true&apos;:</span><br><span class=\"line\">    event_obj.set()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当线程执行的时候，如果Flag为False，则线程会阻塞，若为True，线程不会阻塞，提供了本地和远程的并发性。</p>\n<h4 id=\"5-threading-Condition\"><a href=\"#5-threading-Condition\" class=\"headerlink\" title=\"5.threading.Condition\"></a>5.threading.Condition</h4><p>一个condition变量总是与某些类型的锁相关联，这个可以使用默认的情况创建一个，当几个condition变量必须共享变量和同一个锁的时候是很有用的，锁是condition对象的一部分，没有必要分别跟踪.    </p>\n<p>condition变量服从上下文管理协议，with语句封闭之前可以取得和锁的联系，acquire()和release()会调用与锁相关的方法。   </p>\n<p>其他和锁关联的方法必须被调用,wait()方法会释放锁，当另一个线程使用notify()或者notify_all()唤醒它之前会一直阻塞，一旦被唤醒，wait()会重新获得 锁并返回。</p>\n<p>Condition实现了一个condition变量，这个condition变量<br>允许一个或者多个线程等待，直到他们被另一个线程通知。如果lock参数，被给定一个非空的值，那么他必须是一个lock或者Rlock对象，他用来做底层锁，否则会创建一个新的Rlock对象，用来做底层锁。</p>\n<ul>\n<li>wait(timeout=None):等待通知，或者等待设定的超时事件，当调用这个wait()方法时，如果调用他的线程没有得到锁，会抛出RuntimeError异常。wait()释放锁以后，在调用相同条件下的另一个进程用notify()或者notify_all()叫醒之前，会一直阻塞，wait()可指定超时时间。</li>\n</ul>\n<p>如果有等待的线程，notify()方法会唤醒一个在等待的condition变量的线程，notify_all()则会唤醒所有在等待的condition变量的线程。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\">def consumer(cond):</span><br><span class=\"line\">    with cond:</span><br><span class=\"line\">        print(&quot;consumer before wait&quot;)</span><br><span class=\"line\">        cond.wait()</span><br><span class=\"line\">        print(&quot;consumer after wait&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">def producter(cond):</span><br><span class=\"line\">    with cond:</span><br><span class=\"line\">        print(&quot;producter beofre notifyAll&quot;)</span><br><span class=\"line\">        cond.notifyAll()</span><br><span class=\"line\">        print(&quot;producter after notifyAll&quot;)</span><br><span class=\"line\">        </span><br><span class=\"line\">condition = threading.Condition()</span><br><span class=\"line\">c1 = threading.Thread(name=&apos;c1&apos;, target=consumer, args=(condition,))</span><br><span class=\"line\">c2 = threading.Thread(name=&apos;c2&apos;, target=consumer, args=(condition,))</span><br><span class=\"line\">p1 = threading.Thread(name=&apos;p1&apos;, target=producter, args=(condition,))</span><br><span class=\"line\"></span><br><span class=\"line\">c1.start()</span><br><span class=\"line\">time.sleep(2)</span><br><span class=\"line\">c2.start()</span><br><span class=\"line\">time.sleep(2)</span><br><span class=\"line\">p1.start()</span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">consumer before wait</span><br><span class=\"line\">consumer before wait</span><br><span class=\"line\">producter beofre notifyAll</span><br><span class=\"line\">producter after notifyAll</span><br><span class=\"line\">consumer after wait</span><br><span class=\"line\">consumer after wait</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-queue模块\"><a href=\"#6-queue模块\" class=\"headerlink\" title=\"6.queue模块\"></a>6.queue模块</h4><p>Queue就是队列，他是线程安全的，举例来说，我们去麦当劳吃饭，前台负责把做好的饭卖给顾客，顾客去前台领取做好的饭，这里的前台相当于我们的队列，厨师做好饭通过前台传递给顾客，所谓单项队列。这个模型也叫生产者-消费者模型。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import queue</span><br><span class=\"line\">import threading</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\">class Threadingpool():</span><br><span class=\"line\">    def __init__(self, max_num=10):</span><br><span class=\"line\">        self.queue = queue.Queue(max_num)</span><br><span class=\"line\">        for i in range(max_num):</span><br><span class=\"line\">            self.queue.put(threading.Thread)</span><br><span class=\"line\">    </span><br><span class=\"line\">    def getThreading(self):</span><br><span class=\"line\">        return self.queue.get()</span><br><span class=\"line\">    </span><br><span class=\"line\">    def addThreading(self):</span><br><span class=\"line\">        return self.queue.put(threading.Thread)</span><br><span class=\"line\">    </span><br><span class=\"line\">def func(p, i):</span><br><span class=\"line\">    time.sleep(1)</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">    p.addThreading()</span><br><span class=\"line\">    </span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    p = Threadingpool()</span><br><span class=\"line\">    for i in range(11):</span><br><span class=\"line\">        thread = p.getThreading()</span><br><span class=\"line\">        print(thread)</span><br><span class=\"line\">        t = thread(target= func, args=(p, i))</span><br><span class=\"line\">        t.start()</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"进程与线程的关系\"><a href=\"#进程与线程的关系\" class=\"headerlink\" title=\"进程与线程的关系\"></a>进程与线程的关系</h3><p>线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时，该进程所产生的所有线程都会被强制清除并且退出。。线程可与属于同一进程的其他线程共享进程的全部资源。</p>\n<h3 id=\"python的线程\"><a href=\"#python的线程\" class=\"headerlink\" title=\"python的线程\"></a>python的线程</h3><p>Threading用于提供线程相关的操作，线程是应用程序中的最小单元。</p>\n<h4 id=\"1-threading模块\"><a href=\"#1-threading模块\" class=\"headerlink\" title=\"1.threading模块\"></a>1.threading模块</h4><p>threading模块是对thread模块的二次封装，提供了更方便的api来处理线程。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\">import time</span><br><span class=\"line\">def work(num):</span><br><span class=\"line\">    time.sleep(1)</span><br><span class=\"line\">    print(&quot;the number is &#123;&#125;&quot;.format(num))</span><br><span class=\"line\">   #return</span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(20):</span><br><span class=\"line\">    t = threading.Thread(target=work, args=(i,), name=&quot;t&#123;&#125;&quot;.format(i))</span><br><span class=\"line\">    t.start()</span><br></pre></td></tr></table></figure></p>","more":"<p>这里创建了20个线程，然后控制器就交给了cpu，cpu根据指定算法进行调度，分片执行命令。<br>方法说明:<br>1.t.start():激活线程<br>2.t.getName():获取线程名称<br>3.t.setName():设置线程名称<br>4.t.name:获取或者设置线程名称<br>5.t.is_alive():判断线程是否为激活状态<br>6.t.isAlive():判断线程是否为激活状态<br>7.t.setDaemon():设置为后台线程或者前台线程(默认为False),通过设定一个布尔值设置线程是否为守护线程，必须在start()方法之后才可以使用。如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕，无论后台线程成功与否，均停止。如果是前台线程，主线程执行完毕，前台线程也在执行，主线程执行完毕后，等待前台线程也执行完毕后，程序停止。<br>8.t.isDaemon():判断是否为守护线程<br>9.t.ident:获取线程的标识符，线程标识符是一个非零整数，只有在调用了start()方法之后属性才有效,否则返回None。<br>10.t.join():逐个执行每个线程，执行完毕后往下执行，该方法使得多线程无意义。<br>11.t.run():线程被cpu调度后自动执行run方法。</p>\n<h4 id=\"2-线程锁threading-RLock和threading-Lock\"><a href=\"#2-线程锁threading-RLock和threading-Lock\" class=\"headerlink\" title=\"2.线程锁threading.RLock和threading.Lock\"></a>2.线程锁threading.RLock和threading.Lock</h4><p>由于线程之间是随机调度，并且每个线程可能执行n条执行后，cpu接着执行其他线程，为了保证数据的准确性，引入了锁的概念，可能出现的问题如下:<br>假如列表A的所有元素都为0,当一个线程从前向后打印所有元素，另一个线程从后向前修改列表的元素为1，那么输出的时候，列表的元素会一部分为0，一部分为1，导致了数据的不一致。锁的出现解决了这个问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\">global_num = 0</span><br><span class=\"line\">lock = threading.RLock()</span><br><span class=\"line\"></span><br><span class=\"line\">def Func():</span><br><span class=\"line\">    lock.acquire()    #获得锁</span><br><span class=\"line\">    global global_num</span><br><span class=\"line\">    global_num += 1</span><br><span class=\"line\">    time.sleep(1)</span><br><span class=\"line\">    print(global_num)</span><br><span class=\"line\">    lock.release()    #释放锁</span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(10):</span><br><span class=\"line\">    t = threading.Thread(target=Func,)</span><br><span class=\"line\">    t.start()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-thrading-RLock和thrading-Lock\"><a href=\"#3-thrading-RLock和thrading-Lock\" class=\"headerlink\" title=\"3.thrading.RLock和thrading.Lock\"></a>3.thrading.RLock和thrading.Lock</h4><p>RLock允许在同一线程被多次require，而Lock却不允许，如果使用RLock，那么acquire和release必须成对出现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\">lock = threading.Lock()</span><br><span class=\"line\">lock.require()</span><br><span class=\"line\">lock.acquire()  ##产生了死锁</span><br><span class=\"line\">lock.release()</span><br><span class=\"line\">loack.release()</span><br><span class=\"line\"></span><br><span class=\"line\">rlock = threading.RLock()</span><br><span class=\"line\">rlock.require()</span><br><span class=\"line\">rlock.require() #在同一线程内，程序不会堵塞</span><br><span class=\"line\">rlock.release()</span><br><span class=\"line\">rlock.release()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-threding-Event\"><a href=\"#4-threding-Event\" class=\"headerlink\" title=\"4.threding.Event\"></a>4.threding.Event</h4><p>python线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法:set,wait,clear。<br>事件处理的机制:全局定义了一个<code>Flag</code>,如果<code>Flag</code>的值为False，那么当程序执行event.wait方法就会堵塞，如果<code>Flag</code>为True,那么event.wait方法时不会堵塞。</p>\n<ul>\n<li>clear: 将<code>Flag</code>设置为False</li>\n<li>set: 将<code>Flag</code>设置为True</li>\n<li>Event.isSet():判断标识位是否为True<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\"></span><br><span class=\"line\">def do(event):</span><br><span class=\"line\">    print(&apos;start&apos;)</span><br><span class=\"line\">    print(&apos;event:&apos;,event.isSet())</span><br><span class=\"line\">    event.wait()</span><br><span class=\"line\">    print(&apos;execute&apos;)</span><br><span class=\"line\">    </span><br><span class=\"line\">event_obj = threading.Event()</span><br><span class=\"line\">for i in range(10):</span><br><span class=\"line\">    #event_obj.set()</span><br><span class=\"line\">    t = threading.Thread(target=do, args=(event_obj,))</span><br><span class=\"line\">    t.start()</span><br><span class=\"line\">    </span><br><span class=\"line\">event_obj.clear()</span><br><span class=\"line\">inp = input(&quot;input:&quot;)</span><br><span class=\"line\">if inp == &apos;true&apos;:</span><br><span class=\"line\">    event_obj.set()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当线程执行的时候，如果Flag为False，则线程会阻塞，若为True，线程不会阻塞，提供了本地和远程的并发性。</p>\n<h4 id=\"5-threading-Condition\"><a href=\"#5-threading-Condition\" class=\"headerlink\" title=\"5.threading.Condition\"></a>5.threading.Condition</h4><p>一个condition变量总是与某些类型的锁相关联，这个可以使用默认的情况创建一个，当几个condition变量必须共享变量和同一个锁的时候是很有用的，锁是condition对象的一部分，没有必要分别跟踪.    </p>\n<p>condition变量服从上下文管理协议，with语句封闭之前可以取得和锁的联系，acquire()和release()会调用与锁相关的方法。   </p>\n<p>其他和锁关联的方法必须被调用,wait()方法会释放锁，当另一个线程使用notify()或者notify_all()唤醒它之前会一直阻塞，一旦被唤醒，wait()会重新获得 锁并返回。</p>\n<p>Condition实现了一个condition变量，这个condition变量<br>允许一个或者多个线程等待，直到他们被另一个线程通知。如果lock参数，被给定一个非空的值，那么他必须是一个lock或者Rlock对象，他用来做底层锁，否则会创建一个新的Rlock对象，用来做底层锁。</p>\n<ul>\n<li>wait(timeout=None):等待通知，或者等待设定的超时事件，当调用这个wait()方法时，如果调用他的线程没有得到锁，会抛出RuntimeError异常。wait()释放锁以后，在调用相同条件下的另一个进程用notify()或者notify_all()叫醒之前，会一直阻塞，wait()可指定超时时间。</li>\n</ul>\n<p>如果有等待的线程，notify()方法会唤醒一个在等待的condition变量的线程，notify_all()则会唤醒所有在等待的condition变量的线程。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import threading</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\">def consumer(cond):</span><br><span class=\"line\">    with cond:</span><br><span class=\"line\">        print(&quot;consumer before wait&quot;)</span><br><span class=\"line\">        cond.wait()</span><br><span class=\"line\">        print(&quot;consumer after wait&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">def producter(cond):</span><br><span class=\"line\">    with cond:</span><br><span class=\"line\">        print(&quot;producter beofre notifyAll&quot;)</span><br><span class=\"line\">        cond.notifyAll()</span><br><span class=\"line\">        print(&quot;producter after notifyAll&quot;)</span><br><span class=\"line\">        </span><br><span class=\"line\">condition = threading.Condition()</span><br><span class=\"line\">c1 = threading.Thread(name=&apos;c1&apos;, target=consumer, args=(condition,))</span><br><span class=\"line\">c2 = threading.Thread(name=&apos;c2&apos;, target=consumer, args=(condition,))</span><br><span class=\"line\">p1 = threading.Thread(name=&apos;p1&apos;, target=producter, args=(condition,))</span><br><span class=\"line\"></span><br><span class=\"line\">c1.start()</span><br><span class=\"line\">time.sleep(2)</span><br><span class=\"line\">c2.start()</span><br><span class=\"line\">time.sleep(2)</span><br><span class=\"line\">p1.start()</span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">consumer before wait</span><br><span class=\"line\">consumer before wait</span><br><span class=\"line\">producter beofre notifyAll</span><br><span class=\"line\">producter after notifyAll</span><br><span class=\"line\">consumer after wait</span><br><span class=\"line\">consumer after wait</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-queue模块\"><a href=\"#6-queue模块\" class=\"headerlink\" title=\"6.queue模块\"></a>6.queue模块</h4><p>Queue就是队列，他是线程安全的，举例来说，我们去麦当劳吃饭，前台负责把做好的饭卖给顾客，顾客去前台领取做好的饭，这里的前台相当于我们的队列，厨师做好饭通过前台传递给顾客，所谓单项队列。这个模型也叫生产者-消费者模型。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import queue</span><br><span class=\"line\">import threading</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\">class Threadingpool():</span><br><span class=\"line\">    def __init__(self, max_num=10):</span><br><span class=\"line\">        self.queue = queue.Queue(max_num)</span><br><span class=\"line\">        for i in range(max_num):</span><br><span class=\"line\">            self.queue.put(threading.Thread)</span><br><span class=\"line\">    </span><br><span class=\"line\">    def getThreading(self):</span><br><span class=\"line\">        return self.queue.get()</span><br><span class=\"line\">    </span><br><span class=\"line\">    def addThreading(self):</span><br><span class=\"line\">        return self.queue.put(threading.Thread)</span><br><span class=\"line\">    </span><br><span class=\"line\">def func(p, i):</span><br><span class=\"line\">    time.sleep(1)</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">    p.addThreading()</span><br><span class=\"line\">    </span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    p = Threadingpool()</span><br><span class=\"line\">    for i in range(11):</span><br><span class=\"line\">        thread = p.getThreading()</span><br><span class=\"line\">        print(thread)</span><br><span class=\"line\">        t = thread(target= func, args=(p, i))</span><br><span class=\"line\">        t.start()</span><br></pre></td></tr></table></figure></p>"},{"layout":"posts","title":"redis事务","date":"2019-02-25T01:58:14.000Z","_content":"\n### 什么是redis的基本事务\nredis的基本事务(basic transaction)需要用到MULTI和EXEC命令，这种事务可以让一个客户端在不被其他客户端打断的情况下执行多个命令。和关系数据库那种可以在执行的过程中进行回滚(rollback)的事务不同，在redis里面，被MULTI和EXEC命令保卫的所有命令会一个接一个的执行，知道所有的命令执行完毕。当一个事务执行完毕后，才会处理其他客户端的命令。    \n在redis里面执行事务，我们首先需要执行MULTI命令，然后输入我们想要在事务里面执行的命令，然后再执行EXEC命令。大概redis从一个客户端那里接收到MULTI命令，redis会将这个客户端发送的所有命令放到一个队列里面，直到这个客户端发送EXEC命令为止，然后redis就会在不被打断的情况下，一个接一个的执行存储在队列里面的命令。从语义上说，redis事务在pytho客户端上是以流水线(pipeline)实现的；对连接对象调用pipeline()方法创建一个事务，在这个事务正确使用的情况下，会用MULTI和EXEC包裹起一连串的多个命令。另外，为了减少redis与客户端之间的通信往返次数，执行多个命令时候的性能，python的redis客户端会存储起事务包含的多个命令，然后在事务执行时一次性将所有命令发送给redis。    \n<!--more -->\n```\nconn = redis.Redis()\n\ndef notrans():\n    print(conn.incr('notrans:')) #d对notrans计数器执行自增操作，并打印操作的执行结果\n    time.sleep(0.1)\n    conn.incr('notrans', -1)\n\nif 1:\n    for i in range(3):\n        threading.Thread(target=notrans).start()\n    time.sleep(5)\n>>>1\n>>>2\n>>>3\n    \n##由于没有使用事务，所以三个线程在没有执行自减操作之前，对counter计数执行自增操作。如果我们需要在不受其他命令\n##干扰的情况下，对计数器执行自增自减操作、利用事务\n\ndef trans():\n    pipeline = conn.pipeline()  #创建一个事务型(transactional)流水线对象\n    pipeline.incr('trans:')  #吧针对'trans:' 计数器的自增操作放入队列\n    time.sleep(.1)\n    pipeline.incr('trans:', -1)  #把针对'trans:'计数器的自减操作放入队列\n    print(pipeline.execute()[0]) #执行事务包含的命令并打印自增的操作结果\n\nif 1:\n    for i in range(3):\n        threading.Thread(target=trans).start()\n    time.sleep(.5)\n>>>1\n>>>1\n>>>1\n\n## 尽管自增自减操作有一短延时，但通过使用事务，各个线程都可以在不被打断的情况下执行各自队列里面的命令\n```\n\n### 键的过期时间\n\n在使用redis存储数据的时候，有些数据可能在某个时间点之后就不在使用了，用户可以显式的使用del删除，也可以通过redus的过期时间(expiration)特性来让一个键在给定的实现(timeout)之后自动删除。\n\n- persist: persist key-name,移除键的过期时间\n- ttl: ttl key-name,返回距离给定键的过期时间还有多少秒\n- expire: expire key-name seconds,让key在多少seconds之后过期\n- expireat: expireat keyname timestamp,将给定的键的过期时间设置为给定的unix时间戳\n- pttl: pttl key-name,返回距离给定键的过期时间还有多少毫秒\n- pexpire: pexpire key-name milliseconds,让键key-name在milliseconds毫秒之后过期\n- pexpireat: pexpireat key-name timestamp-milliseconds,讲一个毫秒级的unix时间戳设置为给定键的过期时间\n```\n>>> conn.set('key', 'value')                    # 设置一个简单的字符串值，作为过期时间的设置对象。\nTrue                                            #\n>>> conn.get('key')                             #\n'value'                                         #\n>>> conn.expire('key', 2)                       # 如果我们为键设置了过期时间，那么当键过期后，\nTrue                                            # 我们再尝试去获取键时，会发现键已经被删除了。\n>>> time.sleep(2)                               #\n>>> conn.get('key')                             #\n>>> conn.set('key', 'value2')\nTrue\n>>> conn.expire('key', 100); conn.ttl('key')    # 还可以很容易地查到键距离过期时间还有多久。\nTrue                                            #\n100     \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/redis事务.md","raw":"---\nlayout: posts\ntitle: redis事务\ndate: 2019-02-25 09:58:14\ntags: redis\ncategories: redis\n---\n\n### 什么是redis的基本事务\nredis的基本事务(basic transaction)需要用到MULTI和EXEC命令，这种事务可以让一个客户端在不被其他客户端打断的情况下执行多个命令。和关系数据库那种可以在执行的过程中进行回滚(rollback)的事务不同，在redis里面，被MULTI和EXEC命令保卫的所有命令会一个接一个的执行，知道所有的命令执行完毕。当一个事务执行完毕后，才会处理其他客户端的命令。    \n在redis里面执行事务，我们首先需要执行MULTI命令，然后输入我们想要在事务里面执行的命令，然后再执行EXEC命令。大概redis从一个客户端那里接收到MULTI命令，redis会将这个客户端发送的所有命令放到一个队列里面，直到这个客户端发送EXEC命令为止，然后redis就会在不被打断的情况下，一个接一个的执行存储在队列里面的命令。从语义上说，redis事务在pytho客户端上是以流水线(pipeline)实现的；对连接对象调用pipeline()方法创建一个事务，在这个事务正确使用的情况下，会用MULTI和EXEC包裹起一连串的多个命令。另外，为了减少redis与客户端之间的通信往返次数，执行多个命令时候的性能，python的redis客户端会存储起事务包含的多个命令，然后在事务执行时一次性将所有命令发送给redis。    \n<!--more -->\n```\nconn = redis.Redis()\n\ndef notrans():\n    print(conn.incr('notrans:')) #d对notrans计数器执行自增操作，并打印操作的执行结果\n    time.sleep(0.1)\n    conn.incr('notrans', -1)\n\nif 1:\n    for i in range(3):\n        threading.Thread(target=notrans).start()\n    time.sleep(5)\n>>>1\n>>>2\n>>>3\n    \n##由于没有使用事务，所以三个线程在没有执行自减操作之前，对counter计数执行自增操作。如果我们需要在不受其他命令\n##干扰的情况下，对计数器执行自增自减操作、利用事务\n\ndef trans():\n    pipeline = conn.pipeline()  #创建一个事务型(transactional)流水线对象\n    pipeline.incr('trans:')  #吧针对'trans:' 计数器的自增操作放入队列\n    time.sleep(.1)\n    pipeline.incr('trans:', -1)  #把针对'trans:'计数器的自减操作放入队列\n    print(pipeline.execute()[0]) #执行事务包含的命令并打印自增的操作结果\n\nif 1:\n    for i in range(3):\n        threading.Thread(target=trans).start()\n    time.sleep(.5)\n>>>1\n>>>1\n>>>1\n\n## 尽管自增自减操作有一短延时，但通过使用事务，各个线程都可以在不被打断的情况下执行各自队列里面的命令\n```\n\n### 键的过期时间\n\n在使用redis存储数据的时候，有些数据可能在某个时间点之后就不在使用了，用户可以显式的使用del删除，也可以通过redus的过期时间(expiration)特性来让一个键在给定的实现(timeout)之后自动删除。\n\n- persist: persist key-name,移除键的过期时间\n- ttl: ttl key-name,返回距离给定键的过期时间还有多少秒\n- expire: expire key-name seconds,让key在多少seconds之后过期\n- expireat: expireat keyname timestamp,将给定的键的过期时间设置为给定的unix时间戳\n- pttl: pttl key-name,返回距离给定键的过期时间还有多少毫秒\n- pexpire: pexpire key-name milliseconds,让键key-name在milliseconds毫秒之后过期\n- pexpireat: pexpireat key-name timestamp-milliseconds,讲一个毫秒级的unix时间戳设置为给定键的过期时间\n```\n>>> conn.set('key', 'value')                    # 设置一个简单的字符串值，作为过期时间的设置对象。\nTrue                                            #\n>>> conn.get('key')                             #\n'value'                                         #\n>>> conn.expire('key', 2)                       # 如果我们为键设置了过期时间，那么当键过期后，\nTrue                                            # 我们再尝试去获取键时，会发现键已经被删除了。\n>>> time.sleep(2)                               #\n>>> conn.get('key')                             #\n>>> conn.set('key', 'value2')\nTrue\n>>> conn.expire('key', 100); conn.ttl('key')    # 还可以很容易地查到键距离过期时间还有多久。\nTrue                                            #\n100     \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"redis事务","published":1,"updated":"2022-05-20T02:24:20.543Z","comments":1,"photos":[],"link":"","_id":"cl3e0vh7n001hlae1r8b45ltr","content":"<h3 id=\"什么是redis的基本事务\"><a href=\"#什么是redis的基本事务\" class=\"headerlink\" title=\"什么是redis的基本事务\"></a>什么是redis的基本事务</h3><p>redis的基本事务(basic transaction)需要用到MULTI和EXEC命令，这种事务可以让一个客户端在不被其他客户端打断的情况下执行多个命令。和关系数据库那种可以在执行的过程中进行回滚(rollback)的事务不同，在redis里面，被MULTI和EXEC命令保卫的所有命令会一个接一个的执行，知道所有的命令执行完毕。当一个事务执行完毕后，才会处理其他客户端的命令。<br>在redis里面执行事务，我们首先需要执行MULTI命令，然后输入我们想要在事务里面执行的命令，然后再执行EXEC命令。大概redis从一个客户端那里接收到MULTI命令，redis会将这个客户端发送的所有命令放到一个队列里面，直到这个客户端发送EXEC命令为止，然后redis就会在不被打断的情况下，一个接一个的执行存储在队列里面的命令。从语义上说，redis事务在pytho客户端上是以流水线(pipeline)实现的；对连接对象调用pipeline()方法创建一个事务，在这个事务正确使用的情况下，会用MULTI和EXEC包裹起一连串的多个命令。另外，为了减少redis与客户端之间的通信往返次数，执行多个命令时候的性能，python的redis客户端会存储起事务包含的多个命令，然后在事务执行时一次性将所有命令发送给redis。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn = redis.Redis()</span><br><span class=\"line\"></span><br><span class=\"line\">def notrans():</span><br><span class=\"line\">    print(conn.incr(&apos;notrans:&apos;)) #d对notrans计数器执行自增操作，并打印操作的执行结果</span><br><span class=\"line\">    time.sleep(0.1)</span><br><span class=\"line\">    conn.incr(&apos;notrans&apos;, -1)</span><br><span class=\"line\"></span><br><span class=\"line\">if 1:</span><br><span class=\"line\">    for i in range(3):</span><br><span class=\"line\">        threading.Thread(target=notrans).start()</span><br><span class=\"line\">    time.sleep(5)</span><br><span class=\"line\">&gt;&gt;&gt;1</span><br><span class=\"line\">&gt;&gt;&gt;2</span><br><span class=\"line\">&gt;&gt;&gt;3</span><br><span class=\"line\">    </span><br><span class=\"line\">##由于没有使用事务，所以三个线程在没有执行自减操作之前，对counter计数执行自增操作。如果我们需要在不受其他命令</span><br><span class=\"line\">##干扰的情况下，对计数器执行自增自减操作、利用事务</span><br><span class=\"line\"></span><br><span class=\"line\">def trans():</span><br><span class=\"line\">    pipeline = conn.pipeline()  #创建一个事务型(transactional)流水线对象</span><br><span class=\"line\">    pipeline.incr(&apos;trans:&apos;)  #吧针对&apos;trans:&apos; 计数器的自增操作放入队列</span><br><span class=\"line\">    time.sleep(.1)</span><br><span class=\"line\">    pipeline.incr(&apos;trans:&apos;, -1)  #把针对&apos;trans:&apos;计数器的自减操作放入队列</span><br><span class=\"line\">    print(pipeline.execute()[0]) #执行事务包含的命令并打印自增的操作结果</span><br><span class=\"line\"></span><br><span class=\"line\">if 1:</span><br><span class=\"line\">    for i in range(3):</span><br><span class=\"line\">        threading.Thread(target=trans).start()</span><br><span class=\"line\">    time.sleep(.5)</span><br><span class=\"line\">&gt;&gt;&gt;1</span><br><span class=\"line\">&gt;&gt;&gt;1</span><br><span class=\"line\">&gt;&gt;&gt;1</span><br><span class=\"line\"></span><br><span class=\"line\">## 尽管自增自减操作有一短延时，但通过使用事务，各个线程都可以在不被打断的情况下执行各自队列里面的命令</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"键的过期时间\"><a href=\"#键的过期时间\" class=\"headerlink\" title=\"键的过期时间\"></a>键的过期时间</h3><p>在使用redis存储数据的时候，有些数据可能在某个时间点之后就不在使用了，用户可以显式的使用del删除，也可以通过redus的过期时间(expiration)特性来让一个键在给定的实现(timeout)之后自动删除。</p>\n<ul>\n<li>persist: persist key-name,移除键的过期时间</li>\n<li>ttl: ttl key-name,返回距离给定键的过期时间还有多少秒</li>\n<li>expire: expire key-name seconds,让key在多少seconds之后过期</li>\n<li>expireat: expireat keyname timestamp,将给定的键的过期时间设置为给定的unix时间戳</li>\n<li>pttl: pttl key-name,返回距离给定键的过期时间还有多少毫秒</li>\n<li>pexpire: pexpire key-name milliseconds,让键key-name在milliseconds毫秒之后过期</li>\n<li>pexpireat: pexpireat key-name timestamp-milliseconds,讲一个毫秒级的unix时间戳设置为给定键的过期时间<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.set(&apos;key&apos;, &apos;value&apos;)                    # 设置一个简单的字符串值，作为过期时间的设置对象。</span><br><span class=\"line\">True                                            #</span><br><span class=\"line\">&gt;&gt;&gt; conn.get(&apos;key&apos;)                             #</span><br><span class=\"line\">&apos;value&apos;                                         #</span><br><span class=\"line\">&gt;&gt;&gt; conn.expire(&apos;key&apos;, 2)                       # 如果我们为键设置了过期时间，那么当键过期后，</span><br><span class=\"line\">True                                            # 我们再尝试去获取键时，会发现键已经被删除了。</span><br><span class=\"line\">&gt;&gt;&gt; time.sleep(2)                               #</span><br><span class=\"line\">&gt;&gt;&gt; conn.get(&apos;key&apos;)                             #</span><br><span class=\"line\">&gt;&gt;&gt; conn.set(&apos;key&apos;, &apos;value2&apos;)</span><br><span class=\"line\">True</span><br><span class=\"line\">&gt;&gt;&gt; conn.expire(&apos;key&apos;, 100); conn.ttl(&apos;key&apos;)    # 还可以很容易地查到键距离过期时间还有多久。</span><br><span class=\"line\">True                                            #</span><br><span class=\"line\">100</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是redis的基本事务\"><a href=\"#什么是redis的基本事务\" class=\"headerlink\" title=\"什么是redis的基本事务\"></a>什么是redis的基本事务</h3><p>redis的基本事务(basic transaction)需要用到MULTI和EXEC命令，这种事务可以让一个客户端在不被其他客户端打断的情况下执行多个命令。和关系数据库那种可以在执行的过程中进行回滚(rollback)的事务不同，在redis里面，被MULTI和EXEC命令保卫的所有命令会一个接一个的执行，知道所有的命令执行完毕。当一个事务执行完毕后，才会处理其他客户端的命令。<br>在redis里面执行事务，我们首先需要执行MULTI命令，然后输入我们想要在事务里面执行的命令，然后再执行EXEC命令。大概redis从一个客户端那里接收到MULTI命令，redis会将这个客户端发送的所有命令放到一个队列里面，直到这个客户端发送EXEC命令为止，然后redis就会在不被打断的情况下，一个接一个的执行存储在队列里面的命令。从语义上说，redis事务在pytho客户端上是以流水线(pipeline)实现的；对连接对象调用pipeline()方法创建一个事务，在这个事务正确使用的情况下，会用MULTI和EXEC包裹起一连串的多个命令。另外，为了减少redis与客户端之间的通信往返次数，执行多个命令时候的性能，python的redis客户端会存储起事务包含的多个命令，然后在事务执行时一次性将所有命令发送给redis。<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn = redis.Redis()</span><br><span class=\"line\"></span><br><span class=\"line\">def notrans():</span><br><span class=\"line\">    print(conn.incr(&apos;notrans:&apos;)) #d对notrans计数器执行自增操作，并打印操作的执行结果</span><br><span class=\"line\">    time.sleep(0.1)</span><br><span class=\"line\">    conn.incr(&apos;notrans&apos;, -1)</span><br><span class=\"line\"></span><br><span class=\"line\">if 1:</span><br><span class=\"line\">    for i in range(3):</span><br><span class=\"line\">        threading.Thread(target=notrans).start()</span><br><span class=\"line\">    time.sleep(5)</span><br><span class=\"line\">&gt;&gt;&gt;1</span><br><span class=\"line\">&gt;&gt;&gt;2</span><br><span class=\"line\">&gt;&gt;&gt;3</span><br><span class=\"line\">    </span><br><span class=\"line\">##由于没有使用事务，所以三个线程在没有执行自减操作之前，对counter计数执行自增操作。如果我们需要在不受其他命令</span><br><span class=\"line\">##干扰的情况下，对计数器执行自增自减操作、利用事务</span><br><span class=\"line\"></span><br><span class=\"line\">def trans():</span><br><span class=\"line\">    pipeline = conn.pipeline()  #创建一个事务型(transactional)流水线对象</span><br><span class=\"line\">    pipeline.incr(&apos;trans:&apos;)  #吧针对&apos;trans:&apos; 计数器的自增操作放入队列</span><br><span class=\"line\">    time.sleep(.1)</span><br><span class=\"line\">    pipeline.incr(&apos;trans:&apos;, -1)  #把针对&apos;trans:&apos;计数器的自减操作放入队列</span><br><span class=\"line\">    print(pipeline.execute()[0]) #执行事务包含的命令并打印自增的操作结果</span><br><span class=\"line\"></span><br><span class=\"line\">if 1:</span><br><span class=\"line\">    for i in range(3):</span><br><span class=\"line\">        threading.Thread(target=trans).start()</span><br><span class=\"line\">    time.sleep(.5)</span><br><span class=\"line\">&gt;&gt;&gt;1</span><br><span class=\"line\">&gt;&gt;&gt;1</span><br><span class=\"line\">&gt;&gt;&gt;1</span><br><span class=\"line\"></span><br><span class=\"line\">## 尽管自增自减操作有一短延时，但通过使用事务，各个线程都可以在不被打断的情况下执行各自队列里面的命令</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"键的过期时间\"><a href=\"#键的过期时间\" class=\"headerlink\" title=\"键的过期时间\"></a>键的过期时间</h3><p>在使用redis存储数据的时候，有些数据可能在某个时间点之后就不在使用了，用户可以显式的使用del删除，也可以通过redus的过期时间(expiration)特性来让一个键在给定的实现(timeout)之后自动删除。</p>\n<ul>\n<li>persist: persist key-name,移除键的过期时间</li>\n<li>ttl: ttl key-name,返回距离给定键的过期时间还有多少秒</li>\n<li>expire: expire key-name seconds,让key在多少seconds之后过期</li>\n<li>expireat: expireat keyname timestamp,将给定的键的过期时间设置为给定的unix时间戳</li>\n<li>pttl: pttl key-name,返回距离给定键的过期时间还有多少毫秒</li>\n<li>pexpire: pexpire key-name milliseconds,让键key-name在milliseconds毫秒之后过期</li>\n<li>pexpireat: pexpireat key-name timestamp-milliseconds,讲一个毫秒级的unix时间戳设置为给定键的过期时间<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.set(&apos;key&apos;, &apos;value&apos;)                    # 设置一个简单的字符串值，作为过期时间的设置对象。</span><br><span class=\"line\">True                                            #</span><br><span class=\"line\">&gt;&gt;&gt; conn.get(&apos;key&apos;)                             #</span><br><span class=\"line\">&apos;value&apos;                                         #</span><br><span class=\"line\">&gt;&gt;&gt; conn.expire(&apos;key&apos;, 2)                       # 如果我们为键设置了过期时间，那么当键过期后，</span><br><span class=\"line\">True                                            # 我们再尝试去获取键时，会发现键已经被删除了。</span><br><span class=\"line\">&gt;&gt;&gt; time.sleep(2)                               #</span><br><span class=\"line\">&gt;&gt;&gt; conn.get(&apos;key&apos;)                             #</span><br><span class=\"line\">&gt;&gt;&gt; conn.set(&apos;key&apos;, &apos;value2&apos;)</span><br><span class=\"line\">True</span><br><span class=\"line\">&gt;&gt;&gt; conn.expire(&apos;key&apos;, 100); conn.ttl(&apos;key&apos;)    # 还可以很容易地查到键距离过期时间还有多久。</span><br><span class=\"line\">True                                            #</span><br><span class=\"line\">100</span><br></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"redis","date":"2019-01-04T03:24:29.000Z","catrgories":"redis","_content":"\n#### 字符串\n\n在redis中，字符串可以存储三种类型的值    \n- 字节串(byte string)\n- 整数\n- 浮点数\n\n简单的自增命令，自减命令    \n- incr: 用法incr key-name，将键存储的值加1    \n- decr: 用法decr key-name，将键存储的值减1    \n- incrby: 用法 incrby key-name amount，将键对应的值加上amount    \n- decrby: 用法 decrby key-name amount,将键对应的值减去amount    \n- incrbyfloat: 用法incrbyfloat ket-name amount，将键存储的值加上浮点数amount，这个命令在redis2.6以上可用。    \n\n例子，在python解释器运行:\n```\n>>> conn = redis.Redis()\n>>> conn.get('key')  #尝试获取一个不存在的键值，得到None，终端不会显示\n>>> conn.incr('key')  #可对不存在的键来进行自增操作\n1\n>>> conn.incr('key', 15)\n16\n>>> conn.decr('key', 5)\n11\n>>> conn.get('key')  #尝试获取一个键时，命令以字符串格式返回被存储的整数\n11\n>>> conn.set('key', '20')\nTrue\n>>> conn.incr('key', 5)\n25\n```\n<!-- more -->\n其他命令:   \n- append: append key-name value，将提供的值value追加到给定键key-name当前存储值的末尾\n- getrange: getrange ket-name start end，获取一个由偏移量start-end内的所有字符组成的子串，start从0递增。\n- setrange: setrange key-name start value，将从start偏移量开始的子串设置为value。\n- getbit: getbit key-name offset，将字节串看做二进制串(bit string)，并返回串中偏移量为offset的二进制的值。\n- setbit: setbit keyname offset value，将字节串看为二进制串，并将串中偏移量为offset的值设为value\n\n例子:\n```\n>>> conn = redis.Redis()\n>>> conn.append('newstring', 'hello ')\n6\n>>> conn.get('newstring')\n'hello '\n>>> conn.getrange('newstring', 0, 2)\n'hel'\n>>> conn.setrange('newstring', 6, 'world')\n11\n>>> conn.setbit('anohter-key', 2, 1)\n0\n>>> conn.setbit('another-key', 7, 1)  #redis存储二进制位按照从高到低进行排列\n0\n>>> conn.get('another-key')\n'!'\n```\n\n#### 列表\n\nredis列表允许用户从序列的两端弹出或者推入元素。获取元素，执行列表操作，列表还可以用来存储任务信息，最近浏览过的文章和常用的联系人信息。常用命令如下\n\n- rpush: rpush key-name value [value...],将一个值或多个值从列表右端推入\n- lpush: 同上，从左边推入\n- rpop:  rpop key-name value,将一个值从列表右端弹出，并返回\n- lpop: 同上，从左边\n- lindex: lindex key-name offset,返回列表中偏移量为offset的元素\n- lrange: lrange key-name start end,返回列表中偏移量从start开始到end结束的所有元素\n- ltrim: ltrim key-name start end,对列表进行修剪，只保留start到end之间的元素，包括start和end\n\n例子:\n```\n>>> conn.rpush('list-key', 'last')          # 在向列表推入元素时，\n1L                                          # 推入操作执行完毕之后会返回列表当前的长度。\n>>> conn.lpush('list-key', 'first')         # 可以很容易地对列表的两端执行推入操作。\n2L\n>>> conn.rpush('list-key', 'new last')\n3L\n>>> conn.lrange('list-key', 0, -1)          # 从语义上来说，列表的左端为开头，右端为结尾。\n['first', 'last', 'new last']               #\n>>> conn.lpop('list-key')                   # 通过重复地弹出列表左端的元素，\n'first'                                     # 可以按照从左到右的顺序来获取列表中的元素。\n>>> conn.lpop('list-key')                   #\n'last'                                      #\n>>> conn.lrange('list-key', 0, -1)\n['new last']\n>>> conn.rpush('list-key', 'a', 'b', 'c')   # 可以同时推入多个元素。\n4L\n>>> conn.lrange('list-key', 0, -1)\n['new last', 'a', 'b', 'c']\n>>> conn.ltrim('list-key', 2, -1)           # 可以从列表的左端、右端或者左右两端删减任意数量的元素。\nTrue                                        #\n>>> conn.lrange('list-key', 0, -1)          #\n['b', 'c']\n```\n其他命令：    \n- blpop: blpop key-name [key-name] timeout,从第一个非空列表中弹出位于最左端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现。\n- brpop: brpop key-name [key-name] timeout,同上，但是弹出位于最右端的元素。\n- rpoplpush: rpoplpush source-key dest-key,从source-key列表中弹出位于最右端的元素，将这个元素推如到desk-key的最左端，并返回这个元素\n- brpoplpush: brpoplpush source-key dest-key,从source-key列表弹出最右端的元素，然后将这个元素推入到dest-key的最左端，并向用户返回这个元素，若source-key为空，那在timeout秒内阻塞并等待可弹出的元素出现。    \n\n例子,带有b可以设置timeout:\n```\n>>> conn.rpush('list', 'item1')             # 将一些元素添加到两个列表里面。\n1                                           #\n>>> conn.rpush('list', 'item2')             #\n2                                           #\n>>> conn.rpush('list2', 'item3')            #\n1                                           #\n>>> conn.brpoplpush('list2', 'list', 1)     # 将一个元素从一个列表移动到另一个列表，\n'item3'                                     # 并返回被移动的元素。\n>>> conn.brpoplpush('list2', 'list', 1)     # 当列表不包含任何元素时，阻塞弹出操作会在给定的时限内等待可弹出的元素出现，并在时限到达后返回None（交互终端不会打印这个值）。\n>>> conn.lrange('list', 0, -1)              # 弹出“list2”最右端的元素，\n['item3', 'item1', 'item2']                 # 并将弹出的元素推入到“list”的左端。\n>>> conn.brpoplpush('list', 'list2', 1)\n'item2'\n>>> conn.blpop(['list', 'list2'], 1)        # BLPOP命令会从左到右地检查传入的列表，\n('list', 'item3')                           # 并对最先遇到的非空列表执行弹出操作。\n>>> conn.blpop(['list', 'list2'], 1)        #\n('list', 'item1')                           #\n>>> conn.blpop(['list', 'list2'], 1)        #list空了，那么弹出list2的元素\n('list2', 'item2')                          #\n>>> conn.blpop(['list', 'list2'], 1)        #等待1s，没有元素可以弹出\n```\n\n对于阻塞弹出命令和弹出并且推入命令，最常见的技术消息传递(messageing)和任务队列(task queue)的开发\n\n#### 集合\n\nredis的集合以无序的方式来存储各个互不相同的元素，用户可以快速的对集合执行添加元素，移除元素，以及检验一个元素是否存在于集合的操作。常用的命令如下:\n\n- sadd: sadd key-name item [item...],将一个或者多个元素添加到集合中，并返回添加元素中原本不存在于集合里面的元素数量。\n- srem: srem key-name item [item...],从集合里面移除一个或者多个元素，并返回被移除元素的数量\n- sismember: sismember key-name item,检查item元素是否存在与集合key-name中\n- scard: scard key-name,返回集合中包含元素的数量\n- smembers: smembers key-name,返回集合所包含的元素\n- srandmember: srandmember key-name [count],从集合中随机返回一个或多个元素，当count为正数，命令返回的元素不会重复，当count为负数，命令返回的随机元素可能会重复。返回的数目为count的绝对值，若大于set所有元素的数量，则全部返回，负数则重复。\n- spop: spop key-name,从集合里面移除并且返回一个随机元素\n- smove: smove source-key dest-key item,如果集合source-key包含item,那么从集合source-key移除item，并且将item加入到dest-key中，如果item被成功移除，反应会1，否则返回0\n\n示例如下:\n```\n>>> conn.sadd('set-key', 'a', 'b', 'c')         # SADD命令会将那些目前并不存在于集合里面的元素添加到集合里面，\n3                                               # 并返回被添加元素的数量。\n>>> conn.srem('set-key', 'c', 'd')              # srem函数在元素被成功移除时返回True，\nTrue                                            # 移除失败时返回False；\n>>> conn.srem('set-key', 'c', 'd')              # 注意这是Python客户端的一个bug，\nFalse                                           # 实际上Redis的SREM命令返回的是被移除元素的数量，而不是布尔值。\n>>> conn.scard('set-key')                       # 查看集合包含的元素数量。\n2                                               #\n>>> conn.smembers('set-key')                    # 获取集合包含的所有元素。\nset(['a', 'b'])                                 #\n>>> conn.smove('set-key', 'set-key2', 'a')      # 可以很容易地将元素从一个集合移动到另一个集合。\nTrue                                            #\n>>> conn.smove('set-key', 'set-key2', 'c')      # 在执行SMOVE命令时，\nFalse                                           # 如果用户想要移动的元素不存在于第一个集合里，\n>>> conn.smembers('set-key2')                   # 那么移动操作就不会执行。\nset(['a'])   \n```\n\n如下是用于组合和处理多个集合的redis命令\n- sdiff: sdiff key-name [key-name],返回存在与第一个集合而不存在于其他集合的元素。(数学的差集运算)。\n- sdiffstore: sdiff dest-key key-name [key-name],将那些存在与第一个集合，而不存在于其他集合的元素存储到dest-key中。\n- sinter: sinter key-name [key-name],返回存在于所有集合中的元素，数学的交集运算\n- sinterstore: sinter dest-key key-name [key-name],同上，不过存储下来\n- sunion: sunion key-name [key-name],数学的并集\n- sunionstore: sunionstore dest-key key-name [key-name],交集并存储\n\n例子如下:\n```\n>>> conn.sadd('skey1', 'a', 'b', 'c', 'd')  # 首先将一些元素添加到两个集合里面。\n4                                           #\n>>> conn.sadd('skey2', 'c', 'd', 'e', 'f')  #\n4                                           #\n>>> conn.sdiff('skey1', 'skey2')            # 计算从第一个集合中移除第二个集合所有元素之后的结果。\nset(['a', 'b'])                             #\n>>> conn.sinter('skey1', 'skey2')           # 还可以找出同时存在于两个集合中的元素。\nset(['c', 'd'])                             #\n>>> conn.sunion('skey1', 'skey2')           # 可以找出两个结合中的所有元素。\nset(['a', 'c', 'b', 'e', 'd', 'f'])         #\n```\n\n#### 散列\n\nredis的三列可以让用户将多个键值对存储带一个redis里面，从功能上来说，redis为散列值提供了一些和字符串相同的特性。是的散列适用于将一些相关的数据存储到一起，我们可以吧这些数据聚集作为关系数据库的行，或者文档中存储的文档。    \n常用命令如下:\n- hmget: hmget key-name key [key...],从散列里面获取一个或者多个键的值\n- hmset: hmset key-name key value [key,value...],为散列里面的一个键或者多个键来设置值\n- hdel: hdel key-name key [key...],删除散列六面的一个或者多个键值对，返回成功找到并删除键值的数目。\n- hlen: hlen key-name,返回散列包含的键值对的数目    \n例子如下:\n```\n>>> conn.hmset('hash-key', {'k1':'v1', 'k2':'v2', 'k3':'v3'})   # 使用HMSET命令可以一次将多个键值对添加到散列里面。\nTrue                                                            #\n>>> conn.hmget('hash-key', ['k2', 'k3'])                        #  使用HMGET命令可以一次获取多个键的值。\n['v2', 'v3']                                                    #\n>>> conn.hlen('hash-key')                                       # HLEN命令通常用于调试一个包含非常多键值对的散列。\n3                                                               #\n>>> conn.hdel('hash-key', 'k1', 'k3')                           # HDEL命令在成功地移除了至少一个键值对时返回True，\nTrue \n```\n其他的常用批量操作的命令:    \n- hexists: hexists key-name key,检查给定键是否存在与散列之中\n- hkeys: hkeys key-name,获取散列包含的所有键\n- hvals: hvals key-name,获取散列包含的所有值\n- hgetall: hgetall key-name,获取散列包含的所有键值对\n- hincrby: hincrby key-name key increment,将键key的值加上整数increment\n- hincrfloat: hincrfloat key-name key increment,将键的值加上浮点数increment    \n\n例子如下:\n```\n>>> conn.hmset('hash-key2', {'short':'hello', 'long':1000*'1'}) # 在考察散列的时候，我们可以只取出散列包含的键，而不必传输大的键值。\nTrue                                                            #\n>>> conn.hkeys('hash-key2')                                     #\n['long', 'short']                                               #\n>>> conn.hexists('hash-key2', 'num')                            # 检查给定的键是否存在于散列中。\nFalse                                                           #\n>>> conn.hincrby('hash-key2', 'num')                            # 和字符串一样，\n1L                                                              # 对散列中一个尚未存在的键执行自增操作时，\n>>> conn.hexists('hash-key2', 'num')                            # Redis会将键的值当作0来处理。\nTrue  \n```\n\n#### 有序集合\n\n常用的有序集合的命令:\n- zadd: zadd key-name score number [score number],将带有给定值的成员添加到有序集合里面\n- zrem: zrem key-name member [member...],从有序集合移除给定的成员，并返回被移除成员的数目\n- zcard: zcard key-name,返回有序集合包含的成员的数目\n- zincrby: zincrby key-name increment member,将member的值加上increment\n- zcount: zcount key-name min max,返回分值介于min和max之间的成员\n- zrank: zrank key-name min max,返回成员member在key-name的排名\n- zscore: zscore key-name member ,返回成员member的值\n- zrange: zrange key-name start end [withscores],返回有序集合中排名介于start和end之间的成员，如果除了给定的可选的withscore选项，那么连成员的分值一并返回\n\n例子如下:\n```\n>>> conn.zadd('zset-key', {'a': 3, 'b': 2, 'c': 1})   # 在Python以字典输入\n3                                                   # 这跟Redis标准的先输入分值、后输入成员的做法正好相反。\n>>> conn.zcard('zset-key')                          # 取得有序集合的大小可以让我们在某些情况下知道是否需要对有序集合进行修剪。\n3                                                   #\n>>> conn.zincrby('zset-key', 'c', 3)                # 跟字符串和散列一样，\n4.0                                                 # 有序集合的成员也可以执行自增操作。\n>>> conn.zscore('zset-key', 'b')                    # 获取单个成员的分值对于实现计数器或者排行榜之类的功能非常有用。\n2.0                                                 #\n>>> conn.zrank('zset-key', 'c')                     # 获取指定成员的排名（排名以0为开始），\n2                                                   # 之后可以根据这个排名来决定ZRANGE的访问范围。\n>>> conn.zcount('zset-key', 0, 3)                   # 对于某些任务来说，\n2L                                                  # 统计给定分值范围内的元素数量非常有用。\n>>> conn.zrem('zset-key', 'b')                      # 从有序集合里面移除成员和添加成员一样容易。\nTrue                                                #\n>>> conn.zrange('zset-key', 0, -1, withscores=True) # 在进行调试时，我们通常会使用ZRANGE取出有序集合里包含的所有元素，\n[('a', 3.0), ('c', 4.0)]    \n```\n其他常用:    \n- zrevrank: zrevrank key-name member,返回有序集合成员member所处的位置，成员按照从大到小排列。\n- zrevrange: zrevrange key-name start stop [withscores],返回有序集合给定范围内的成员，成员按照分值由大到小排列。\n- zrangebyscore: zrangebyscore key min max [withscores] [limit offset count],获取有序集合分值介于min和max之间，并按照分值从大到小的顺序返回他们\n- zremrangebyrank: zremrangebyrank key-name start stop,移除有序集合排名介于start-stop之间的所有成员。\n- zremrangebyscore: zremrangebyscore key-name min max,移除有序集合中分值介于min-max之间的所有成员。\n- zinterstore: zinterstore dest-key key-count key [key...],给给定的有序集合执行集合的交集运算\n- zunionstore: zunionstore dest-key key-count key [key...],并集操作。\n\n```\n>>> def publisher(n):\n...     time.sleep(1)                                                   # 函数在刚开始执行时会先休眠，让订阅者有足够的时间来连接服务器并监听消息。\n...     for i in range(n):\n...         conn.publish('channel', i)                                  # 在发布消息之后进行短暂的休眠，\n...         time.sleep(1)                                               # 让消息可以一条接一条地出现。\n...\n>>> def run_pubsub():\n...     threading.Thread(target=publisher, args=(3,)).start()           # 启动发送者线程发送三条消息。\n...     pubsub = conn.pubsub()                                          # 创建发布与订阅对象，并让它订阅给定的频道。\n...     pubsub.subscribe(['channel'])                                   #\n...     count = 0\n...     for item in pubsub.listen():                                    # 通过遍历pubsub.listen()函数的执行结果来监听订阅消息。\n...         print(item)                                                  # 打印接收到的每条消息。\n...         count += 1                                                  # 在接收到一条订阅反馈消息和三条发布者发送的消息之后，\n...         if count == 4:                                              # 执行退订操作，停止监听新消息。\n...             pubsub.unsubscribe()                                    #\n...         if count == 5:                                              # 当客户端接收到退订反馈消息时，\n...             break                                                   # 需要停止接收消息。\n...\n>>> run_pubsub()                                                        # 实际运行函数并观察它们的行为。\n{'pattern': None, 'type': 'subscribe', 'channel': 'channel', 'data': 1L}# 在刚开始订阅一个频道的时候，客户端会接收到一条关于被订阅频道的反馈消息。\n{'pattern': None, 'type': 'message', 'channel': 'channel', 'data': '0'} # 这些结构就是我们在遍历pubsub.listen()函数时得到的元素。\n{'pattern': None, 'type': 'message', 'channel': 'channel', 'data': '1'} #\n{'pattern': None, 'type': 'message', 'channel': 'channel', 'data': '2'} #\n{'pattern': None, 'type': 'unsubscribe', 'channel': 'channel', 'data':  # 在退订频道时，客户端会接收到一条反馈消息，\n0L} \n```\n\n\ncurl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.23.0/minikube-darwin-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/\n\n\n","source":"_posts/redis.md","raw":"---\ntitle: redis\ndate: 2019-01-04 11:24:29\ntags: redis\ncatrgories: redis\n---\n\n#### 字符串\n\n在redis中，字符串可以存储三种类型的值    \n- 字节串(byte string)\n- 整数\n- 浮点数\n\n简单的自增命令，自减命令    \n- incr: 用法incr key-name，将键存储的值加1    \n- decr: 用法decr key-name，将键存储的值减1    \n- incrby: 用法 incrby key-name amount，将键对应的值加上amount    \n- decrby: 用法 decrby key-name amount,将键对应的值减去amount    \n- incrbyfloat: 用法incrbyfloat ket-name amount，将键存储的值加上浮点数amount，这个命令在redis2.6以上可用。    \n\n例子，在python解释器运行:\n```\n>>> conn = redis.Redis()\n>>> conn.get('key')  #尝试获取一个不存在的键值，得到None，终端不会显示\n>>> conn.incr('key')  #可对不存在的键来进行自增操作\n1\n>>> conn.incr('key', 15)\n16\n>>> conn.decr('key', 5)\n11\n>>> conn.get('key')  #尝试获取一个键时，命令以字符串格式返回被存储的整数\n11\n>>> conn.set('key', '20')\nTrue\n>>> conn.incr('key', 5)\n25\n```\n<!-- more -->\n其他命令:   \n- append: append key-name value，将提供的值value追加到给定键key-name当前存储值的末尾\n- getrange: getrange ket-name start end，获取一个由偏移量start-end内的所有字符组成的子串，start从0递增。\n- setrange: setrange key-name start value，将从start偏移量开始的子串设置为value。\n- getbit: getbit key-name offset，将字节串看做二进制串(bit string)，并返回串中偏移量为offset的二进制的值。\n- setbit: setbit keyname offset value，将字节串看为二进制串，并将串中偏移量为offset的值设为value\n\n例子:\n```\n>>> conn = redis.Redis()\n>>> conn.append('newstring', 'hello ')\n6\n>>> conn.get('newstring')\n'hello '\n>>> conn.getrange('newstring', 0, 2)\n'hel'\n>>> conn.setrange('newstring', 6, 'world')\n11\n>>> conn.setbit('anohter-key', 2, 1)\n0\n>>> conn.setbit('another-key', 7, 1)  #redis存储二进制位按照从高到低进行排列\n0\n>>> conn.get('another-key')\n'!'\n```\n\n#### 列表\n\nredis列表允许用户从序列的两端弹出或者推入元素。获取元素，执行列表操作，列表还可以用来存储任务信息，最近浏览过的文章和常用的联系人信息。常用命令如下\n\n- rpush: rpush key-name value [value...],将一个值或多个值从列表右端推入\n- lpush: 同上，从左边推入\n- rpop:  rpop key-name value,将一个值从列表右端弹出，并返回\n- lpop: 同上，从左边\n- lindex: lindex key-name offset,返回列表中偏移量为offset的元素\n- lrange: lrange key-name start end,返回列表中偏移量从start开始到end结束的所有元素\n- ltrim: ltrim key-name start end,对列表进行修剪，只保留start到end之间的元素，包括start和end\n\n例子:\n```\n>>> conn.rpush('list-key', 'last')          # 在向列表推入元素时，\n1L                                          # 推入操作执行完毕之后会返回列表当前的长度。\n>>> conn.lpush('list-key', 'first')         # 可以很容易地对列表的两端执行推入操作。\n2L\n>>> conn.rpush('list-key', 'new last')\n3L\n>>> conn.lrange('list-key', 0, -1)          # 从语义上来说，列表的左端为开头，右端为结尾。\n['first', 'last', 'new last']               #\n>>> conn.lpop('list-key')                   # 通过重复地弹出列表左端的元素，\n'first'                                     # 可以按照从左到右的顺序来获取列表中的元素。\n>>> conn.lpop('list-key')                   #\n'last'                                      #\n>>> conn.lrange('list-key', 0, -1)\n['new last']\n>>> conn.rpush('list-key', 'a', 'b', 'c')   # 可以同时推入多个元素。\n4L\n>>> conn.lrange('list-key', 0, -1)\n['new last', 'a', 'b', 'c']\n>>> conn.ltrim('list-key', 2, -1)           # 可以从列表的左端、右端或者左右两端删减任意数量的元素。\nTrue                                        #\n>>> conn.lrange('list-key', 0, -1)          #\n['b', 'c']\n```\n其他命令：    \n- blpop: blpop key-name [key-name] timeout,从第一个非空列表中弹出位于最左端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现。\n- brpop: brpop key-name [key-name] timeout,同上，但是弹出位于最右端的元素。\n- rpoplpush: rpoplpush source-key dest-key,从source-key列表中弹出位于最右端的元素，将这个元素推如到desk-key的最左端，并返回这个元素\n- brpoplpush: brpoplpush source-key dest-key,从source-key列表弹出最右端的元素，然后将这个元素推入到dest-key的最左端，并向用户返回这个元素，若source-key为空，那在timeout秒内阻塞并等待可弹出的元素出现。    \n\n例子,带有b可以设置timeout:\n```\n>>> conn.rpush('list', 'item1')             # 将一些元素添加到两个列表里面。\n1                                           #\n>>> conn.rpush('list', 'item2')             #\n2                                           #\n>>> conn.rpush('list2', 'item3')            #\n1                                           #\n>>> conn.brpoplpush('list2', 'list', 1)     # 将一个元素从一个列表移动到另一个列表，\n'item3'                                     # 并返回被移动的元素。\n>>> conn.brpoplpush('list2', 'list', 1)     # 当列表不包含任何元素时，阻塞弹出操作会在给定的时限内等待可弹出的元素出现，并在时限到达后返回None（交互终端不会打印这个值）。\n>>> conn.lrange('list', 0, -1)              # 弹出“list2”最右端的元素，\n['item3', 'item1', 'item2']                 # 并将弹出的元素推入到“list”的左端。\n>>> conn.brpoplpush('list', 'list2', 1)\n'item2'\n>>> conn.blpop(['list', 'list2'], 1)        # BLPOP命令会从左到右地检查传入的列表，\n('list', 'item3')                           # 并对最先遇到的非空列表执行弹出操作。\n>>> conn.blpop(['list', 'list2'], 1)        #\n('list', 'item1')                           #\n>>> conn.blpop(['list', 'list2'], 1)        #list空了，那么弹出list2的元素\n('list2', 'item2')                          #\n>>> conn.blpop(['list', 'list2'], 1)        #等待1s，没有元素可以弹出\n```\n\n对于阻塞弹出命令和弹出并且推入命令，最常见的技术消息传递(messageing)和任务队列(task queue)的开发\n\n#### 集合\n\nredis的集合以无序的方式来存储各个互不相同的元素，用户可以快速的对集合执行添加元素，移除元素，以及检验一个元素是否存在于集合的操作。常用的命令如下:\n\n- sadd: sadd key-name item [item...],将一个或者多个元素添加到集合中，并返回添加元素中原本不存在于集合里面的元素数量。\n- srem: srem key-name item [item...],从集合里面移除一个或者多个元素，并返回被移除元素的数量\n- sismember: sismember key-name item,检查item元素是否存在与集合key-name中\n- scard: scard key-name,返回集合中包含元素的数量\n- smembers: smembers key-name,返回集合所包含的元素\n- srandmember: srandmember key-name [count],从集合中随机返回一个或多个元素，当count为正数，命令返回的元素不会重复，当count为负数，命令返回的随机元素可能会重复。返回的数目为count的绝对值，若大于set所有元素的数量，则全部返回，负数则重复。\n- spop: spop key-name,从集合里面移除并且返回一个随机元素\n- smove: smove source-key dest-key item,如果集合source-key包含item,那么从集合source-key移除item，并且将item加入到dest-key中，如果item被成功移除，反应会1，否则返回0\n\n示例如下:\n```\n>>> conn.sadd('set-key', 'a', 'b', 'c')         # SADD命令会将那些目前并不存在于集合里面的元素添加到集合里面，\n3                                               # 并返回被添加元素的数量。\n>>> conn.srem('set-key', 'c', 'd')              # srem函数在元素被成功移除时返回True，\nTrue                                            # 移除失败时返回False；\n>>> conn.srem('set-key', 'c', 'd')              # 注意这是Python客户端的一个bug，\nFalse                                           # 实际上Redis的SREM命令返回的是被移除元素的数量，而不是布尔值。\n>>> conn.scard('set-key')                       # 查看集合包含的元素数量。\n2                                               #\n>>> conn.smembers('set-key')                    # 获取集合包含的所有元素。\nset(['a', 'b'])                                 #\n>>> conn.smove('set-key', 'set-key2', 'a')      # 可以很容易地将元素从一个集合移动到另一个集合。\nTrue                                            #\n>>> conn.smove('set-key', 'set-key2', 'c')      # 在执行SMOVE命令时，\nFalse                                           # 如果用户想要移动的元素不存在于第一个集合里，\n>>> conn.smembers('set-key2')                   # 那么移动操作就不会执行。\nset(['a'])   \n```\n\n如下是用于组合和处理多个集合的redis命令\n- sdiff: sdiff key-name [key-name],返回存在与第一个集合而不存在于其他集合的元素。(数学的差集运算)。\n- sdiffstore: sdiff dest-key key-name [key-name],将那些存在与第一个集合，而不存在于其他集合的元素存储到dest-key中。\n- sinter: sinter key-name [key-name],返回存在于所有集合中的元素，数学的交集运算\n- sinterstore: sinter dest-key key-name [key-name],同上，不过存储下来\n- sunion: sunion key-name [key-name],数学的并集\n- sunionstore: sunionstore dest-key key-name [key-name],交集并存储\n\n例子如下:\n```\n>>> conn.sadd('skey1', 'a', 'b', 'c', 'd')  # 首先将一些元素添加到两个集合里面。\n4                                           #\n>>> conn.sadd('skey2', 'c', 'd', 'e', 'f')  #\n4                                           #\n>>> conn.sdiff('skey1', 'skey2')            # 计算从第一个集合中移除第二个集合所有元素之后的结果。\nset(['a', 'b'])                             #\n>>> conn.sinter('skey1', 'skey2')           # 还可以找出同时存在于两个集合中的元素。\nset(['c', 'd'])                             #\n>>> conn.sunion('skey1', 'skey2')           # 可以找出两个结合中的所有元素。\nset(['a', 'c', 'b', 'e', 'd', 'f'])         #\n```\n\n#### 散列\n\nredis的三列可以让用户将多个键值对存储带一个redis里面，从功能上来说，redis为散列值提供了一些和字符串相同的特性。是的散列适用于将一些相关的数据存储到一起，我们可以吧这些数据聚集作为关系数据库的行，或者文档中存储的文档。    \n常用命令如下:\n- hmget: hmget key-name key [key...],从散列里面获取一个或者多个键的值\n- hmset: hmset key-name key value [key,value...],为散列里面的一个键或者多个键来设置值\n- hdel: hdel key-name key [key...],删除散列六面的一个或者多个键值对，返回成功找到并删除键值的数目。\n- hlen: hlen key-name,返回散列包含的键值对的数目    \n例子如下:\n```\n>>> conn.hmset('hash-key', {'k1':'v1', 'k2':'v2', 'k3':'v3'})   # 使用HMSET命令可以一次将多个键值对添加到散列里面。\nTrue                                                            #\n>>> conn.hmget('hash-key', ['k2', 'k3'])                        #  使用HMGET命令可以一次获取多个键的值。\n['v2', 'v3']                                                    #\n>>> conn.hlen('hash-key')                                       # HLEN命令通常用于调试一个包含非常多键值对的散列。\n3                                                               #\n>>> conn.hdel('hash-key', 'k1', 'k3')                           # HDEL命令在成功地移除了至少一个键值对时返回True，\nTrue \n```\n其他的常用批量操作的命令:    \n- hexists: hexists key-name key,检查给定键是否存在与散列之中\n- hkeys: hkeys key-name,获取散列包含的所有键\n- hvals: hvals key-name,获取散列包含的所有值\n- hgetall: hgetall key-name,获取散列包含的所有键值对\n- hincrby: hincrby key-name key increment,将键key的值加上整数increment\n- hincrfloat: hincrfloat key-name key increment,将键的值加上浮点数increment    \n\n例子如下:\n```\n>>> conn.hmset('hash-key2', {'short':'hello', 'long':1000*'1'}) # 在考察散列的时候，我们可以只取出散列包含的键，而不必传输大的键值。\nTrue                                                            #\n>>> conn.hkeys('hash-key2')                                     #\n['long', 'short']                                               #\n>>> conn.hexists('hash-key2', 'num')                            # 检查给定的键是否存在于散列中。\nFalse                                                           #\n>>> conn.hincrby('hash-key2', 'num')                            # 和字符串一样，\n1L                                                              # 对散列中一个尚未存在的键执行自增操作时，\n>>> conn.hexists('hash-key2', 'num')                            # Redis会将键的值当作0来处理。\nTrue  \n```\n\n#### 有序集合\n\n常用的有序集合的命令:\n- zadd: zadd key-name score number [score number],将带有给定值的成员添加到有序集合里面\n- zrem: zrem key-name member [member...],从有序集合移除给定的成员，并返回被移除成员的数目\n- zcard: zcard key-name,返回有序集合包含的成员的数目\n- zincrby: zincrby key-name increment member,将member的值加上increment\n- zcount: zcount key-name min max,返回分值介于min和max之间的成员\n- zrank: zrank key-name min max,返回成员member在key-name的排名\n- zscore: zscore key-name member ,返回成员member的值\n- zrange: zrange key-name start end [withscores],返回有序集合中排名介于start和end之间的成员，如果除了给定的可选的withscore选项，那么连成员的分值一并返回\n\n例子如下:\n```\n>>> conn.zadd('zset-key', {'a': 3, 'b': 2, 'c': 1})   # 在Python以字典输入\n3                                                   # 这跟Redis标准的先输入分值、后输入成员的做法正好相反。\n>>> conn.zcard('zset-key')                          # 取得有序集合的大小可以让我们在某些情况下知道是否需要对有序集合进行修剪。\n3                                                   #\n>>> conn.zincrby('zset-key', 'c', 3)                # 跟字符串和散列一样，\n4.0                                                 # 有序集合的成员也可以执行自增操作。\n>>> conn.zscore('zset-key', 'b')                    # 获取单个成员的分值对于实现计数器或者排行榜之类的功能非常有用。\n2.0                                                 #\n>>> conn.zrank('zset-key', 'c')                     # 获取指定成员的排名（排名以0为开始），\n2                                                   # 之后可以根据这个排名来决定ZRANGE的访问范围。\n>>> conn.zcount('zset-key', 0, 3)                   # 对于某些任务来说，\n2L                                                  # 统计给定分值范围内的元素数量非常有用。\n>>> conn.zrem('zset-key', 'b')                      # 从有序集合里面移除成员和添加成员一样容易。\nTrue                                                #\n>>> conn.zrange('zset-key', 0, -1, withscores=True) # 在进行调试时，我们通常会使用ZRANGE取出有序集合里包含的所有元素，\n[('a', 3.0), ('c', 4.0)]    \n```\n其他常用:    \n- zrevrank: zrevrank key-name member,返回有序集合成员member所处的位置，成员按照从大到小排列。\n- zrevrange: zrevrange key-name start stop [withscores],返回有序集合给定范围内的成员，成员按照分值由大到小排列。\n- zrangebyscore: zrangebyscore key min max [withscores] [limit offset count],获取有序集合分值介于min和max之间，并按照分值从大到小的顺序返回他们\n- zremrangebyrank: zremrangebyrank key-name start stop,移除有序集合排名介于start-stop之间的所有成员。\n- zremrangebyscore: zremrangebyscore key-name min max,移除有序集合中分值介于min-max之间的所有成员。\n- zinterstore: zinterstore dest-key key-count key [key...],给给定的有序集合执行集合的交集运算\n- zunionstore: zunionstore dest-key key-count key [key...],并集操作。\n\n```\n>>> def publisher(n):\n...     time.sleep(1)                                                   # 函数在刚开始执行时会先休眠，让订阅者有足够的时间来连接服务器并监听消息。\n...     for i in range(n):\n...         conn.publish('channel', i)                                  # 在发布消息之后进行短暂的休眠，\n...         time.sleep(1)                                               # 让消息可以一条接一条地出现。\n...\n>>> def run_pubsub():\n...     threading.Thread(target=publisher, args=(3,)).start()           # 启动发送者线程发送三条消息。\n...     pubsub = conn.pubsub()                                          # 创建发布与订阅对象，并让它订阅给定的频道。\n...     pubsub.subscribe(['channel'])                                   #\n...     count = 0\n...     for item in pubsub.listen():                                    # 通过遍历pubsub.listen()函数的执行结果来监听订阅消息。\n...         print(item)                                                  # 打印接收到的每条消息。\n...         count += 1                                                  # 在接收到一条订阅反馈消息和三条发布者发送的消息之后，\n...         if count == 4:                                              # 执行退订操作，停止监听新消息。\n...             pubsub.unsubscribe()                                    #\n...         if count == 5:                                              # 当客户端接收到退订反馈消息时，\n...             break                                                   # 需要停止接收消息。\n...\n>>> run_pubsub()                                                        # 实际运行函数并观察它们的行为。\n{'pattern': None, 'type': 'subscribe', 'channel': 'channel', 'data': 1L}# 在刚开始订阅一个频道的时候，客户端会接收到一条关于被订阅频道的反馈消息。\n{'pattern': None, 'type': 'message', 'channel': 'channel', 'data': '0'} # 这些结构就是我们在遍历pubsub.listen()函数时得到的元素。\n{'pattern': None, 'type': 'message', 'channel': 'channel', 'data': '1'} #\n{'pattern': None, 'type': 'message', 'channel': 'channel', 'data': '2'} #\n{'pattern': None, 'type': 'unsubscribe', 'channel': 'channel', 'data':  # 在退订频道时，客户端会接收到一条反馈消息，\n0L} \n```\n\n\ncurl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.23.0/minikube-darwin-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/\n\n\n","slug":"redis","published":1,"updated":"2022-05-20T02:24:20.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7o001mlae1xwkdvj7q","content":"<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><p>在redis中，字符串可以存储三种类型的值    </p>\n<ul>\n<li>字节串(byte string)</li>\n<li>整数</li>\n<li>浮点数</li>\n</ul>\n<p>简单的自增命令，自减命令    </p>\n<ul>\n<li>incr: 用法incr key-name，将键存储的值加1    </li>\n<li>decr: 用法decr key-name，将键存储的值减1    </li>\n<li>incrby: 用法 incrby key-name amount，将键对应的值加上amount    </li>\n<li>decrby: 用法 decrby key-name amount,将键对应的值减去amount    </li>\n<li>incrbyfloat: 用法incrbyfloat ket-name amount，将键存储的值加上浮点数amount，这个命令在redis2.6以上可用。    </li>\n</ul>\n<p>例子，在python解释器运行:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn = redis.Redis()</span><br><span class=\"line\">&gt;&gt;&gt; conn.get(&apos;key&apos;)  #尝试获取一个不存在的键值，得到None，终端不会显示</span><br><span class=\"line\">&gt;&gt;&gt; conn.incr(&apos;key&apos;)  #可对不存在的键来进行自增操作</span><br><span class=\"line\">1</span><br><span class=\"line\">&gt;&gt;&gt; conn.incr(&apos;key&apos;, 15)</span><br><span class=\"line\">16</span><br><span class=\"line\">&gt;&gt;&gt; conn.decr(&apos;key&apos;, 5)</span><br><span class=\"line\">11</span><br><span class=\"line\">&gt;&gt;&gt; conn.get(&apos;key&apos;)  #尝试获取一个键时，命令以字符串格式返回被存储的整数</span><br><span class=\"line\">11</span><br><span class=\"line\">&gt;&gt;&gt; conn.set(&apos;key&apos;, &apos;20&apos;)</span><br><span class=\"line\">True</span><br><span class=\"line\">&gt;&gt;&gt; conn.incr(&apos;key&apos;, 5)</span><br><span class=\"line\">25</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>其他命令:   </p>\n<ul>\n<li>append: append key-name value，将提供的值value追加到给定键key-name当前存储值的末尾</li>\n<li>getrange: getrange ket-name start end，获取一个由偏移量start-end内的所有字符组成的子串，start从0递增。</li>\n<li>setrange: setrange key-name start value，将从start偏移量开始的子串设置为value。</li>\n<li>getbit: getbit key-name offset，将字节串看做二进制串(bit string)，并返回串中偏移量为offset的二进制的值。</li>\n<li>setbit: setbit keyname offset value，将字节串看为二进制串，并将串中偏移量为offset的值设为value</li>\n</ul>\n<p>例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn = redis.Redis()</span><br><span class=\"line\">&gt;&gt;&gt; conn.append(&apos;newstring&apos;, &apos;hello &apos;)</span><br><span class=\"line\">6</span><br><span class=\"line\">&gt;&gt;&gt; conn.get(&apos;newstring&apos;)</span><br><span class=\"line\">&apos;hello &apos;</span><br><span class=\"line\">&gt;&gt;&gt; conn.getrange(&apos;newstring&apos;, 0, 2)</span><br><span class=\"line\">&apos;hel&apos;</span><br><span class=\"line\">&gt;&gt;&gt; conn.setrange(&apos;newstring&apos;, 6, &apos;world&apos;)</span><br><span class=\"line\">11</span><br><span class=\"line\">&gt;&gt;&gt; conn.setbit(&apos;anohter-key&apos;, 2, 1)</span><br><span class=\"line\">0</span><br><span class=\"line\">&gt;&gt;&gt; conn.setbit(&apos;another-key&apos;, 7, 1)  #redis存储二进制位按照从高到低进行排列</span><br><span class=\"line\">0</span><br><span class=\"line\">&gt;&gt;&gt; conn.get(&apos;another-key&apos;)</span><br><span class=\"line\">&apos;!&apos;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h4><p>redis列表允许用户从序列的两端弹出或者推入元素。获取元素，执行列表操作，列表还可以用来存储任务信息，最近浏览过的文章和常用的联系人信息。常用命令如下</p>\n<ul>\n<li>rpush: rpush key-name value [value…],将一个值或多个值从列表右端推入</li>\n<li>lpush: 同上，从左边推入</li>\n<li>rpop:  rpop key-name value,将一个值从列表右端弹出，并返回</li>\n<li>lpop: 同上，从左边</li>\n<li>lindex: lindex key-name offset,返回列表中偏移量为offset的元素</li>\n<li>lrange: lrange key-name start end,返回列表中偏移量从start开始到end结束的所有元素</li>\n<li>ltrim: ltrim key-name start end,对列表进行修剪，只保留start到end之间的元素，包括start和end</li>\n</ul>\n<p>例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.rpush(&apos;list-key&apos;, &apos;last&apos;)          # 在向列表推入元素时，</span><br><span class=\"line\">1L                                          # 推入操作执行完毕之后会返回列表当前的长度。</span><br><span class=\"line\">&gt;&gt;&gt; conn.lpush(&apos;list-key&apos;, &apos;first&apos;)         # 可以很容易地对列表的两端执行推入操作。</span><br><span class=\"line\">2L</span><br><span class=\"line\">&gt;&gt;&gt; conn.rpush(&apos;list-key&apos;, &apos;new last&apos;)</span><br><span class=\"line\">3L</span><br><span class=\"line\">&gt;&gt;&gt; conn.lrange(&apos;list-key&apos;, 0, -1)          # 从语义上来说，列表的左端为开头，右端为结尾。</span><br><span class=\"line\">[&apos;first&apos;, &apos;last&apos;, &apos;new last&apos;]               #</span><br><span class=\"line\">&gt;&gt;&gt; conn.lpop(&apos;list-key&apos;)                   # 通过重复地弹出列表左端的元素，</span><br><span class=\"line\">&apos;first&apos;                                     # 可以按照从左到右的顺序来获取列表中的元素。</span><br><span class=\"line\">&gt;&gt;&gt; conn.lpop(&apos;list-key&apos;)                   #</span><br><span class=\"line\">&apos;last&apos;                                      #</span><br><span class=\"line\">&gt;&gt;&gt; conn.lrange(&apos;list-key&apos;, 0, -1)</span><br><span class=\"line\">[&apos;new last&apos;]</span><br><span class=\"line\">&gt;&gt;&gt; conn.rpush(&apos;list-key&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;)   # 可以同时推入多个元素。</span><br><span class=\"line\">4L</span><br><span class=\"line\">&gt;&gt;&gt; conn.lrange(&apos;list-key&apos;, 0, -1)</span><br><span class=\"line\">[&apos;new last&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class=\"line\">&gt;&gt;&gt; conn.ltrim(&apos;list-key&apos;, 2, -1)           # 可以从列表的左端、右端或者左右两端删减任意数量的元素。</span><br><span class=\"line\">True                                        #</span><br><span class=\"line\">&gt;&gt;&gt; conn.lrange(&apos;list-key&apos;, 0, -1)          #</span><br><span class=\"line\">[&apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p>\n<p>其他命令：    </p>\n<ul>\n<li>blpop: blpop key-name [key-name] timeout,从第一个非空列表中弹出位于最左端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现。</li>\n<li>brpop: brpop key-name [key-name] timeout,同上，但是弹出位于最右端的元素。</li>\n<li>rpoplpush: rpoplpush source-key dest-key,从source-key列表中弹出位于最右端的元素，将这个元素推如到desk-key的最左端，并返回这个元素</li>\n<li>brpoplpush: brpoplpush source-key dest-key,从source-key列表弹出最右端的元素，然后将这个元素推入到dest-key的最左端，并向用户返回这个元素，若source-key为空，那在timeout秒内阻塞并等待可弹出的元素出现。    </li>\n</ul>\n<p>例子,带有b可以设置timeout:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.rpush(&apos;list&apos;, &apos;item1&apos;)             # 将一些元素添加到两个列表里面。</span><br><span class=\"line\">1                                           #</span><br><span class=\"line\">&gt;&gt;&gt; conn.rpush(&apos;list&apos;, &apos;item2&apos;)             #</span><br><span class=\"line\">2                                           #</span><br><span class=\"line\">&gt;&gt;&gt; conn.rpush(&apos;list2&apos;, &apos;item3&apos;)            #</span><br><span class=\"line\">1                                           #</span><br><span class=\"line\">&gt;&gt;&gt; conn.brpoplpush(&apos;list2&apos;, &apos;list&apos;, 1)     # 将一个元素从一个列表移动到另一个列表，</span><br><span class=\"line\">&apos;item3&apos;                                     # 并返回被移动的元素。</span><br><span class=\"line\">&gt;&gt;&gt; conn.brpoplpush(&apos;list2&apos;, &apos;list&apos;, 1)     # 当列表不包含任何元素时，阻塞弹出操作会在给定的时限内等待可弹出的元素出现，并在时限到达后返回None（交互终端不会打印这个值）。</span><br><span class=\"line\">&gt;&gt;&gt; conn.lrange(&apos;list&apos;, 0, -1)              # 弹出“list2”最右端的元素，</span><br><span class=\"line\">[&apos;item3&apos;, &apos;item1&apos;, &apos;item2&apos;]                 # 并将弹出的元素推入到“list”的左端。</span><br><span class=\"line\">&gt;&gt;&gt; conn.brpoplpush(&apos;list&apos;, &apos;list2&apos;, 1)</span><br><span class=\"line\">&apos;item2&apos;</span><br><span class=\"line\">&gt;&gt;&gt; conn.blpop([&apos;list&apos;, &apos;list2&apos;], 1)        # BLPOP命令会从左到右地检查传入的列表，</span><br><span class=\"line\">(&apos;list&apos;, &apos;item3&apos;)                           # 并对最先遇到的非空列表执行弹出操作。</span><br><span class=\"line\">&gt;&gt;&gt; conn.blpop([&apos;list&apos;, &apos;list2&apos;], 1)        #</span><br><span class=\"line\">(&apos;list&apos;, &apos;item1&apos;)                           #</span><br><span class=\"line\">&gt;&gt;&gt; conn.blpop([&apos;list&apos;, &apos;list2&apos;], 1)        #list空了，那么弹出list2的元素</span><br><span class=\"line\">(&apos;list2&apos;, &apos;item2&apos;)                          #</span><br><span class=\"line\">&gt;&gt;&gt; conn.blpop([&apos;list&apos;, &apos;list2&apos;], 1)        #等待1s，没有元素可以弹出</span><br></pre></td></tr></table></figure></p>\n<p>对于阻塞弹出命令和弹出并且推入命令，最常见的技术消息传递(messageing)和任务队列(task queue)的开发</p>\n<h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><p>redis的集合以无序的方式来存储各个互不相同的元素，用户可以快速的对集合执行添加元素，移除元素，以及检验一个元素是否存在于集合的操作。常用的命令如下:</p>\n<ul>\n<li>sadd: sadd key-name item [item…],将一个或者多个元素添加到集合中，并返回添加元素中原本不存在于集合里面的元素数量。</li>\n<li>srem: srem key-name item [item…],从集合里面移除一个或者多个元素，并返回被移除元素的数量</li>\n<li>sismember: sismember key-name item,检查item元素是否存在与集合key-name中</li>\n<li>scard: scard key-name,返回集合中包含元素的数量</li>\n<li>smembers: smembers key-name,返回集合所包含的元素</li>\n<li>srandmember: srandmember key-name [count],从集合中随机返回一个或多个元素，当count为正数，命令返回的元素不会重复，当count为负数，命令返回的随机元素可能会重复。返回的数目为count的绝对值，若大于set所有元素的数量，则全部返回，负数则重复。</li>\n<li>spop: spop key-name,从集合里面移除并且返回一个随机元素</li>\n<li>smove: smove source-key dest-key item,如果集合source-key包含item,那么从集合source-key移除item，并且将item加入到dest-key中，如果item被成功移除，反应会1，否则返回0</li>\n</ul>\n<p>示例如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.sadd(&apos;set-key&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;)         # SADD命令会将那些目前并不存在于集合里面的元素添加到集合里面，</span><br><span class=\"line\">3                                               # 并返回被添加元素的数量。</span><br><span class=\"line\">&gt;&gt;&gt; conn.srem(&apos;set-key&apos;, &apos;c&apos;, &apos;d&apos;)              # srem函数在元素被成功移除时返回True，</span><br><span class=\"line\">True                                            # 移除失败时返回False；</span><br><span class=\"line\">&gt;&gt;&gt; conn.srem(&apos;set-key&apos;, &apos;c&apos;, &apos;d&apos;)              # 注意这是Python客户端的一个bug，</span><br><span class=\"line\">False                                           # 实际上Redis的SREM命令返回的是被移除元素的数量，而不是布尔值。</span><br><span class=\"line\">&gt;&gt;&gt; conn.scard(&apos;set-key&apos;)                       # 查看集合包含的元素数量。</span><br><span class=\"line\">2                                               #</span><br><span class=\"line\">&gt;&gt;&gt; conn.smembers(&apos;set-key&apos;)                    # 获取集合包含的所有元素。</span><br><span class=\"line\">set([&apos;a&apos;, &apos;b&apos;])                                 #</span><br><span class=\"line\">&gt;&gt;&gt; conn.smove(&apos;set-key&apos;, &apos;set-key2&apos;, &apos;a&apos;)      # 可以很容易地将元素从一个集合移动到另一个集合。</span><br><span class=\"line\">True                                            #</span><br><span class=\"line\">&gt;&gt;&gt; conn.smove(&apos;set-key&apos;, &apos;set-key2&apos;, &apos;c&apos;)      # 在执行SMOVE命令时，</span><br><span class=\"line\">False                                           # 如果用户想要移动的元素不存在于第一个集合里，</span><br><span class=\"line\">&gt;&gt;&gt; conn.smembers(&apos;set-key2&apos;)                   # 那么移动操作就不会执行。</span><br><span class=\"line\">set([&apos;a&apos;])</span><br></pre></td></tr></table></figure></p>\n<p>如下是用于组合和处理多个集合的redis命令</p>\n<ul>\n<li>sdiff: sdiff key-name [key-name],返回存在与第一个集合而不存在于其他集合的元素。(数学的差集运算)。</li>\n<li>sdiffstore: sdiff dest-key key-name [key-name],将那些存在与第一个集合，而不存在于其他集合的元素存储到dest-key中。</li>\n<li>sinter: sinter key-name [key-name],返回存在于所有集合中的元素，数学的交集运算</li>\n<li>sinterstore: sinter dest-key key-name [key-name],同上，不过存储下来</li>\n<li>sunion: sunion key-name [key-name],数学的并集</li>\n<li>sunionstore: sunionstore dest-key key-name [key-name],交集并存储</li>\n</ul>\n<p>例子如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.sadd(&apos;skey1&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;)  # 首先将一些元素添加到两个集合里面。</span><br><span class=\"line\">4                                           #</span><br><span class=\"line\">&gt;&gt;&gt; conn.sadd(&apos;skey2&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;)  #</span><br><span class=\"line\">4                                           #</span><br><span class=\"line\">&gt;&gt;&gt; conn.sdiff(&apos;skey1&apos;, &apos;skey2&apos;)            # 计算从第一个集合中移除第二个集合所有元素之后的结果。</span><br><span class=\"line\">set([&apos;a&apos;, &apos;b&apos;])                             #</span><br><span class=\"line\">&gt;&gt;&gt; conn.sinter(&apos;skey1&apos;, &apos;skey2&apos;)           # 还可以找出同时存在于两个集合中的元素。</span><br><span class=\"line\">set([&apos;c&apos;, &apos;d&apos;])                             #</span><br><span class=\"line\">&gt;&gt;&gt; conn.sunion(&apos;skey1&apos;, &apos;skey2&apos;)           # 可以找出两个结合中的所有元素。</span><br><span class=\"line\">set([&apos;a&apos;, &apos;c&apos;, &apos;b&apos;, &apos;e&apos;, &apos;d&apos;, &apos;f&apos;])         #</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"散列\"><a href=\"#散列\" class=\"headerlink\" title=\"散列\"></a>散列</h4><p>redis的三列可以让用户将多个键值对存储带一个redis里面，从功能上来说，redis为散列值提供了一些和字符串相同的特性。是的散列适用于将一些相关的数据存储到一起，我们可以吧这些数据聚集作为关系数据库的行，或者文档中存储的文档。<br>常用命令如下:</p>\n<ul>\n<li>hmget: hmget key-name key [key…],从散列里面获取一个或者多个键的值</li>\n<li>hmset: hmset key-name key value [key,value…],为散列里面的一个键或者多个键来设置值</li>\n<li>hdel: hdel key-name key [key…],删除散列六面的一个或者多个键值对，返回成功找到并删除键值的数目。</li>\n<li>hlen: hlen key-name,返回散列包含的键值对的数目<br>例子如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.hmset(&apos;hash-key&apos;, &#123;&apos;k1&apos;:&apos;v1&apos;, &apos;k2&apos;:&apos;v2&apos;, &apos;k3&apos;:&apos;v3&apos;&#125;)   # 使用HMSET命令可以一次将多个键值对添加到散列里面。</span><br><span class=\"line\">True                                                            #</span><br><span class=\"line\">&gt;&gt;&gt; conn.hmget(&apos;hash-key&apos;, [&apos;k2&apos;, &apos;k3&apos;])                        #  使用HMGET命令可以一次获取多个键的值。</span><br><span class=\"line\">[&apos;v2&apos;, &apos;v3&apos;]                                                    #</span><br><span class=\"line\">&gt;&gt;&gt; conn.hlen(&apos;hash-key&apos;)                                       # HLEN命令通常用于调试一个包含非常多键值对的散列。</span><br><span class=\"line\">3                                                               #</span><br><span class=\"line\">&gt;&gt;&gt; conn.hdel(&apos;hash-key&apos;, &apos;k1&apos;, &apos;k3&apos;)                           # HDEL命令在成功地移除了至少一个键值对时返回True，</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>其他的常用批量操作的命令:    </p>\n<ul>\n<li>hexists: hexists key-name key,检查给定键是否存在与散列之中</li>\n<li>hkeys: hkeys key-name,获取散列包含的所有键</li>\n<li>hvals: hvals key-name,获取散列包含的所有值</li>\n<li>hgetall: hgetall key-name,获取散列包含的所有键值对</li>\n<li>hincrby: hincrby key-name key increment,将键key的值加上整数increment</li>\n<li>hincrfloat: hincrfloat key-name key increment,将键的值加上浮点数increment    </li>\n</ul>\n<p>例子如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.hmset(&apos;hash-key2&apos;, &#123;&apos;short&apos;:&apos;hello&apos;, &apos;long&apos;:1000*&apos;1&apos;&#125;) # 在考察散列的时候，我们可以只取出散列包含的键，而不必传输大的键值。</span><br><span class=\"line\">True                                                            #</span><br><span class=\"line\">&gt;&gt;&gt; conn.hkeys(&apos;hash-key2&apos;)                                     #</span><br><span class=\"line\">[&apos;long&apos;, &apos;short&apos;]                                               #</span><br><span class=\"line\">&gt;&gt;&gt; conn.hexists(&apos;hash-key2&apos;, &apos;num&apos;)                            # 检查给定的键是否存在于散列中。</span><br><span class=\"line\">False                                                           #</span><br><span class=\"line\">&gt;&gt;&gt; conn.hincrby(&apos;hash-key2&apos;, &apos;num&apos;)                            # 和字符串一样，</span><br><span class=\"line\">1L                                                              # 对散列中一个尚未存在的键执行自增操作时，</span><br><span class=\"line\">&gt;&gt;&gt; conn.hexists(&apos;hash-key2&apos;, &apos;num&apos;)                            # Redis会将键的值当作0来处理。</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"有序集合\"><a href=\"#有序集合\" class=\"headerlink\" title=\"有序集合\"></a>有序集合</h4><p>常用的有序集合的命令:</p>\n<ul>\n<li>zadd: zadd key-name score number [score number],将带有给定值的成员添加到有序集合里面</li>\n<li>zrem: zrem key-name member [member…],从有序集合移除给定的成员，并返回被移除成员的数目</li>\n<li>zcard: zcard key-name,返回有序集合包含的成员的数目</li>\n<li>zincrby: zincrby key-name increment member,将member的值加上increment</li>\n<li>zcount: zcount key-name min max,返回分值介于min和max之间的成员</li>\n<li>zrank: zrank key-name min max,返回成员member在key-name的排名</li>\n<li>zscore: zscore key-name member ,返回成员member的值</li>\n<li>zrange: zrange key-name start end [withscores],返回有序集合中排名介于start和end之间的成员，如果除了给定的可选的withscore选项，那么连成员的分值一并返回</li>\n</ul>\n<p>例子如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.zadd(&apos;zset-key&apos;, &#123;&apos;a&apos;: 3, &apos;b&apos;: 2, &apos;c&apos;: 1&#125;)   # 在Python以字典输入</span><br><span class=\"line\">3                                                   # 这跟Redis标准的先输入分值、后输入成员的做法正好相反。</span><br><span class=\"line\">&gt;&gt;&gt; conn.zcard(&apos;zset-key&apos;)                          # 取得有序集合的大小可以让我们在某些情况下知道是否需要对有序集合进行修剪。</span><br><span class=\"line\">3                                                   #</span><br><span class=\"line\">&gt;&gt;&gt; conn.zincrby(&apos;zset-key&apos;, &apos;c&apos;, 3)                # 跟字符串和散列一样，</span><br><span class=\"line\">4.0                                                 # 有序集合的成员也可以执行自增操作。</span><br><span class=\"line\">&gt;&gt;&gt; conn.zscore(&apos;zset-key&apos;, &apos;b&apos;)                    # 获取单个成员的分值对于实现计数器或者排行榜之类的功能非常有用。</span><br><span class=\"line\">2.0                                                 #</span><br><span class=\"line\">&gt;&gt;&gt; conn.zrank(&apos;zset-key&apos;, &apos;c&apos;)                     # 获取指定成员的排名（排名以0为开始），</span><br><span class=\"line\">2                                                   # 之后可以根据这个排名来决定ZRANGE的访问范围。</span><br><span class=\"line\">&gt;&gt;&gt; conn.zcount(&apos;zset-key&apos;, 0, 3)                   # 对于某些任务来说，</span><br><span class=\"line\">2L                                                  # 统计给定分值范围内的元素数量非常有用。</span><br><span class=\"line\">&gt;&gt;&gt; conn.zrem(&apos;zset-key&apos;, &apos;b&apos;)                      # 从有序集合里面移除成员和添加成员一样容易。</span><br><span class=\"line\">True                                                #</span><br><span class=\"line\">&gt;&gt;&gt; conn.zrange(&apos;zset-key&apos;, 0, -1, withscores=True) # 在进行调试时，我们通常会使用ZRANGE取出有序集合里包含的所有元素，</span><br><span class=\"line\">[(&apos;a&apos;, 3.0), (&apos;c&apos;, 4.0)]</span><br></pre></td></tr></table></figure></p>\n<p>其他常用:    </p>\n<ul>\n<li>zrevrank: zrevrank key-name member,返回有序集合成员member所处的位置，成员按照从大到小排列。</li>\n<li>zrevrange: zrevrange key-name start stop [withscores],返回有序集合给定范围内的成员，成员按照分值由大到小排列。</li>\n<li>zrangebyscore: zrangebyscore key min max [withscores] [limit offset count],获取有序集合分值介于min和max之间，并按照分值从大到小的顺序返回他们</li>\n<li>zremrangebyrank: zremrangebyrank key-name start stop,移除有序集合排名介于start-stop之间的所有成员。</li>\n<li>zremrangebyscore: zremrangebyscore key-name min max,移除有序集合中分值介于min-max之间的所有成员。</li>\n<li>zinterstore: zinterstore dest-key key-count key [key…],给给定的有序集合执行集合的交集运算</li>\n<li>zunionstore: zunionstore dest-key key-count key [key…],并集操作。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; def publisher(n):</span><br><span class=\"line\">...     time.sleep(1)                                                   # 函数在刚开始执行时会先休眠，让订阅者有足够的时间来连接服务器并监听消息。</span><br><span class=\"line\">...     for i in range(n):</span><br><span class=\"line\">...         conn.publish(&apos;channel&apos;, i)                                  # 在发布消息之后进行短暂的休眠，</span><br><span class=\"line\">...         time.sleep(1)                                               # 让消息可以一条接一条地出现。</span><br><span class=\"line\">...</span><br><span class=\"line\">&gt;&gt;&gt; def run_pubsub():</span><br><span class=\"line\">...     threading.Thread(target=publisher, args=(3,)).start()           # 启动发送者线程发送三条消息。</span><br><span class=\"line\">...     pubsub = conn.pubsub()                                          # 创建发布与订阅对象，并让它订阅给定的频道。</span><br><span class=\"line\">...     pubsub.subscribe([&apos;channel&apos;])                                   #</span><br><span class=\"line\">...     count = 0</span><br><span class=\"line\">...     for item in pubsub.listen():                                    # 通过遍历pubsub.listen()函数的执行结果来监听订阅消息。</span><br><span class=\"line\">...         print(item)                                                  # 打印接收到的每条消息。</span><br><span class=\"line\">...         count += 1                                                  # 在接收到一条订阅反馈消息和三条发布者发送的消息之后，</span><br><span class=\"line\">...         if count == 4:                                              # 执行退订操作，停止监听新消息。</span><br><span class=\"line\">...             pubsub.unsubscribe()                                    #</span><br><span class=\"line\">...         if count == 5:                                              # 当客户端接收到退订反馈消息时，</span><br><span class=\"line\">...             break                                                   # 需要停止接收消息。</span><br><span class=\"line\">...</span><br><span class=\"line\">&gt;&gt;&gt; run_pubsub()                                                        # 实际运行函数并观察它们的行为。</span><br><span class=\"line\">&#123;&apos;pattern&apos;: None, &apos;type&apos;: &apos;subscribe&apos;, &apos;channel&apos;: &apos;channel&apos;, &apos;data&apos;: 1L&#125;# 在刚开始订阅一个频道的时候，客户端会接收到一条关于被订阅频道的反馈消息。</span><br><span class=\"line\">&#123;&apos;pattern&apos;: None, &apos;type&apos;: &apos;message&apos;, &apos;channel&apos;: &apos;channel&apos;, &apos;data&apos;: &apos;0&apos;&#125; # 这些结构就是我们在遍历pubsub.listen()函数时得到的元素。</span><br><span class=\"line\">&#123;&apos;pattern&apos;: None, &apos;type&apos;: &apos;message&apos;, &apos;channel&apos;: &apos;channel&apos;, &apos;data&apos;: &apos;1&apos;&#125; #</span><br><span class=\"line\">&#123;&apos;pattern&apos;: None, &apos;type&apos;: &apos;message&apos;, &apos;channel&apos;: &apos;channel&apos;, &apos;data&apos;: &apos;2&apos;&#125; #</span><br><span class=\"line\">&#123;&apos;pattern&apos;: None, &apos;type&apos;: &apos;unsubscribe&apos;, &apos;channel&apos;: &apos;channel&apos;, &apos;data&apos;:  # 在退订频道时，客户端会接收到一条反馈消息，</span><br><span class=\"line\">0L&#125;</span><br></pre></td></tr></table></figure>\n<p>curl -Lo minikube <a href=\"https://storage.googleapis.com/minikube/releases/v0.23.0/minikube-darwin-amd64\" target=\"_blank\" rel=\"noopener\">https://storage.googleapis.com/minikube/releases/v0.23.0/minikube-darwin-amd64</a> &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><p>在redis中，字符串可以存储三种类型的值    </p>\n<ul>\n<li>字节串(byte string)</li>\n<li>整数</li>\n<li>浮点数</li>\n</ul>\n<p>简单的自增命令，自减命令    </p>\n<ul>\n<li>incr: 用法incr key-name，将键存储的值加1    </li>\n<li>decr: 用法decr key-name，将键存储的值减1    </li>\n<li>incrby: 用法 incrby key-name amount，将键对应的值加上amount    </li>\n<li>decrby: 用法 decrby key-name amount,将键对应的值减去amount    </li>\n<li>incrbyfloat: 用法incrbyfloat ket-name amount，将键存储的值加上浮点数amount，这个命令在redis2.6以上可用。    </li>\n</ul>\n<p>例子，在python解释器运行:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn = redis.Redis()</span><br><span class=\"line\">&gt;&gt;&gt; conn.get(&apos;key&apos;)  #尝试获取一个不存在的键值，得到None，终端不会显示</span><br><span class=\"line\">&gt;&gt;&gt; conn.incr(&apos;key&apos;)  #可对不存在的键来进行自增操作</span><br><span class=\"line\">1</span><br><span class=\"line\">&gt;&gt;&gt; conn.incr(&apos;key&apos;, 15)</span><br><span class=\"line\">16</span><br><span class=\"line\">&gt;&gt;&gt; conn.decr(&apos;key&apos;, 5)</span><br><span class=\"line\">11</span><br><span class=\"line\">&gt;&gt;&gt; conn.get(&apos;key&apos;)  #尝试获取一个键时，命令以字符串格式返回被存储的整数</span><br><span class=\"line\">11</span><br><span class=\"line\">&gt;&gt;&gt; conn.set(&apos;key&apos;, &apos;20&apos;)</span><br><span class=\"line\">True</span><br><span class=\"line\">&gt;&gt;&gt; conn.incr(&apos;key&apos;, 5)</span><br><span class=\"line\">25</span><br></pre></td></tr></table></figure></p>","more":"<p>其他命令:   </p>\n<ul>\n<li>append: append key-name value，将提供的值value追加到给定键key-name当前存储值的末尾</li>\n<li>getrange: getrange ket-name start end，获取一个由偏移量start-end内的所有字符组成的子串，start从0递增。</li>\n<li>setrange: setrange key-name start value，将从start偏移量开始的子串设置为value。</li>\n<li>getbit: getbit key-name offset，将字节串看做二进制串(bit string)，并返回串中偏移量为offset的二进制的值。</li>\n<li>setbit: setbit keyname offset value，将字节串看为二进制串，并将串中偏移量为offset的值设为value</li>\n</ul>\n<p>例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn = redis.Redis()</span><br><span class=\"line\">&gt;&gt;&gt; conn.append(&apos;newstring&apos;, &apos;hello &apos;)</span><br><span class=\"line\">6</span><br><span class=\"line\">&gt;&gt;&gt; conn.get(&apos;newstring&apos;)</span><br><span class=\"line\">&apos;hello &apos;</span><br><span class=\"line\">&gt;&gt;&gt; conn.getrange(&apos;newstring&apos;, 0, 2)</span><br><span class=\"line\">&apos;hel&apos;</span><br><span class=\"line\">&gt;&gt;&gt; conn.setrange(&apos;newstring&apos;, 6, &apos;world&apos;)</span><br><span class=\"line\">11</span><br><span class=\"line\">&gt;&gt;&gt; conn.setbit(&apos;anohter-key&apos;, 2, 1)</span><br><span class=\"line\">0</span><br><span class=\"line\">&gt;&gt;&gt; conn.setbit(&apos;another-key&apos;, 7, 1)  #redis存储二进制位按照从高到低进行排列</span><br><span class=\"line\">0</span><br><span class=\"line\">&gt;&gt;&gt; conn.get(&apos;another-key&apos;)</span><br><span class=\"line\">&apos;!&apos;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h4><p>redis列表允许用户从序列的两端弹出或者推入元素。获取元素，执行列表操作，列表还可以用来存储任务信息，最近浏览过的文章和常用的联系人信息。常用命令如下</p>\n<ul>\n<li>rpush: rpush key-name value [value…],将一个值或多个值从列表右端推入</li>\n<li>lpush: 同上，从左边推入</li>\n<li>rpop:  rpop key-name value,将一个值从列表右端弹出，并返回</li>\n<li>lpop: 同上，从左边</li>\n<li>lindex: lindex key-name offset,返回列表中偏移量为offset的元素</li>\n<li>lrange: lrange key-name start end,返回列表中偏移量从start开始到end结束的所有元素</li>\n<li>ltrim: ltrim key-name start end,对列表进行修剪，只保留start到end之间的元素，包括start和end</li>\n</ul>\n<p>例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.rpush(&apos;list-key&apos;, &apos;last&apos;)          # 在向列表推入元素时，</span><br><span class=\"line\">1L                                          # 推入操作执行完毕之后会返回列表当前的长度。</span><br><span class=\"line\">&gt;&gt;&gt; conn.lpush(&apos;list-key&apos;, &apos;first&apos;)         # 可以很容易地对列表的两端执行推入操作。</span><br><span class=\"line\">2L</span><br><span class=\"line\">&gt;&gt;&gt; conn.rpush(&apos;list-key&apos;, &apos;new last&apos;)</span><br><span class=\"line\">3L</span><br><span class=\"line\">&gt;&gt;&gt; conn.lrange(&apos;list-key&apos;, 0, -1)          # 从语义上来说，列表的左端为开头，右端为结尾。</span><br><span class=\"line\">[&apos;first&apos;, &apos;last&apos;, &apos;new last&apos;]               #</span><br><span class=\"line\">&gt;&gt;&gt; conn.lpop(&apos;list-key&apos;)                   # 通过重复地弹出列表左端的元素，</span><br><span class=\"line\">&apos;first&apos;                                     # 可以按照从左到右的顺序来获取列表中的元素。</span><br><span class=\"line\">&gt;&gt;&gt; conn.lpop(&apos;list-key&apos;)                   #</span><br><span class=\"line\">&apos;last&apos;                                      #</span><br><span class=\"line\">&gt;&gt;&gt; conn.lrange(&apos;list-key&apos;, 0, -1)</span><br><span class=\"line\">[&apos;new last&apos;]</span><br><span class=\"line\">&gt;&gt;&gt; conn.rpush(&apos;list-key&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;)   # 可以同时推入多个元素。</span><br><span class=\"line\">4L</span><br><span class=\"line\">&gt;&gt;&gt; conn.lrange(&apos;list-key&apos;, 0, -1)</span><br><span class=\"line\">[&apos;new last&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class=\"line\">&gt;&gt;&gt; conn.ltrim(&apos;list-key&apos;, 2, -1)           # 可以从列表的左端、右端或者左右两端删减任意数量的元素。</span><br><span class=\"line\">True                                        #</span><br><span class=\"line\">&gt;&gt;&gt; conn.lrange(&apos;list-key&apos;, 0, -1)          #</span><br><span class=\"line\">[&apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p>\n<p>其他命令：    </p>\n<ul>\n<li>blpop: blpop key-name [key-name] timeout,从第一个非空列表中弹出位于最左端的元素，或者在timeout秒之内阻塞并等待可弹出的元素出现。</li>\n<li>brpop: brpop key-name [key-name] timeout,同上，但是弹出位于最右端的元素。</li>\n<li>rpoplpush: rpoplpush source-key dest-key,从source-key列表中弹出位于最右端的元素，将这个元素推如到desk-key的最左端，并返回这个元素</li>\n<li>brpoplpush: brpoplpush source-key dest-key,从source-key列表弹出最右端的元素，然后将这个元素推入到dest-key的最左端，并向用户返回这个元素，若source-key为空，那在timeout秒内阻塞并等待可弹出的元素出现。    </li>\n</ul>\n<p>例子,带有b可以设置timeout:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.rpush(&apos;list&apos;, &apos;item1&apos;)             # 将一些元素添加到两个列表里面。</span><br><span class=\"line\">1                                           #</span><br><span class=\"line\">&gt;&gt;&gt; conn.rpush(&apos;list&apos;, &apos;item2&apos;)             #</span><br><span class=\"line\">2                                           #</span><br><span class=\"line\">&gt;&gt;&gt; conn.rpush(&apos;list2&apos;, &apos;item3&apos;)            #</span><br><span class=\"line\">1                                           #</span><br><span class=\"line\">&gt;&gt;&gt; conn.brpoplpush(&apos;list2&apos;, &apos;list&apos;, 1)     # 将一个元素从一个列表移动到另一个列表，</span><br><span class=\"line\">&apos;item3&apos;                                     # 并返回被移动的元素。</span><br><span class=\"line\">&gt;&gt;&gt; conn.brpoplpush(&apos;list2&apos;, &apos;list&apos;, 1)     # 当列表不包含任何元素时，阻塞弹出操作会在给定的时限内等待可弹出的元素出现，并在时限到达后返回None（交互终端不会打印这个值）。</span><br><span class=\"line\">&gt;&gt;&gt; conn.lrange(&apos;list&apos;, 0, -1)              # 弹出“list2”最右端的元素，</span><br><span class=\"line\">[&apos;item3&apos;, &apos;item1&apos;, &apos;item2&apos;]                 # 并将弹出的元素推入到“list”的左端。</span><br><span class=\"line\">&gt;&gt;&gt; conn.brpoplpush(&apos;list&apos;, &apos;list2&apos;, 1)</span><br><span class=\"line\">&apos;item2&apos;</span><br><span class=\"line\">&gt;&gt;&gt; conn.blpop([&apos;list&apos;, &apos;list2&apos;], 1)        # BLPOP命令会从左到右地检查传入的列表，</span><br><span class=\"line\">(&apos;list&apos;, &apos;item3&apos;)                           # 并对最先遇到的非空列表执行弹出操作。</span><br><span class=\"line\">&gt;&gt;&gt; conn.blpop([&apos;list&apos;, &apos;list2&apos;], 1)        #</span><br><span class=\"line\">(&apos;list&apos;, &apos;item1&apos;)                           #</span><br><span class=\"line\">&gt;&gt;&gt; conn.blpop([&apos;list&apos;, &apos;list2&apos;], 1)        #list空了，那么弹出list2的元素</span><br><span class=\"line\">(&apos;list2&apos;, &apos;item2&apos;)                          #</span><br><span class=\"line\">&gt;&gt;&gt; conn.blpop([&apos;list&apos;, &apos;list2&apos;], 1)        #等待1s，没有元素可以弹出</span><br></pre></td></tr></table></figure></p>\n<p>对于阻塞弹出命令和弹出并且推入命令，最常见的技术消息传递(messageing)和任务队列(task queue)的开发</p>\n<h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><p>redis的集合以无序的方式来存储各个互不相同的元素，用户可以快速的对集合执行添加元素，移除元素，以及检验一个元素是否存在于集合的操作。常用的命令如下:</p>\n<ul>\n<li>sadd: sadd key-name item [item…],将一个或者多个元素添加到集合中，并返回添加元素中原本不存在于集合里面的元素数量。</li>\n<li>srem: srem key-name item [item…],从集合里面移除一个或者多个元素，并返回被移除元素的数量</li>\n<li>sismember: sismember key-name item,检查item元素是否存在与集合key-name中</li>\n<li>scard: scard key-name,返回集合中包含元素的数量</li>\n<li>smembers: smembers key-name,返回集合所包含的元素</li>\n<li>srandmember: srandmember key-name [count],从集合中随机返回一个或多个元素，当count为正数，命令返回的元素不会重复，当count为负数，命令返回的随机元素可能会重复。返回的数目为count的绝对值，若大于set所有元素的数量，则全部返回，负数则重复。</li>\n<li>spop: spop key-name,从集合里面移除并且返回一个随机元素</li>\n<li>smove: smove source-key dest-key item,如果集合source-key包含item,那么从集合source-key移除item，并且将item加入到dest-key中，如果item被成功移除，反应会1，否则返回0</li>\n</ul>\n<p>示例如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.sadd(&apos;set-key&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;)         # SADD命令会将那些目前并不存在于集合里面的元素添加到集合里面，</span><br><span class=\"line\">3                                               # 并返回被添加元素的数量。</span><br><span class=\"line\">&gt;&gt;&gt; conn.srem(&apos;set-key&apos;, &apos;c&apos;, &apos;d&apos;)              # srem函数在元素被成功移除时返回True，</span><br><span class=\"line\">True                                            # 移除失败时返回False；</span><br><span class=\"line\">&gt;&gt;&gt; conn.srem(&apos;set-key&apos;, &apos;c&apos;, &apos;d&apos;)              # 注意这是Python客户端的一个bug，</span><br><span class=\"line\">False                                           # 实际上Redis的SREM命令返回的是被移除元素的数量，而不是布尔值。</span><br><span class=\"line\">&gt;&gt;&gt; conn.scard(&apos;set-key&apos;)                       # 查看集合包含的元素数量。</span><br><span class=\"line\">2                                               #</span><br><span class=\"line\">&gt;&gt;&gt; conn.smembers(&apos;set-key&apos;)                    # 获取集合包含的所有元素。</span><br><span class=\"line\">set([&apos;a&apos;, &apos;b&apos;])                                 #</span><br><span class=\"line\">&gt;&gt;&gt; conn.smove(&apos;set-key&apos;, &apos;set-key2&apos;, &apos;a&apos;)      # 可以很容易地将元素从一个集合移动到另一个集合。</span><br><span class=\"line\">True                                            #</span><br><span class=\"line\">&gt;&gt;&gt; conn.smove(&apos;set-key&apos;, &apos;set-key2&apos;, &apos;c&apos;)      # 在执行SMOVE命令时，</span><br><span class=\"line\">False                                           # 如果用户想要移动的元素不存在于第一个集合里，</span><br><span class=\"line\">&gt;&gt;&gt; conn.smembers(&apos;set-key2&apos;)                   # 那么移动操作就不会执行。</span><br><span class=\"line\">set([&apos;a&apos;])</span><br></pre></td></tr></table></figure></p>\n<p>如下是用于组合和处理多个集合的redis命令</p>\n<ul>\n<li>sdiff: sdiff key-name [key-name],返回存在与第一个集合而不存在于其他集合的元素。(数学的差集运算)。</li>\n<li>sdiffstore: sdiff dest-key key-name [key-name],将那些存在与第一个集合，而不存在于其他集合的元素存储到dest-key中。</li>\n<li>sinter: sinter key-name [key-name],返回存在于所有集合中的元素，数学的交集运算</li>\n<li>sinterstore: sinter dest-key key-name [key-name],同上，不过存储下来</li>\n<li>sunion: sunion key-name [key-name],数学的并集</li>\n<li>sunionstore: sunionstore dest-key key-name [key-name],交集并存储</li>\n</ul>\n<p>例子如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.sadd(&apos;skey1&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;)  # 首先将一些元素添加到两个集合里面。</span><br><span class=\"line\">4                                           #</span><br><span class=\"line\">&gt;&gt;&gt; conn.sadd(&apos;skey2&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;)  #</span><br><span class=\"line\">4                                           #</span><br><span class=\"line\">&gt;&gt;&gt; conn.sdiff(&apos;skey1&apos;, &apos;skey2&apos;)            # 计算从第一个集合中移除第二个集合所有元素之后的结果。</span><br><span class=\"line\">set([&apos;a&apos;, &apos;b&apos;])                             #</span><br><span class=\"line\">&gt;&gt;&gt; conn.sinter(&apos;skey1&apos;, &apos;skey2&apos;)           # 还可以找出同时存在于两个集合中的元素。</span><br><span class=\"line\">set([&apos;c&apos;, &apos;d&apos;])                             #</span><br><span class=\"line\">&gt;&gt;&gt; conn.sunion(&apos;skey1&apos;, &apos;skey2&apos;)           # 可以找出两个结合中的所有元素。</span><br><span class=\"line\">set([&apos;a&apos;, &apos;c&apos;, &apos;b&apos;, &apos;e&apos;, &apos;d&apos;, &apos;f&apos;])         #</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"散列\"><a href=\"#散列\" class=\"headerlink\" title=\"散列\"></a>散列</h4><p>redis的三列可以让用户将多个键值对存储带一个redis里面，从功能上来说，redis为散列值提供了一些和字符串相同的特性。是的散列适用于将一些相关的数据存储到一起，我们可以吧这些数据聚集作为关系数据库的行，或者文档中存储的文档。<br>常用命令如下:</p>\n<ul>\n<li>hmget: hmget key-name key [key…],从散列里面获取一个或者多个键的值</li>\n<li>hmset: hmset key-name key value [key,value…],为散列里面的一个键或者多个键来设置值</li>\n<li>hdel: hdel key-name key [key…],删除散列六面的一个或者多个键值对，返回成功找到并删除键值的数目。</li>\n<li>hlen: hlen key-name,返回散列包含的键值对的数目<br>例子如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.hmset(&apos;hash-key&apos;, &#123;&apos;k1&apos;:&apos;v1&apos;, &apos;k2&apos;:&apos;v2&apos;, &apos;k3&apos;:&apos;v3&apos;&#125;)   # 使用HMSET命令可以一次将多个键值对添加到散列里面。</span><br><span class=\"line\">True                                                            #</span><br><span class=\"line\">&gt;&gt;&gt; conn.hmget(&apos;hash-key&apos;, [&apos;k2&apos;, &apos;k3&apos;])                        #  使用HMGET命令可以一次获取多个键的值。</span><br><span class=\"line\">[&apos;v2&apos;, &apos;v3&apos;]                                                    #</span><br><span class=\"line\">&gt;&gt;&gt; conn.hlen(&apos;hash-key&apos;)                                       # HLEN命令通常用于调试一个包含非常多键值对的散列。</span><br><span class=\"line\">3                                                               #</span><br><span class=\"line\">&gt;&gt;&gt; conn.hdel(&apos;hash-key&apos;, &apos;k1&apos;, &apos;k3&apos;)                           # HDEL命令在成功地移除了至少一个键值对时返回True，</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>其他的常用批量操作的命令:    </p>\n<ul>\n<li>hexists: hexists key-name key,检查给定键是否存在与散列之中</li>\n<li>hkeys: hkeys key-name,获取散列包含的所有键</li>\n<li>hvals: hvals key-name,获取散列包含的所有值</li>\n<li>hgetall: hgetall key-name,获取散列包含的所有键值对</li>\n<li>hincrby: hincrby key-name key increment,将键key的值加上整数increment</li>\n<li>hincrfloat: hincrfloat key-name key increment,将键的值加上浮点数increment    </li>\n</ul>\n<p>例子如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.hmset(&apos;hash-key2&apos;, &#123;&apos;short&apos;:&apos;hello&apos;, &apos;long&apos;:1000*&apos;1&apos;&#125;) # 在考察散列的时候，我们可以只取出散列包含的键，而不必传输大的键值。</span><br><span class=\"line\">True                                                            #</span><br><span class=\"line\">&gt;&gt;&gt; conn.hkeys(&apos;hash-key2&apos;)                                     #</span><br><span class=\"line\">[&apos;long&apos;, &apos;short&apos;]                                               #</span><br><span class=\"line\">&gt;&gt;&gt; conn.hexists(&apos;hash-key2&apos;, &apos;num&apos;)                            # 检查给定的键是否存在于散列中。</span><br><span class=\"line\">False                                                           #</span><br><span class=\"line\">&gt;&gt;&gt; conn.hincrby(&apos;hash-key2&apos;, &apos;num&apos;)                            # 和字符串一样，</span><br><span class=\"line\">1L                                                              # 对散列中一个尚未存在的键执行自增操作时，</span><br><span class=\"line\">&gt;&gt;&gt; conn.hexists(&apos;hash-key2&apos;, &apos;num&apos;)                            # Redis会将键的值当作0来处理。</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"有序集合\"><a href=\"#有序集合\" class=\"headerlink\" title=\"有序集合\"></a>有序集合</h4><p>常用的有序集合的命令:</p>\n<ul>\n<li>zadd: zadd key-name score number [score number],将带有给定值的成员添加到有序集合里面</li>\n<li>zrem: zrem key-name member [member…],从有序集合移除给定的成员，并返回被移除成员的数目</li>\n<li>zcard: zcard key-name,返回有序集合包含的成员的数目</li>\n<li>zincrby: zincrby key-name increment member,将member的值加上increment</li>\n<li>zcount: zcount key-name min max,返回分值介于min和max之间的成员</li>\n<li>zrank: zrank key-name min max,返回成员member在key-name的排名</li>\n<li>zscore: zscore key-name member ,返回成员member的值</li>\n<li>zrange: zrange key-name start end [withscores],返回有序集合中排名介于start和end之间的成员，如果除了给定的可选的withscore选项，那么连成员的分值一并返回</li>\n</ul>\n<p>例子如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; conn.zadd(&apos;zset-key&apos;, &#123;&apos;a&apos;: 3, &apos;b&apos;: 2, &apos;c&apos;: 1&#125;)   # 在Python以字典输入</span><br><span class=\"line\">3                                                   # 这跟Redis标准的先输入分值、后输入成员的做法正好相反。</span><br><span class=\"line\">&gt;&gt;&gt; conn.zcard(&apos;zset-key&apos;)                          # 取得有序集合的大小可以让我们在某些情况下知道是否需要对有序集合进行修剪。</span><br><span class=\"line\">3                                                   #</span><br><span class=\"line\">&gt;&gt;&gt; conn.zincrby(&apos;zset-key&apos;, &apos;c&apos;, 3)                # 跟字符串和散列一样，</span><br><span class=\"line\">4.0                                                 # 有序集合的成员也可以执行自增操作。</span><br><span class=\"line\">&gt;&gt;&gt; conn.zscore(&apos;zset-key&apos;, &apos;b&apos;)                    # 获取单个成员的分值对于实现计数器或者排行榜之类的功能非常有用。</span><br><span class=\"line\">2.0                                                 #</span><br><span class=\"line\">&gt;&gt;&gt; conn.zrank(&apos;zset-key&apos;, &apos;c&apos;)                     # 获取指定成员的排名（排名以0为开始），</span><br><span class=\"line\">2                                                   # 之后可以根据这个排名来决定ZRANGE的访问范围。</span><br><span class=\"line\">&gt;&gt;&gt; conn.zcount(&apos;zset-key&apos;, 0, 3)                   # 对于某些任务来说，</span><br><span class=\"line\">2L                                                  # 统计给定分值范围内的元素数量非常有用。</span><br><span class=\"line\">&gt;&gt;&gt; conn.zrem(&apos;zset-key&apos;, &apos;b&apos;)                      # 从有序集合里面移除成员和添加成员一样容易。</span><br><span class=\"line\">True                                                #</span><br><span class=\"line\">&gt;&gt;&gt; conn.zrange(&apos;zset-key&apos;, 0, -1, withscores=True) # 在进行调试时，我们通常会使用ZRANGE取出有序集合里包含的所有元素，</span><br><span class=\"line\">[(&apos;a&apos;, 3.0), (&apos;c&apos;, 4.0)]</span><br></pre></td></tr></table></figure></p>\n<p>其他常用:    </p>\n<ul>\n<li>zrevrank: zrevrank key-name member,返回有序集合成员member所处的位置，成员按照从大到小排列。</li>\n<li>zrevrange: zrevrange key-name start stop [withscores],返回有序集合给定范围内的成员，成员按照分值由大到小排列。</li>\n<li>zrangebyscore: zrangebyscore key min max [withscores] [limit offset count],获取有序集合分值介于min和max之间，并按照分值从大到小的顺序返回他们</li>\n<li>zremrangebyrank: zremrangebyrank key-name start stop,移除有序集合排名介于start-stop之间的所有成员。</li>\n<li>zremrangebyscore: zremrangebyscore key-name min max,移除有序集合中分值介于min-max之间的所有成员。</li>\n<li>zinterstore: zinterstore dest-key key-count key [key…],给给定的有序集合执行集合的交集运算</li>\n<li>zunionstore: zunionstore dest-key key-count key [key…],并集操作。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; def publisher(n):</span><br><span class=\"line\">...     time.sleep(1)                                                   # 函数在刚开始执行时会先休眠，让订阅者有足够的时间来连接服务器并监听消息。</span><br><span class=\"line\">...     for i in range(n):</span><br><span class=\"line\">...         conn.publish(&apos;channel&apos;, i)                                  # 在发布消息之后进行短暂的休眠，</span><br><span class=\"line\">...         time.sleep(1)                                               # 让消息可以一条接一条地出现。</span><br><span class=\"line\">...</span><br><span class=\"line\">&gt;&gt;&gt; def run_pubsub():</span><br><span class=\"line\">...     threading.Thread(target=publisher, args=(3,)).start()           # 启动发送者线程发送三条消息。</span><br><span class=\"line\">...     pubsub = conn.pubsub()                                          # 创建发布与订阅对象，并让它订阅给定的频道。</span><br><span class=\"line\">...     pubsub.subscribe([&apos;channel&apos;])                                   #</span><br><span class=\"line\">...     count = 0</span><br><span class=\"line\">...     for item in pubsub.listen():                                    # 通过遍历pubsub.listen()函数的执行结果来监听订阅消息。</span><br><span class=\"line\">...         print(item)                                                  # 打印接收到的每条消息。</span><br><span class=\"line\">...         count += 1                                                  # 在接收到一条订阅反馈消息和三条发布者发送的消息之后，</span><br><span class=\"line\">...         if count == 4:                                              # 执行退订操作，停止监听新消息。</span><br><span class=\"line\">...             pubsub.unsubscribe()                                    #</span><br><span class=\"line\">...         if count == 5:                                              # 当客户端接收到退订反馈消息时，</span><br><span class=\"line\">...             break                                                   # 需要停止接收消息。</span><br><span class=\"line\">...</span><br><span class=\"line\">&gt;&gt;&gt; run_pubsub()                                                        # 实际运行函数并观察它们的行为。</span><br><span class=\"line\">&#123;&apos;pattern&apos;: None, &apos;type&apos;: &apos;subscribe&apos;, &apos;channel&apos;: &apos;channel&apos;, &apos;data&apos;: 1L&#125;# 在刚开始订阅一个频道的时候，客户端会接收到一条关于被订阅频道的反馈消息。</span><br><span class=\"line\">&#123;&apos;pattern&apos;: None, &apos;type&apos;: &apos;message&apos;, &apos;channel&apos;: &apos;channel&apos;, &apos;data&apos;: &apos;0&apos;&#125; # 这些结构就是我们在遍历pubsub.listen()函数时得到的元素。</span><br><span class=\"line\">&#123;&apos;pattern&apos;: None, &apos;type&apos;: &apos;message&apos;, &apos;channel&apos;: &apos;channel&apos;, &apos;data&apos;: &apos;1&apos;&#125; #</span><br><span class=\"line\">&#123;&apos;pattern&apos;: None, &apos;type&apos;: &apos;message&apos;, &apos;channel&apos;: &apos;channel&apos;, &apos;data&apos;: &apos;2&apos;&#125; #</span><br><span class=\"line\">&#123;&apos;pattern&apos;: None, &apos;type&apos;: &apos;unsubscribe&apos;, &apos;channel&apos;: &apos;channel&apos;, &apos;data&apos;:  # 在退订频道时，客户端会接收到一条反馈消息，</span><br><span class=\"line\">0L&#125;</span><br></pre></td></tr></table></figure>\n<p>curl -Lo minikube <a href=\"https://storage.googleapis.com/minikube/releases/v0.23.0/minikube-darwin-amd64\" target=\"_blank\" rel=\"noopener\">https://storage.googleapis.com/minikube/releases/v0.23.0/minikube-darwin-amd64</a> &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/</p>"},{"layout":"posts","title":"redis事务2","date":"2019-02-25T14:39:06.000Z","_content":"### redis事务\n为了保证数据的正确性，确认一点:在多个客户端同时处理相同的数据时候，不谨慎的操作会导致数据出错。下面介绍使用redis事务来防止数据出错的方法，以及事务来提升性能的方法。    \nredis的事务和传统关系数据库事务并不同，在传统关系数据库中，用户先向数据库服务器发送BEGIN，然后执行各个相互一致(consistent)的写操作和读操作，最后用户选择COMMIT来确认之前所做的更改，或者发送ROLLBACK来放弃修改。    \n在redis也可一处理一连串相互一致的读操作和写操作。redis的事务以MULTI开始，之后跟着用户传入的多个命令，最后以EXEC为结束。但是这种简单的操作在调用EXEC命令之前不会执行任何实际的操作，所以用户没办法根据读到的数据做决定。    \n以例子来说明。下图展示了游戏中用于表示用户信息和用户包裹的结构，用户信息存储在散列用户报国使用一个集合来表示。\n<!-- more -->\n<div style=\"width: 200px; margin: auto\">![示例图片](/images/redis-transcation1.bmp)</div>\n\n买卖市场的需求:一个用户(卖家)可以将商品放到市场上进行销售，当一个用户(买家)购买时，卖家会收到钱。为了将被销售商品的全部信息存储到市场里面，我们将会把商品id和卖家id拼接在一起，并将拼接结果作为成员存储到市场的有序集合如下图所示\n\n<div style=\"width: 200px; margin: auto\">![示例图片](/images/redis-transcation2.bmp)</div>\n\n#### 将商品放到市场上销售\n\n为了将商品放到市场上销售，程序出了用到MULTI和EXEC命令之外，需要配合使用WATCH命令，有时甚至会用到UNWATCH和DISCARD(丢弃)。在用户使用WATCH对键进行监听后，直到用户执行EXEC这段时间里，如果有其他的客户端抢险对任何被监视的键进行了替换，更新，删除等操作，那么当用户尝试执行EXEC命令的时候。事务失败并返回一个错误(之后用户可以选择重试事务或者放弃事务)。通过使用WATCH，MULTI/EXEC，UNWATCH/DISCARD等命令，程序可以在执行某些重要操作的时候。通过确保自己正在使用的数据没有发生变化来避免出错。    \n什么是DISCARD？ unwatch命令可以再WATCH命令之后，在MULTI命令执行之前进行重置(reset)。同样DISCARD命令也可以在MULTI命令执行之后，在EXEC执行之前对连接进行重置。这也意味着，用户在使用WATCH监视一个键或者多个键，接着使用MULTI开始一个新的事务，并将多个命令入队到事务队列之后，仍然可以通过发送DISCARD命令来取消WATCH命令并清空所有已经已经入队的命令。\n\n在讲一件商品放到市场上机型销售的时候，程序需要将被销售的商品添加到记录市场正在销售商品的有序集合里面，并且再添加操作执行的过程中，监视卖家的包裹以确保被销售的商品确实存在u卖家的包裹当中。\n```\ndef list_item(conn, itemid, sellerid, pric):\n    inventory = \"inventory:%s\"%sellerid #包裹的集合\n    item = \"%s.%s\"%(itemid, sellerid) \n    end = time.time() + 5\n    pipe = conn.pipeline()\n    while time.time() < end:\n        try:\n            pipe.watch(inventory)  #监视用户的包裹\n            if not pipe.sismember(inventory, itemid) #检查用户是否仍然持有被销售的产品\n                pipe.unwatch(inventory)  #没有的话，取消监视并返回空\n                return None\n            pipe.multi()\n            pipe.zadd(\"market:\", item, price)  #把被销售的产品添加到市场中\n            pipe.srem(\"inventory\", itemid)\n            pipe.execute()\n            return None\n        except redis.exceptions.WatchError:\n            pass\n    return None\n```\nlist_item()函数，首先执行一些初始化，然后对卖家的包裹进行监视，验证卖家的商品是否处于卖家的包裹中，如果是，函数就会把商品添加到市场，并从卖家包裹移除这个商品，，在使用watch对包裹进行监视的过程中，如果包裹被更新或修改，程序受到错误并进行重试。\n\n#### 购买商品\n\n首先对市场以及卖家的信息进行监控，获取买家的钱数以及商品的售价，并检查钱够不够。不够，取消事务。够的话，先把买家的钱转给卖家，然后将售出的商品移动至买家的包裹，并将该商品从市场中移除。当买家的个人信息或者市场的商品信息变动，返回错误，最大重试时间10s\n```\ndef purchase_item(conn, buyerid, itemid, sellerid, lprice):\n    buyer = \"users:%s\" %buyerid\n    seller = \"users:%s\" %sellerid\n    item = \"%s.%s\" %(itemid, sellerid)\n    inventory = \"inventory:%s\" %buyerid\n    end = time.time() + 10\n    pipe = conn.pipeline()\n    \n    while time.time() < end + 10:\n        try:\n            pipe.watch(\"market:\", buyer)　　#监视两个，一个market,一个购买者的信息\n            \n            price = pipe.zscore(\"market:\", item)\n            funds = int(pipe.hget(buyer, \"funds\"))\n            if price != lprice or price > funds:  #检查买家购买的商品的价格是否发生变化及用户是否有钱购买\n                pipe.unwatch()\n                return None\n            pipe.multi()\n            pipe.hincrby(seller, \"funds\", int(price))\n            pipre.hincrby(buyer, \"funds\", int(-price))\n            pipe.sadd(inventory, itemid)\n            pipe.zrem(\"market:\", item)\n            pipe.excute()\n            reutrn True\n            \n        except redis.exceptions.WatchError:\n            pass\n    return False\n    \n```\n\n补充:为什么ｒｅｄｉｓ没有实现典型的加锁功能？　　　　\n在访问以写入为目的数据的时候，关系库会对被访问的数据进行加锁，直到事务被提交或者回滚。如果其他用户尝试对被加锁的数据进行写入，该客户端将会被阻塞。直到第一个事务执行完，持有锁的可花旦越慢，等待时间越长。　　　　\n为了减少等待时间，redis并不会在watch的时候对数据进行加锁，知乎自爱数据被其他客户端抢先修改的情况下通知执行了watch的客户端，这种做法成为乐观锁，而关系数据库的称为悲观锁。乐观锁在实际中也有效，因为客户端永远不必花时间去等待第一个已经取得锁的用户，只需要在自己的事务中失败并且重试即可。\n\n\n### 非事务性流水线操作\n\n事务性质-被，multi和exec包裹的命令在执行时候不会被其他客户端打扰。    \n在需要执行大量命令的情况下，及时命令不需要放在事务中执行，单位了一次发送所有的命令来减少通信次数，用户也可能吧命令包裹在multi和exec之间。但是multi和exec也会消耗资源，可能导致其他命令延迟执行。\n\npipe = conn.pipeline()\n\n如果用户在执行pipeline()传入True作为参数，或者不传，客户端将使用multi和exec包裹命令。如果传入Flase作为参数，同样客户端会想执行事务那样收集用户所需的所有命令，只是不再用multi和exec包裹命令。如果用户需要向redis一次发送多个命令，且对这些命令来说，一个命令的执行结果不影响另一个命令的输入，且这些命令需要以事务方式执行，可通过piepeline()传入fasle来提升redis的性能。\n\n之前的例子update_token函数，负责记录用户最近浏览的商品记忆访问过的页面，并跟新用户的cookie，每次执行都会调用2-5个redis命令，是的客户端和redis产生2-5次通信往返。\n```\ndef update_token(conn, token, user, item=None):\n    #获取时间戳\n    timestamp = time.time()\n    #维持令牌与已经登录的用户的映射\n    conn.hset('login:', token, user)\n    #记录令牌最后一次出现的时间\n    conn.zadd('recent:', token, timestamp)\n    if item:\n        #记录用户浏览过的商品\n        conn.zadd('viewed:' + token, item, timestamp)\n        #移除旧的记录，只保留过去的25个商品,移除0 - -26区间的成员，0和-26都是闭区间\n        conn.zremrangebyrank('viewed:' + token, 0 , -26)\n        #新增,zincrby key -5 member 让member的score减去5，每次减去-1，若key不存在，相当于zadd key increament member\n        #浏览单最多的商品将排列在索引0的位置上\n        conn.zincrby('viewed:', item, -1)\n```\n流水线\n```\ndef update_token_pipeline(conn, toekn, user, item=None):\n    timestamp = time.time()\n    pipe = conn.pipeline(False)\n    pipe.hset('login:', token, user)\n    pipe.zadd('recent', token, timestamp)\n    if item:\n        pipe.zadd('viewed:' + token, item, timestamp)\n        pipe.zremrangebyrank('viewed:' + token, 0， -26)\n        pipe.zincr('viewed:', item, -1)\n    pipe.execute()\n```\n\n减少了通信往返次数，提升了redis性能，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/redis事务2.md","raw":"---\nlayout: posts\ntitle: redis事务2\ndate: 2019-02-25 22:39:06\ntags: redis\ncategories: redis\n---\n### redis事务\n为了保证数据的正确性，确认一点:在多个客户端同时处理相同的数据时候，不谨慎的操作会导致数据出错。下面介绍使用redis事务来防止数据出错的方法，以及事务来提升性能的方法。    \nredis的事务和传统关系数据库事务并不同，在传统关系数据库中，用户先向数据库服务器发送BEGIN，然后执行各个相互一致(consistent)的写操作和读操作，最后用户选择COMMIT来确认之前所做的更改，或者发送ROLLBACK来放弃修改。    \n在redis也可一处理一连串相互一致的读操作和写操作。redis的事务以MULTI开始，之后跟着用户传入的多个命令，最后以EXEC为结束。但是这种简单的操作在调用EXEC命令之前不会执行任何实际的操作，所以用户没办法根据读到的数据做决定。    \n以例子来说明。下图展示了游戏中用于表示用户信息和用户包裹的结构，用户信息存储在散列用户报国使用一个集合来表示。\n<!-- more -->\n<div style=\"width: 200px; margin: auto\">![示例图片](/images/redis-transcation1.bmp)</div>\n\n买卖市场的需求:一个用户(卖家)可以将商品放到市场上进行销售，当一个用户(买家)购买时，卖家会收到钱。为了将被销售商品的全部信息存储到市场里面，我们将会把商品id和卖家id拼接在一起，并将拼接结果作为成员存储到市场的有序集合如下图所示\n\n<div style=\"width: 200px; margin: auto\">![示例图片](/images/redis-transcation2.bmp)</div>\n\n#### 将商品放到市场上销售\n\n为了将商品放到市场上销售，程序出了用到MULTI和EXEC命令之外，需要配合使用WATCH命令，有时甚至会用到UNWATCH和DISCARD(丢弃)。在用户使用WATCH对键进行监听后，直到用户执行EXEC这段时间里，如果有其他的客户端抢险对任何被监视的键进行了替换，更新，删除等操作，那么当用户尝试执行EXEC命令的时候。事务失败并返回一个错误(之后用户可以选择重试事务或者放弃事务)。通过使用WATCH，MULTI/EXEC，UNWATCH/DISCARD等命令，程序可以在执行某些重要操作的时候。通过确保自己正在使用的数据没有发生变化来避免出错。    \n什么是DISCARD？ unwatch命令可以再WATCH命令之后，在MULTI命令执行之前进行重置(reset)。同样DISCARD命令也可以在MULTI命令执行之后，在EXEC执行之前对连接进行重置。这也意味着，用户在使用WATCH监视一个键或者多个键，接着使用MULTI开始一个新的事务，并将多个命令入队到事务队列之后，仍然可以通过发送DISCARD命令来取消WATCH命令并清空所有已经已经入队的命令。\n\n在讲一件商品放到市场上机型销售的时候，程序需要将被销售的商品添加到记录市场正在销售商品的有序集合里面，并且再添加操作执行的过程中，监视卖家的包裹以确保被销售的商品确实存在u卖家的包裹当中。\n```\ndef list_item(conn, itemid, sellerid, pric):\n    inventory = \"inventory:%s\"%sellerid #包裹的集合\n    item = \"%s.%s\"%(itemid, sellerid) \n    end = time.time() + 5\n    pipe = conn.pipeline()\n    while time.time() < end:\n        try:\n            pipe.watch(inventory)  #监视用户的包裹\n            if not pipe.sismember(inventory, itemid) #检查用户是否仍然持有被销售的产品\n                pipe.unwatch(inventory)  #没有的话，取消监视并返回空\n                return None\n            pipe.multi()\n            pipe.zadd(\"market:\", item, price)  #把被销售的产品添加到市场中\n            pipe.srem(\"inventory\", itemid)\n            pipe.execute()\n            return None\n        except redis.exceptions.WatchError:\n            pass\n    return None\n```\nlist_item()函数，首先执行一些初始化，然后对卖家的包裹进行监视，验证卖家的商品是否处于卖家的包裹中，如果是，函数就会把商品添加到市场，并从卖家包裹移除这个商品，，在使用watch对包裹进行监视的过程中，如果包裹被更新或修改，程序受到错误并进行重试。\n\n#### 购买商品\n\n首先对市场以及卖家的信息进行监控，获取买家的钱数以及商品的售价，并检查钱够不够。不够，取消事务。够的话，先把买家的钱转给卖家，然后将售出的商品移动至买家的包裹，并将该商品从市场中移除。当买家的个人信息或者市场的商品信息变动，返回错误，最大重试时间10s\n```\ndef purchase_item(conn, buyerid, itemid, sellerid, lprice):\n    buyer = \"users:%s\" %buyerid\n    seller = \"users:%s\" %sellerid\n    item = \"%s.%s\" %(itemid, sellerid)\n    inventory = \"inventory:%s\" %buyerid\n    end = time.time() + 10\n    pipe = conn.pipeline()\n    \n    while time.time() < end + 10:\n        try:\n            pipe.watch(\"market:\", buyer)　　#监视两个，一个market,一个购买者的信息\n            \n            price = pipe.zscore(\"market:\", item)\n            funds = int(pipe.hget(buyer, \"funds\"))\n            if price != lprice or price > funds:  #检查买家购买的商品的价格是否发生变化及用户是否有钱购买\n                pipe.unwatch()\n                return None\n            pipe.multi()\n            pipe.hincrby(seller, \"funds\", int(price))\n            pipre.hincrby(buyer, \"funds\", int(-price))\n            pipe.sadd(inventory, itemid)\n            pipe.zrem(\"market:\", item)\n            pipe.excute()\n            reutrn True\n            \n        except redis.exceptions.WatchError:\n            pass\n    return False\n    \n```\n\n补充:为什么ｒｅｄｉｓ没有实现典型的加锁功能？　　　　\n在访问以写入为目的数据的时候，关系库会对被访问的数据进行加锁，直到事务被提交或者回滚。如果其他用户尝试对被加锁的数据进行写入，该客户端将会被阻塞。直到第一个事务执行完，持有锁的可花旦越慢，等待时间越长。　　　　\n为了减少等待时间，redis并不会在watch的时候对数据进行加锁，知乎自爱数据被其他客户端抢先修改的情况下通知执行了watch的客户端，这种做法成为乐观锁，而关系数据库的称为悲观锁。乐观锁在实际中也有效，因为客户端永远不必花时间去等待第一个已经取得锁的用户，只需要在自己的事务中失败并且重试即可。\n\n\n### 非事务性流水线操作\n\n事务性质-被，multi和exec包裹的命令在执行时候不会被其他客户端打扰。    \n在需要执行大量命令的情况下，及时命令不需要放在事务中执行，单位了一次发送所有的命令来减少通信次数，用户也可能吧命令包裹在multi和exec之间。但是multi和exec也会消耗资源，可能导致其他命令延迟执行。\n\npipe = conn.pipeline()\n\n如果用户在执行pipeline()传入True作为参数，或者不传，客户端将使用multi和exec包裹命令。如果传入Flase作为参数，同样客户端会想执行事务那样收集用户所需的所有命令，只是不再用multi和exec包裹命令。如果用户需要向redis一次发送多个命令，且对这些命令来说，一个命令的执行结果不影响另一个命令的输入，且这些命令需要以事务方式执行，可通过piepeline()传入fasle来提升redis的性能。\n\n之前的例子update_token函数，负责记录用户最近浏览的商品记忆访问过的页面，并跟新用户的cookie，每次执行都会调用2-5个redis命令，是的客户端和redis产生2-5次通信往返。\n```\ndef update_token(conn, token, user, item=None):\n    #获取时间戳\n    timestamp = time.time()\n    #维持令牌与已经登录的用户的映射\n    conn.hset('login:', token, user)\n    #记录令牌最后一次出现的时间\n    conn.zadd('recent:', token, timestamp)\n    if item:\n        #记录用户浏览过的商品\n        conn.zadd('viewed:' + token, item, timestamp)\n        #移除旧的记录，只保留过去的25个商品,移除0 - -26区间的成员，0和-26都是闭区间\n        conn.zremrangebyrank('viewed:' + token, 0 , -26)\n        #新增,zincrby key -5 member 让member的score减去5，每次减去-1，若key不存在，相当于zadd key increament member\n        #浏览单最多的商品将排列在索引0的位置上\n        conn.zincrby('viewed:', item, -1)\n```\n流水线\n```\ndef update_token_pipeline(conn, toekn, user, item=None):\n    timestamp = time.time()\n    pipe = conn.pipeline(False)\n    pipe.hset('login:', token, user)\n    pipe.zadd('recent', token, timestamp)\n    if item:\n        pipe.zadd('viewed:' + token, item, timestamp)\n        pipe.zremrangebyrank('viewed:' + token, 0， -26)\n        pipe.zincr('viewed:', item, -1)\n    pipe.execute()\n```\n\n减少了通信往返次数，提升了redis性能，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"redis事务2","published":1,"updated":"2022-05-20T02:24:20.543Z","comments":1,"photos":[],"link":"","_id":"cl3e0vh7o001nlae1q46x2afl","content":"<h3 id=\"redis事务\"><a href=\"#redis事务\" class=\"headerlink\" title=\"redis事务\"></a>redis事务</h3><p>为了保证数据的正确性，确认一点:在多个客户端同时处理相同的数据时候，不谨慎的操作会导致数据出错。下面介绍使用redis事务来防止数据出错的方法，以及事务来提升性能的方法。<br>redis的事务和传统关系数据库事务并不同，在传统关系数据库中，用户先向数据库服务器发送BEGIN，然后执行各个相互一致(consistent)的写操作和读操作，最后用户选择COMMIT来确认之前所做的更改，或者发送ROLLBACK来放弃修改。<br>在redis也可一处理一连串相互一致的读操作和写操作。redis的事务以MULTI开始，之后跟着用户传入的多个命令，最后以EXEC为结束。但是这种简单的操作在调用EXEC命令之前不会执行任何实际的操作，所以用户没办法根据读到的数据做决定。<br>以例子来说明。下图展示了游戏中用于表示用户信息和用户包裹的结构，用户信息存储在散列用户报国使用一个集合来表示。<br><a id=\"more\"></a></p>\n<div style=\"width: 200px; margin: auto\"><img src=\"/images/redis-transcation1.bmp\" alt=\"示例图片\"></div>\n\n<p>买卖市场的需求:一个用户(卖家)可以将商品放到市场上进行销售，当一个用户(买家)购买时，卖家会收到钱。为了将被销售商品的全部信息存储到市场里面，我们将会把商品id和卖家id拼接在一起，并将拼接结果作为成员存储到市场的有序集合如下图所示</p>\n<div style=\"width: 200px; margin: auto\"><img src=\"/images/redis-transcation2.bmp\" alt=\"示例图片\"></div>\n\n<h4 id=\"将商品放到市场上销售\"><a href=\"#将商品放到市场上销售\" class=\"headerlink\" title=\"将商品放到市场上销售\"></a>将商品放到市场上销售</h4><p>为了将商品放到市场上销售，程序出了用到MULTI和EXEC命令之外，需要配合使用WATCH命令，有时甚至会用到UNWATCH和DISCARD(丢弃)。在用户使用WATCH对键进行监听后，直到用户执行EXEC这段时间里，如果有其他的客户端抢险对任何被监视的键进行了替换，更新，删除等操作，那么当用户尝试执行EXEC命令的时候。事务失败并返回一个错误(之后用户可以选择重试事务或者放弃事务)。通过使用WATCH，MULTI/EXEC，UNWATCH/DISCARD等命令，程序可以在执行某些重要操作的时候。通过确保自己正在使用的数据没有发生变化来避免出错。<br>什么是DISCARD？ unwatch命令可以再WATCH命令之后，在MULTI命令执行之前进行重置(reset)。同样DISCARD命令也可以在MULTI命令执行之后，在EXEC执行之前对连接进行重置。这也意味着，用户在使用WATCH监视一个键或者多个键，接着使用MULTI开始一个新的事务，并将多个命令入队到事务队列之后，仍然可以通过发送DISCARD命令来取消WATCH命令并清空所有已经已经入队的命令。</p>\n<p>在讲一件商品放到市场上机型销售的时候，程序需要将被销售的商品添加到记录市场正在销售商品的有序集合里面，并且再添加操作执行的过程中，监视卖家的包裹以确保被销售的商品确实存在u卖家的包裹当中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def list_item(conn, itemid, sellerid, pric):</span><br><span class=\"line\">    inventory = &quot;inventory:%s&quot;%sellerid #包裹的集合</span><br><span class=\"line\">    item = &quot;%s.%s&quot;%(itemid, sellerid) </span><br><span class=\"line\">    end = time.time() + 5</span><br><span class=\"line\">    pipe = conn.pipeline()</span><br><span class=\"line\">    while time.time() &lt; end:</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            pipe.watch(inventory)  #监视用户的包裹</span><br><span class=\"line\">            if not pipe.sismember(inventory, itemid) #检查用户是否仍然持有被销售的产品</span><br><span class=\"line\">                pipe.unwatch(inventory)  #没有的话，取消监视并返回空</span><br><span class=\"line\">                return None</span><br><span class=\"line\">            pipe.multi()</span><br><span class=\"line\">            pipe.zadd(&quot;market:&quot;, item, price)  #把被销售的产品添加到市场中</span><br><span class=\"line\">            pipe.srem(&quot;inventory&quot;, itemid)</span><br><span class=\"line\">            pipe.execute()</span><br><span class=\"line\">            return None</span><br><span class=\"line\">        except redis.exceptions.WatchError:</span><br><span class=\"line\">            pass</span><br><span class=\"line\">    return None</span><br></pre></td></tr></table></figure></p>\n<p>list_item()函数，首先执行一些初始化，然后对卖家的包裹进行监视，验证卖家的商品是否处于卖家的包裹中，如果是，函数就会把商品添加到市场，并从卖家包裹移除这个商品，，在使用watch对包裹进行监视的过程中，如果包裹被更新或修改，程序受到错误并进行重试。</p>\n<h4 id=\"购买商品\"><a href=\"#购买商品\" class=\"headerlink\" title=\"购买商品\"></a>购买商品</h4><p>首先对市场以及卖家的信息进行监控，获取买家的钱数以及商品的售价，并检查钱够不够。不够，取消事务。够的话，先把买家的钱转给卖家，然后将售出的商品移动至买家的包裹，并将该商品从市场中移除。当买家的个人信息或者市场的商品信息变动，返回错误，最大重试时间10s<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def purchase_item(conn, buyerid, itemid, sellerid, lprice):</span><br><span class=\"line\">    buyer = &quot;users:%s&quot; %buyerid</span><br><span class=\"line\">    seller = &quot;users:%s&quot; %sellerid</span><br><span class=\"line\">    item = &quot;%s.%s&quot; %(itemid, sellerid)</span><br><span class=\"line\">    inventory = &quot;inventory:%s&quot; %buyerid</span><br><span class=\"line\">    end = time.time() + 10</span><br><span class=\"line\">    pipe = conn.pipeline()</span><br><span class=\"line\">    </span><br><span class=\"line\">    while time.time() &lt; end + 10:</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            pipe.watch(&quot;market:&quot;, buyer)　　#监视两个，一个market,一个购买者的信息</span><br><span class=\"line\">            </span><br><span class=\"line\">            price = pipe.zscore(&quot;market:&quot;, item)</span><br><span class=\"line\">            funds = int(pipe.hget(buyer, &quot;funds&quot;))</span><br><span class=\"line\">            if price != lprice or price &gt; funds:  #检查买家购买的商品的价格是否发生变化及用户是否有钱购买</span><br><span class=\"line\">                pipe.unwatch()</span><br><span class=\"line\">                return None</span><br><span class=\"line\">            pipe.multi()</span><br><span class=\"line\">            pipe.hincrby(seller, &quot;funds&quot;, int(price))</span><br><span class=\"line\">            pipre.hincrby(buyer, &quot;funds&quot;, int(-price))</span><br><span class=\"line\">            pipe.sadd(inventory, itemid)</span><br><span class=\"line\">            pipe.zrem(&quot;market:&quot;, item)</span><br><span class=\"line\">            pipe.excute()</span><br><span class=\"line\">            reutrn True</span><br><span class=\"line\">            </span><br><span class=\"line\">        except redis.exceptions.WatchError:</span><br><span class=\"line\">            pass</span><br><span class=\"line\">    return False</span><br></pre></td></tr></table></figure></p>\n<p>补充:为什么ｒｅｄｉｓ没有实现典型的加锁功能？　　　　<br>在访问以写入为目的数据的时候，关系库会对被访问的数据进行加锁，直到事务被提交或者回滚。如果其他用户尝试对被加锁的数据进行写入，该客户端将会被阻塞。直到第一个事务执行完，持有锁的可花旦越慢，等待时间越长。　　　　<br>为了减少等待时间，redis并不会在watch的时候对数据进行加锁，知乎自爱数据被其他客户端抢先修改的情况下通知执行了watch的客户端，这种做法成为乐观锁，而关系数据库的称为悲观锁。乐观锁在实际中也有效，因为客户端永远不必花时间去等待第一个已经取得锁的用户，只需要在自己的事务中失败并且重试即可。</p>\n<h3 id=\"非事务性流水线操作\"><a href=\"#非事务性流水线操作\" class=\"headerlink\" title=\"非事务性流水线操作\"></a>非事务性流水线操作</h3><p>事务性质-被，multi和exec包裹的命令在执行时候不会被其他客户端打扰。<br>在需要执行大量命令的情况下，及时命令不需要放在事务中执行，单位了一次发送所有的命令来减少通信次数，用户也可能吧命令包裹在multi和exec之间。但是multi和exec也会消耗资源，可能导致其他命令延迟执行。</p>\n<p>pipe = conn.pipeline()</p>\n<p>如果用户在执行pipeline()传入True作为参数，或者不传，客户端将使用multi和exec包裹命令。如果传入Flase作为参数，同样客户端会想执行事务那样收集用户所需的所有命令，只是不再用multi和exec包裹命令。如果用户需要向redis一次发送多个命令，且对这些命令来说，一个命令的执行结果不影响另一个命令的输入，且这些命令需要以事务方式执行，可通过piepeline()传入fasle来提升redis的性能。</p>\n<p>之前的例子update_token函数，负责记录用户最近浏览的商品记忆访问过的页面，并跟新用户的cookie，每次执行都会调用2-5个redis命令，是的客户端和redis产生2-5次通信往返。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def update_token(conn, token, user, item=None):</span><br><span class=\"line\">    #获取时间戳</span><br><span class=\"line\">    timestamp = time.time()</span><br><span class=\"line\">    #维持令牌与已经登录的用户的映射</span><br><span class=\"line\">    conn.hset(&apos;login:&apos;, token, user)</span><br><span class=\"line\">    #记录令牌最后一次出现的时间</span><br><span class=\"line\">    conn.zadd(&apos;recent:&apos;, token, timestamp)</span><br><span class=\"line\">    if item:</span><br><span class=\"line\">        #记录用户浏览过的商品</span><br><span class=\"line\">        conn.zadd(&apos;viewed:&apos; + token, item, timestamp)</span><br><span class=\"line\">        #移除旧的记录，只保留过去的25个商品,移除0 - -26区间的成员，0和-26都是闭区间</span><br><span class=\"line\">        conn.zremrangebyrank(&apos;viewed:&apos; + token, 0 , -26)</span><br><span class=\"line\">        #新增,zincrby key -5 member 让member的score减去5，每次减去-1，若key不存在，相当于zadd key increament member</span><br><span class=\"line\">        #浏览单最多的商品将排列在索引0的位置上</span><br><span class=\"line\">        conn.zincrby(&apos;viewed:&apos;, item, -1)</span><br></pre></td></tr></table></figure></p>\n<p>流水线<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def update_token_pipeline(conn, toekn, user, item=None):</span><br><span class=\"line\">    timestamp = time.time()</span><br><span class=\"line\">    pipe = conn.pipeline(False)</span><br><span class=\"line\">    pipe.hset(&apos;login:&apos;, token, user)</span><br><span class=\"line\">    pipe.zadd(&apos;recent&apos;, token, timestamp)</span><br><span class=\"line\">    if item:</span><br><span class=\"line\">        pipe.zadd(&apos;viewed:&apos; + token, item, timestamp)</span><br><span class=\"line\">        pipe.zremrangebyrank(&apos;viewed:&apos; + token, 0， -26)</span><br><span class=\"line\">        pipe.zincr(&apos;viewed:&apos;, item, -1)</span><br><span class=\"line\">    pipe.execute()</span><br></pre></td></tr></table></figure></p>\n<p>减少了通信往返次数，提升了redis性能，</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"redis事务\"><a href=\"#redis事务\" class=\"headerlink\" title=\"redis事务\"></a>redis事务</h3><p>为了保证数据的正确性，确认一点:在多个客户端同时处理相同的数据时候，不谨慎的操作会导致数据出错。下面介绍使用redis事务来防止数据出错的方法，以及事务来提升性能的方法。<br>redis的事务和传统关系数据库事务并不同，在传统关系数据库中，用户先向数据库服务器发送BEGIN，然后执行各个相互一致(consistent)的写操作和读操作，最后用户选择COMMIT来确认之前所做的更改，或者发送ROLLBACK来放弃修改。<br>在redis也可一处理一连串相互一致的读操作和写操作。redis的事务以MULTI开始，之后跟着用户传入的多个命令，最后以EXEC为结束。但是这种简单的操作在调用EXEC命令之前不会执行任何实际的操作，所以用户没办法根据读到的数据做决定。<br>以例子来说明。下图展示了游戏中用于表示用户信息和用户包裹的结构，用户信息存储在散列用户报国使用一个集合来表示。<br>","more":"</p>\n<div style=\"width: 200px; margin: auto\"><img src=\"/images/redis-transcation1.bmp\" alt=\"示例图片\"></div>\n\n<p>买卖市场的需求:一个用户(卖家)可以将商品放到市场上进行销售，当一个用户(买家)购买时，卖家会收到钱。为了将被销售商品的全部信息存储到市场里面，我们将会把商品id和卖家id拼接在一起，并将拼接结果作为成员存储到市场的有序集合如下图所示</p>\n<div style=\"width: 200px; margin: auto\"><img src=\"/images/redis-transcation2.bmp\" alt=\"示例图片\"></div>\n\n<h4 id=\"将商品放到市场上销售\"><a href=\"#将商品放到市场上销售\" class=\"headerlink\" title=\"将商品放到市场上销售\"></a>将商品放到市场上销售</h4><p>为了将商品放到市场上销售，程序出了用到MULTI和EXEC命令之外，需要配合使用WATCH命令，有时甚至会用到UNWATCH和DISCARD(丢弃)。在用户使用WATCH对键进行监听后，直到用户执行EXEC这段时间里，如果有其他的客户端抢险对任何被监视的键进行了替换，更新，删除等操作，那么当用户尝试执行EXEC命令的时候。事务失败并返回一个错误(之后用户可以选择重试事务或者放弃事务)。通过使用WATCH，MULTI/EXEC，UNWATCH/DISCARD等命令，程序可以在执行某些重要操作的时候。通过确保自己正在使用的数据没有发生变化来避免出错。<br>什么是DISCARD？ unwatch命令可以再WATCH命令之后，在MULTI命令执行之前进行重置(reset)。同样DISCARD命令也可以在MULTI命令执行之后，在EXEC执行之前对连接进行重置。这也意味着，用户在使用WATCH监视一个键或者多个键，接着使用MULTI开始一个新的事务，并将多个命令入队到事务队列之后，仍然可以通过发送DISCARD命令来取消WATCH命令并清空所有已经已经入队的命令。</p>\n<p>在讲一件商品放到市场上机型销售的时候，程序需要将被销售的商品添加到记录市场正在销售商品的有序集合里面，并且再添加操作执行的过程中，监视卖家的包裹以确保被销售的商品确实存在u卖家的包裹当中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def list_item(conn, itemid, sellerid, pric):</span><br><span class=\"line\">    inventory = &quot;inventory:%s&quot;%sellerid #包裹的集合</span><br><span class=\"line\">    item = &quot;%s.%s&quot;%(itemid, sellerid) </span><br><span class=\"line\">    end = time.time() + 5</span><br><span class=\"line\">    pipe = conn.pipeline()</span><br><span class=\"line\">    while time.time() &lt; end:</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            pipe.watch(inventory)  #监视用户的包裹</span><br><span class=\"line\">            if not pipe.sismember(inventory, itemid) #检查用户是否仍然持有被销售的产品</span><br><span class=\"line\">                pipe.unwatch(inventory)  #没有的话，取消监视并返回空</span><br><span class=\"line\">                return None</span><br><span class=\"line\">            pipe.multi()</span><br><span class=\"line\">            pipe.zadd(&quot;market:&quot;, item, price)  #把被销售的产品添加到市场中</span><br><span class=\"line\">            pipe.srem(&quot;inventory&quot;, itemid)</span><br><span class=\"line\">            pipe.execute()</span><br><span class=\"line\">            return None</span><br><span class=\"line\">        except redis.exceptions.WatchError:</span><br><span class=\"line\">            pass</span><br><span class=\"line\">    return None</span><br></pre></td></tr></table></figure></p>\n<p>list_item()函数，首先执行一些初始化，然后对卖家的包裹进行监视，验证卖家的商品是否处于卖家的包裹中，如果是，函数就会把商品添加到市场，并从卖家包裹移除这个商品，，在使用watch对包裹进行监视的过程中，如果包裹被更新或修改，程序受到错误并进行重试。</p>\n<h4 id=\"购买商品\"><a href=\"#购买商品\" class=\"headerlink\" title=\"购买商品\"></a>购买商品</h4><p>首先对市场以及卖家的信息进行监控，获取买家的钱数以及商品的售价，并检查钱够不够。不够，取消事务。够的话，先把买家的钱转给卖家，然后将售出的商品移动至买家的包裹，并将该商品从市场中移除。当买家的个人信息或者市场的商品信息变动，返回错误，最大重试时间10s<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def purchase_item(conn, buyerid, itemid, sellerid, lprice):</span><br><span class=\"line\">    buyer = &quot;users:%s&quot; %buyerid</span><br><span class=\"line\">    seller = &quot;users:%s&quot; %sellerid</span><br><span class=\"line\">    item = &quot;%s.%s&quot; %(itemid, sellerid)</span><br><span class=\"line\">    inventory = &quot;inventory:%s&quot; %buyerid</span><br><span class=\"line\">    end = time.time() + 10</span><br><span class=\"line\">    pipe = conn.pipeline()</span><br><span class=\"line\">    </span><br><span class=\"line\">    while time.time() &lt; end + 10:</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            pipe.watch(&quot;market:&quot;, buyer)　　#监视两个，一个market,一个购买者的信息</span><br><span class=\"line\">            </span><br><span class=\"line\">            price = pipe.zscore(&quot;market:&quot;, item)</span><br><span class=\"line\">            funds = int(pipe.hget(buyer, &quot;funds&quot;))</span><br><span class=\"line\">            if price != lprice or price &gt; funds:  #检查买家购买的商品的价格是否发生变化及用户是否有钱购买</span><br><span class=\"line\">                pipe.unwatch()</span><br><span class=\"line\">                return None</span><br><span class=\"line\">            pipe.multi()</span><br><span class=\"line\">            pipe.hincrby(seller, &quot;funds&quot;, int(price))</span><br><span class=\"line\">            pipre.hincrby(buyer, &quot;funds&quot;, int(-price))</span><br><span class=\"line\">            pipe.sadd(inventory, itemid)</span><br><span class=\"line\">            pipe.zrem(&quot;market:&quot;, item)</span><br><span class=\"line\">            pipe.excute()</span><br><span class=\"line\">            reutrn True</span><br><span class=\"line\">            </span><br><span class=\"line\">        except redis.exceptions.WatchError:</span><br><span class=\"line\">            pass</span><br><span class=\"line\">    return False</span><br></pre></td></tr></table></figure></p>\n<p>补充:为什么ｒｅｄｉｓ没有实现典型的加锁功能？　　　　<br>在访问以写入为目的数据的时候，关系库会对被访问的数据进行加锁，直到事务被提交或者回滚。如果其他用户尝试对被加锁的数据进行写入，该客户端将会被阻塞。直到第一个事务执行完，持有锁的可花旦越慢，等待时间越长。　　　　<br>为了减少等待时间，redis并不会在watch的时候对数据进行加锁，知乎自爱数据被其他客户端抢先修改的情况下通知执行了watch的客户端，这种做法成为乐观锁，而关系数据库的称为悲观锁。乐观锁在实际中也有效，因为客户端永远不必花时间去等待第一个已经取得锁的用户，只需要在自己的事务中失败并且重试即可。</p>\n<h3 id=\"非事务性流水线操作\"><a href=\"#非事务性流水线操作\" class=\"headerlink\" title=\"非事务性流水线操作\"></a>非事务性流水线操作</h3><p>事务性质-被，multi和exec包裹的命令在执行时候不会被其他客户端打扰。<br>在需要执行大量命令的情况下，及时命令不需要放在事务中执行，单位了一次发送所有的命令来减少通信次数，用户也可能吧命令包裹在multi和exec之间。但是multi和exec也会消耗资源，可能导致其他命令延迟执行。</p>\n<p>pipe = conn.pipeline()</p>\n<p>如果用户在执行pipeline()传入True作为参数，或者不传，客户端将使用multi和exec包裹命令。如果传入Flase作为参数，同样客户端会想执行事务那样收集用户所需的所有命令，只是不再用multi和exec包裹命令。如果用户需要向redis一次发送多个命令，且对这些命令来说，一个命令的执行结果不影响另一个命令的输入，且这些命令需要以事务方式执行，可通过piepeline()传入fasle来提升redis的性能。</p>\n<p>之前的例子update_token函数，负责记录用户最近浏览的商品记忆访问过的页面，并跟新用户的cookie，每次执行都会调用2-5个redis命令，是的客户端和redis产生2-5次通信往返。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def update_token(conn, token, user, item=None):</span><br><span class=\"line\">    #获取时间戳</span><br><span class=\"line\">    timestamp = time.time()</span><br><span class=\"line\">    #维持令牌与已经登录的用户的映射</span><br><span class=\"line\">    conn.hset(&apos;login:&apos;, token, user)</span><br><span class=\"line\">    #记录令牌最后一次出现的时间</span><br><span class=\"line\">    conn.zadd(&apos;recent:&apos;, token, timestamp)</span><br><span class=\"line\">    if item:</span><br><span class=\"line\">        #记录用户浏览过的商品</span><br><span class=\"line\">        conn.zadd(&apos;viewed:&apos; + token, item, timestamp)</span><br><span class=\"line\">        #移除旧的记录，只保留过去的25个商品,移除0 - -26区间的成员，0和-26都是闭区间</span><br><span class=\"line\">        conn.zremrangebyrank(&apos;viewed:&apos; + token, 0 , -26)</span><br><span class=\"line\">        #新增,zincrby key -5 member 让member的score减去5，每次减去-1，若key不存在，相当于zadd key increament member</span><br><span class=\"line\">        #浏览单最多的商品将排列在索引0的位置上</span><br><span class=\"line\">        conn.zincrby(&apos;viewed:&apos;, item, -1)</span><br></pre></td></tr></table></figure></p>\n<p>流水线<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def update_token_pipeline(conn, toekn, user, item=None):</span><br><span class=\"line\">    timestamp = time.time()</span><br><span class=\"line\">    pipe = conn.pipeline(False)</span><br><span class=\"line\">    pipe.hset(&apos;login:&apos;, token, user)</span><br><span class=\"line\">    pipe.zadd(&apos;recent&apos;, token, timestamp)</span><br><span class=\"line\">    if item:</span><br><span class=\"line\">        pipe.zadd(&apos;viewed:&apos; + token, item, timestamp)</span><br><span class=\"line\">        pipe.zremrangebyrank(&apos;viewed:&apos; + token, 0， -26)</span><br><span class=\"line\">        pipe.zincr(&apos;viewed:&apos;, item, -1)</span><br><span class=\"line\">    pipe.execute()</span><br></pre></td></tr></table></figure></p>\n<p>减少了通信往返次数，提升了redis性能，</p>"},{"layout":"posts","title":"redis持久化","date":"2019-02-25T07:13:24.000Z","_content":"\n### 持久化选项\nredis提供了两种不同的持久化方法来将数据存储到硬盘中。一种方法叫做快照(snapshotting)，他可以将某一时刻的所有数据写入硬盘。另一种叫做只追加文件(appedn-only file,AOF),他会在执行写命令时，将被执行的写命令复制到硬盘中，这两种持久化方法即可以同时使用也可以单独使用。    \n将内存的数据存储到硬盘的主要原因是为了在之后重用数据，或是为了防止系统故障将数据备份到另一个远程位置\n\n#### 快照持久化\n创建快照的方法\n- 客户端可以通过向redis发送BGSAVE命令来创建一个快照，对于支持BGSAVE命令的平台来说，redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程继续处理命令请求。\n- 客户端还可以通过向redis发送SAVE命令来创建一个快照，接到SAVE命令的redis服务器在快照创建完毕之前不再响应任何其他请求。SAVE命令并不常用，通常只会在没有足够内存去执行BGSAVE的命令情况下，或者等待持久化操作完毕后也无所谓的情况下，才会使用SAVE.\n- 如果用户设置了save的配置选项，比如`save 60 10000`，那么redis最近一次创建快照之后开始算起，当60s之后有10000次写入，这个条件被满足以后，redis会自动触发BGSAVE命令。如果用户设置了多个save配置，当任意一个save配置条件被满足，都会触发BGSAVE。\n- 当redis通过SHUTDOWN命令接收到关闭服务器的请求时，或者接受到标准的TERM信号时，会执行一个SAVE命令，阻塞所有客户端，不在执行刻画段发送的任何命令。并在SAVE命令之后关闭服务器。\n- 当一个redis服务器链接另一个redis服务器，并向对方发送SYNC命令来开始一次复制操作的时候，如果服务器目前没有执行BGSAVE操作，或者主服务器并非刚刚执行完BGSAVE操作，那么主服务器会执行BGSAVE。     \n<!-- more -->\n在只使用快照持久化来保存数据时，如果系统真的发生崩溃，那么用户将丢失最近一次生成快照之后的所有数据。因此快照持久化只适用于那些即使丢失一部分数据也不会造成问题的应用程序。\n\n\n### AOF持久化\nAOF持久化会将被执行的写命令写到AOF文件的末尾，以此来记录数据的变化。因此，redis只要从头到尾重新执行一次AOF文件包含的所有写命令，就可以恢复AOF文件所记录的数据集。appendfsync配置选项对AOF文件的同步频率的影响。\n- always: 每个redis写命令都会同步写入硬盘，这样会严重降低redis的速度。\n- everysec: 每秒执行一次同步，显式的将多个命令同步到硬盘\n- no: 让操作系统决定何时同步\n\n\n\n#### 重写/压缩AOF文件\n假如选择everysec，由于redis会不断的执行写命令记录到AOF文件中，随着redis的不断运行，AOF文件会不断增大，甚至用完硬盘所有空间。为了解决此问题，用户可以向redis发送BGREWRITEAOF，这个命令会移除AOF文件的冗余来重写AOF文件。`同快照持久化一样，重写需要用到子进程，由于快照持久化存在内存占中和性能问题，在AOF持久化同样存在`，如果不加以控制，AOF的文件会比快照文件大好几倍。    \n同快照持久化一样可以通设置save选项来自动执行BGSAVE一样，AOF持久化可以通过设置'auto-aof-rewrite-perventage'选项和`auto-aof-rewrite-min-size`选项来自动执行BGREWRITEAOF，例如，设置`auto-aof-rewrite-percentage 100`和`auto-aof-rewrite-min-size 64mb`，并且启用了AOF持久化，那么当AOF文件大于64mb，并且AOF文件的体积比上次重写之后体积增加了一倍，redis自动执行BGREWRITEAOF。    \n无论使用AOF持久化还是快照持久化，将数据持久化到硬盘上是十分有必要的，除此外，用户还需对持久化的文件进行备份，这样才能避免数据的丢失。但随着负载量的上升，或者数据的完整性越来越重要，用户可能需要复制特性。\n\n#### 复制(replication)\n复制可以让其他服务器拥有一个不断更新的数据副本，从而使得拥有数据副本的服务器可以处理客户端发送的请求。关系数据库通常会使用一个主服务器(master)向多个从服务器(salve)发送更新，并使用从服务器开处理所有请求。redis同理。    \n复制的过程如下:\n\n<div style=\"width: 200px; margin: auto\">![示例图片](/images/AOF-replication.bmp)</div>\n\n从服务器的设置:用户可以通过配置选项SLAVEOF host port来讲一个redis服务器设置为服务器，也可以通过向正在运行的redis服务器发送SLAVEOF命令来将其设置为从服务器。\n- 如果使用SALVEOF配置选项设置，那么redis启动时会载入当前可用的任何快照或者AOF文件，然后连接主服务器完成上图的复制过程。\n- 如果使用SALVEOF命令，那么redis会立即尝试连接主服务器，并在连接成功后开始上图的复制过程。\n\n当多个从服务器尝试链接同一个主服务器，有时候可重用已有的快照文件。\n<div style=\"width: 200px; margin: auto\">![示例图片](/images/AOF-replication.bmp)</div>\n\n#### 检验硬盘写入\n为了验证主服务器已经把数据发送至从服务器，用户需要再向主服务器写入一个唯一的虚构值(unique dummy value)，然后通过检查虚构值是否存在于从服务器来判断数据是否到达从服务器。但判断数据是否写入硬盘则相对困难，对于每秒同步一次的AOF文件，可通过等待一秒来确定数据是否写入硬盘。更节约时间的做法是检查INFO命令的输出结果中aof_pending_bio_fsync的属性是否为0，如果是的话，那么就表示服务器保存至硬盘。在向主服务器写入数据后，用户可以将二者的链接作为参数，然后执行检查。代码\n```\nimport time\nimport uuid\n\n##wait_for_sync\ndef wait_for_sync(mconn, sconn):\n    identifier = str(uuid.uuid4()) #添加随机的令牌利用uuid生成\n    #print(identifier)\n    mconn.zadd('sync:wait', identifier, time.time())  #将令牌添加至主服务器\n    \n    while not sconn.info()['master_link_status'] != 'up': #如果有必要，等待从服务器完成同步\n        time.sleep(.001)\n        \n    while not sconn.zscore('sync:wait', identifier): #等待从服务器接受数据更新\n        time.sleep(.001)\n        \n    deadline = time.time() + 1.01   #最多等待1s\n    while time.time() < deadline:\n        if sconn.info()['aof_pending_bio_fsync'] == 0: #检查数据是否存入了硬盘，等于0则存入\n            break\n        time.sleep(.001)\n    mconn.zrem('sync:wait', identifier)\n    mconn.zremrangebyscore('sync:wait', 0, time.time()-900) #清理刚创建的新令牌以及之前可能留下的旧令牌,900s\n    \n    #zremrange的使用\n    #     redis> ZRANGE salary 0 -1 WITHSCORES          # 显示有序集内所有成员及其 score 值\n    # 1) \"tom\"\n    # 2) \"2000\"\n    # 3) \"peter\"\n    # 4) \"3500\"\n    # 5) \"jack\"\n    # 6) \"5000\"\n\n    # redis> ZREMRANGEBYSCORE salary 1500 3500      # 移除所有薪水在 1500 到 3500 内的员工\n    # (integer) 2\n\n    # redis> ZRANGE salary 0 -1 WITHSCORES          # 剩下的有序集成员\n    # 1) \"jack\"\n    # 2) \"5000\"\n```\n其中info命令提供了大量与redis服务器有关的信息，比如内存占用量，，客户端连接数，每个数据库包含的键的数量，上次创建快照文件之后执行的命令的数量等等。     \n为了确保操作正确执行wait_for_sync()函数会首先确认从服务器连接上主服务器，然后检查自己添加到等待同步有序集合里面的值是否存在从服务器，在发现值已经存在于从服务器，函数会检查从服务器写入缓冲区的状态，并在1s之内，等待从服务器将缓冲区的所有数据存硬盘。孙然函数等待1s，但是大部分同步会在很短的时间内完成。最后确认数据保存到硬盘，函数会执行一些清理操作。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/redis持久化.md","raw":"---\nlayout: posts\ntitle: redis持久化\ndate: 2019-02-25 15:13:24\ntags: redis\ncategories: redis\n---\n\n### 持久化选项\nredis提供了两种不同的持久化方法来将数据存储到硬盘中。一种方法叫做快照(snapshotting)，他可以将某一时刻的所有数据写入硬盘。另一种叫做只追加文件(appedn-only file,AOF),他会在执行写命令时，将被执行的写命令复制到硬盘中，这两种持久化方法即可以同时使用也可以单独使用。    \n将内存的数据存储到硬盘的主要原因是为了在之后重用数据，或是为了防止系统故障将数据备份到另一个远程位置\n\n#### 快照持久化\n创建快照的方法\n- 客户端可以通过向redis发送BGSAVE命令来创建一个快照，对于支持BGSAVE命令的平台来说，redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程继续处理命令请求。\n- 客户端还可以通过向redis发送SAVE命令来创建一个快照，接到SAVE命令的redis服务器在快照创建完毕之前不再响应任何其他请求。SAVE命令并不常用，通常只会在没有足够内存去执行BGSAVE的命令情况下，或者等待持久化操作完毕后也无所谓的情况下，才会使用SAVE.\n- 如果用户设置了save的配置选项，比如`save 60 10000`，那么redis最近一次创建快照之后开始算起，当60s之后有10000次写入，这个条件被满足以后，redis会自动触发BGSAVE命令。如果用户设置了多个save配置，当任意一个save配置条件被满足，都会触发BGSAVE。\n- 当redis通过SHUTDOWN命令接收到关闭服务器的请求时，或者接受到标准的TERM信号时，会执行一个SAVE命令，阻塞所有客户端，不在执行刻画段发送的任何命令。并在SAVE命令之后关闭服务器。\n- 当一个redis服务器链接另一个redis服务器，并向对方发送SYNC命令来开始一次复制操作的时候，如果服务器目前没有执行BGSAVE操作，或者主服务器并非刚刚执行完BGSAVE操作，那么主服务器会执行BGSAVE。     \n<!-- more -->\n在只使用快照持久化来保存数据时，如果系统真的发生崩溃，那么用户将丢失最近一次生成快照之后的所有数据。因此快照持久化只适用于那些即使丢失一部分数据也不会造成问题的应用程序。\n\n\n### AOF持久化\nAOF持久化会将被执行的写命令写到AOF文件的末尾，以此来记录数据的变化。因此，redis只要从头到尾重新执行一次AOF文件包含的所有写命令，就可以恢复AOF文件所记录的数据集。appendfsync配置选项对AOF文件的同步频率的影响。\n- always: 每个redis写命令都会同步写入硬盘，这样会严重降低redis的速度。\n- everysec: 每秒执行一次同步，显式的将多个命令同步到硬盘\n- no: 让操作系统决定何时同步\n\n\n\n#### 重写/压缩AOF文件\n假如选择everysec，由于redis会不断的执行写命令记录到AOF文件中，随着redis的不断运行，AOF文件会不断增大，甚至用完硬盘所有空间。为了解决此问题，用户可以向redis发送BGREWRITEAOF，这个命令会移除AOF文件的冗余来重写AOF文件。`同快照持久化一样，重写需要用到子进程，由于快照持久化存在内存占中和性能问题，在AOF持久化同样存在`，如果不加以控制，AOF的文件会比快照文件大好几倍。    \n同快照持久化一样可以通设置save选项来自动执行BGSAVE一样，AOF持久化可以通过设置'auto-aof-rewrite-perventage'选项和`auto-aof-rewrite-min-size`选项来自动执行BGREWRITEAOF，例如，设置`auto-aof-rewrite-percentage 100`和`auto-aof-rewrite-min-size 64mb`，并且启用了AOF持久化，那么当AOF文件大于64mb，并且AOF文件的体积比上次重写之后体积增加了一倍，redis自动执行BGREWRITEAOF。    \n无论使用AOF持久化还是快照持久化，将数据持久化到硬盘上是十分有必要的，除此外，用户还需对持久化的文件进行备份，这样才能避免数据的丢失。但随着负载量的上升，或者数据的完整性越来越重要，用户可能需要复制特性。\n\n#### 复制(replication)\n复制可以让其他服务器拥有一个不断更新的数据副本，从而使得拥有数据副本的服务器可以处理客户端发送的请求。关系数据库通常会使用一个主服务器(master)向多个从服务器(salve)发送更新，并使用从服务器开处理所有请求。redis同理。    \n复制的过程如下:\n\n<div style=\"width: 200px; margin: auto\">![示例图片](/images/AOF-replication.bmp)</div>\n\n从服务器的设置:用户可以通过配置选项SLAVEOF host port来讲一个redis服务器设置为服务器，也可以通过向正在运行的redis服务器发送SLAVEOF命令来将其设置为从服务器。\n- 如果使用SALVEOF配置选项设置，那么redis启动时会载入当前可用的任何快照或者AOF文件，然后连接主服务器完成上图的复制过程。\n- 如果使用SALVEOF命令，那么redis会立即尝试连接主服务器，并在连接成功后开始上图的复制过程。\n\n当多个从服务器尝试链接同一个主服务器，有时候可重用已有的快照文件。\n<div style=\"width: 200px; margin: auto\">![示例图片](/images/AOF-replication.bmp)</div>\n\n#### 检验硬盘写入\n为了验证主服务器已经把数据发送至从服务器，用户需要再向主服务器写入一个唯一的虚构值(unique dummy value)，然后通过检查虚构值是否存在于从服务器来判断数据是否到达从服务器。但判断数据是否写入硬盘则相对困难，对于每秒同步一次的AOF文件，可通过等待一秒来确定数据是否写入硬盘。更节约时间的做法是检查INFO命令的输出结果中aof_pending_bio_fsync的属性是否为0，如果是的话，那么就表示服务器保存至硬盘。在向主服务器写入数据后，用户可以将二者的链接作为参数，然后执行检查。代码\n```\nimport time\nimport uuid\n\n##wait_for_sync\ndef wait_for_sync(mconn, sconn):\n    identifier = str(uuid.uuid4()) #添加随机的令牌利用uuid生成\n    #print(identifier)\n    mconn.zadd('sync:wait', identifier, time.time())  #将令牌添加至主服务器\n    \n    while not sconn.info()['master_link_status'] != 'up': #如果有必要，等待从服务器完成同步\n        time.sleep(.001)\n        \n    while not sconn.zscore('sync:wait', identifier): #等待从服务器接受数据更新\n        time.sleep(.001)\n        \n    deadline = time.time() + 1.01   #最多等待1s\n    while time.time() < deadline:\n        if sconn.info()['aof_pending_bio_fsync'] == 0: #检查数据是否存入了硬盘，等于0则存入\n            break\n        time.sleep(.001)\n    mconn.zrem('sync:wait', identifier)\n    mconn.zremrangebyscore('sync:wait', 0, time.time()-900) #清理刚创建的新令牌以及之前可能留下的旧令牌,900s\n    \n    #zremrange的使用\n    #     redis> ZRANGE salary 0 -1 WITHSCORES          # 显示有序集内所有成员及其 score 值\n    # 1) \"tom\"\n    # 2) \"2000\"\n    # 3) \"peter\"\n    # 4) \"3500\"\n    # 5) \"jack\"\n    # 6) \"5000\"\n\n    # redis> ZREMRANGEBYSCORE salary 1500 3500      # 移除所有薪水在 1500 到 3500 内的员工\n    # (integer) 2\n\n    # redis> ZRANGE salary 0 -1 WITHSCORES          # 剩下的有序集成员\n    # 1) \"jack\"\n    # 2) \"5000\"\n```\n其中info命令提供了大量与redis服务器有关的信息，比如内存占用量，，客户端连接数，每个数据库包含的键的数量，上次创建快照文件之后执行的命令的数量等等。     \n为了确保操作正确执行wait_for_sync()函数会首先确认从服务器连接上主服务器，然后检查自己添加到等待同步有序集合里面的值是否存在从服务器，在发现值已经存在于从服务器，函数会检查从服务器写入缓冲区的状态，并在1s之内，等待从服务器将缓冲区的所有数据存硬盘。孙然函数等待1s，但是大部分同步会在很短的时间内完成。最后确认数据保存到硬盘，函数会执行一些清理操作。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"redis持久化","published":1,"updated":"2022-05-20T02:24:20.543Z","comments":1,"photos":[],"link":"","_id":"cl3e0vh7p001rlae1jc1mgftt","content":"<h3 id=\"持久化选项\"><a href=\"#持久化选项\" class=\"headerlink\" title=\"持久化选项\"></a>持久化选项</h3><p>redis提供了两种不同的持久化方法来将数据存储到硬盘中。一种方法叫做快照(snapshotting)，他可以将某一时刻的所有数据写入硬盘。另一种叫做只追加文件(appedn-only file,AOF),他会在执行写命令时，将被执行的写命令复制到硬盘中，这两种持久化方法即可以同时使用也可以单独使用。<br>将内存的数据存储到硬盘的主要原因是为了在之后重用数据，或是为了防止系统故障将数据备份到另一个远程位置</p>\n<h4 id=\"快照持久化\"><a href=\"#快照持久化\" class=\"headerlink\" title=\"快照持久化\"></a>快照持久化</h4><p>创建快照的方法</p>\n<ul>\n<li>客户端可以通过向redis发送BGSAVE命令来创建一个快照，对于支持BGSAVE命令的平台来说，redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程继续处理命令请求。</li>\n<li>客户端还可以通过向redis发送SAVE命令来创建一个快照，接到SAVE命令的redis服务器在快照创建完毕之前不再响应任何其他请求。SAVE命令并不常用，通常只会在没有足够内存去执行BGSAVE的命令情况下，或者等待持久化操作完毕后也无所谓的情况下，才会使用SAVE.</li>\n<li>如果用户设置了save的配置选项，比如<code>save 60 10000</code>，那么redis最近一次创建快照之后开始算起，当60s之后有10000次写入，这个条件被满足以后，redis会自动触发BGSAVE命令。如果用户设置了多个save配置，当任意一个save配置条件被满足，都会触发BGSAVE。</li>\n<li>当redis通过SHUTDOWN命令接收到关闭服务器的请求时，或者接受到标准的TERM信号时，会执行一个SAVE命令，阻塞所有客户端，不在执行刻画段发送的任何命令。并在SAVE命令之后关闭服务器。</li>\n<li>当一个redis服务器链接另一个redis服务器，并向对方发送SYNC命令来开始一次复制操作的时候，如果服务器目前没有执行BGSAVE操作，或者主服务器并非刚刚执行完BGSAVE操作，那么主服务器会执行BGSAVE。     <a id=\"more\"></a>\n在只使用快照持久化来保存数据时，如果系统真的发生崩溃，那么用户将丢失最近一次生成快照之后的所有数据。因此快照持久化只适用于那些即使丢失一部分数据也不会造成问题的应用程序。</li>\n</ul>\n<h3 id=\"AOF持久化\"><a href=\"#AOF持久化\" class=\"headerlink\" title=\"AOF持久化\"></a>AOF持久化</h3><p>AOF持久化会将被执行的写命令写到AOF文件的末尾，以此来记录数据的变化。因此，redis只要从头到尾重新执行一次AOF文件包含的所有写命令，就可以恢复AOF文件所记录的数据集。appendfsync配置选项对AOF文件的同步频率的影响。</p>\n<ul>\n<li>always: 每个redis写命令都会同步写入硬盘，这样会严重降低redis的速度。</li>\n<li>everysec: 每秒执行一次同步，显式的将多个命令同步到硬盘</li>\n<li>no: 让操作系统决定何时同步</li>\n</ul>\n<h4 id=\"重写-压缩AOF文件\"><a href=\"#重写-压缩AOF文件\" class=\"headerlink\" title=\"重写/压缩AOF文件\"></a>重写/压缩AOF文件</h4><p>假如选择everysec，由于redis会不断的执行写命令记录到AOF文件中，随着redis的不断运行，AOF文件会不断增大，甚至用完硬盘所有空间。为了解决此问题，用户可以向redis发送BGREWRITEAOF，这个命令会移除AOF文件的冗余来重写AOF文件。<code>同快照持久化一样，重写需要用到子进程，由于快照持久化存在内存占中和性能问题，在AOF持久化同样存在</code>，如果不加以控制，AOF的文件会比快照文件大好几倍。<br>同快照持久化一样可以通设置save选项来自动执行BGSAVE一样，AOF持久化可以通过设置’auto-aof-rewrite-perventage’选项和<code>auto-aof-rewrite-min-size</code>选项来自动执行BGREWRITEAOF，例如，设置<code>auto-aof-rewrite-percentage 100</code>和<code>auto-aof-rewrite-min-size 64mb</code>，并且启用了AOF持久化，那么当AOF文件大于64mb，并且AOF文件的体积比上次重写之后体积增加了一倍，redis自动执行BGREWRITEAOF。<br>无论使用AOF持久化还是快照持久化，将数据持久化到硬盘上是十分有必要的，除此外，用户还需对持久化的文件进行备份，这样才能避免数据的丢失。但随着负载量的上升，或者数据的完整性越来越重要，用户可能需要复制特性。</p>\n<h4 id=\"复制-replication\"><a href=\"#复制-replication\" class=\"headerlink\" title=\"复制(replication)\"></a>复制(replication)</h4><p>复制可以让其他服务器拥有一个不断更新的数据副本，从而使得拥有数据副本的服务器可以处理客户端发送的请求。关系数据库通常会使用一个主服务器(master)向多个从服务器(salve)发送更新，并使用从服务器开处理所有请求。redis同理。<br>复制的过程如下:</p>\n<div style=\"width: 200px; margin: auto\"><img src=\"/images/AOF-replication.bmp\" alt=\"示例图片\"></div>\n\n<p>从服务器的设置:用户可以通过配置选项SLAVEOF host port来讲一个redis服务器设置为服务器，也可以通过向正在运行的redis服务器发送SLAVEOF命令来将其设置为从服务器。</p>\n<ul>\n<li>如果使用SALVEOF配置选项设置，那么redis启动时会载入当前可用的任何快照或者AOF文件，然后连接主服务器完成上图的复制过程。</li>\n<li>如果使用SALVEOF命令，那么redis会立即尝试连接主服务器，并在连接成功后开始上图的复制过程。</li>\n</ul>\n<p>当多个从服务器尝试链接同一个主服务器，有时候可重用已有的快照文件。</p>\n<div style=\"width: 200px; margin: auto\"><img src=\"/images/AOF-replication.bmp\" alt=\"示例图片\"></div>\n\n<h4 id=\"检验硬盘写入\"><a href=\"#检验硬盘写入\" class=\"headerlink\" title=\"检验硬盘写入\"></a>检验硬盘写入</h4><p>为了验证主服务器已经把数据发送至从服务器，用户需要再向主服务器写入一个唯一的虚构值(unique dummy value)，然后通过检查虚构值是否存在于从服务器来判断数据是否到达从服务器。但判断数据是否写入硬盘则相对困难，对于每秒同步一次的AOF文件，可通过等待一秒来确定数据是否写入硬盘。更节约时间的做法是检查INFO命令的输出结果中aof_pending_bio_fsync的属性是否为0，如果是的话，那么就表示服务器保存至硬盘。在向主服务器写入数据后，用户可以将二者的链接作为参数，然后执行检查。代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import time</span><br><span class=\"line\">import uuid</span><br><span class=\"line\"></span><br><span class=\"line\">##wait_for_sync</span><br><span class=\"line\">def wait_for_sync(mconn, sconn):</span><br><span class=\"line\">    identifier = str(uuid.uuid4()) #添加随机的令牌利用uuid生成</span><br><span class=\"line\">    #print(identifier)</span><br><span class=\"line\">    mconn.zadd(&apos;sync:wait&apos;, identifier, time.time())  #将令牌添加至主服务器</span><br><span class=\"line\">    </span><br><span class=\"line\">    while not sconn.info()[&apos;master_link_status&apos;] != &apos;up&apos;: #如果有必要，等待从服务器完成同步</span><br><span class=\"line\">        time.sleep(.001)</span><br><span class=\"line\">        </span><br><span class=\"line\">    while not sconn.zscore(&apos;sync:wait&apos;, identifier): #等待从服务器接受数据更新</span><br><span class=\"line\">        time.sleep(.001)</span><br><span class=\"line\">        </span><br><span class=\"line\">    deadline = time.time() + 1.01   #最多等待1s</span><br><span class=\"line\">    while time.time() &lt; deadline:</span><br><span class=\"line\">        if sconn.info()[&apos;aof_pending_bio_fsync&apos;] == 0: #检查数据是否存入了硬盘，等于0则存入</span><br><span class=\"line\">            break</span><br><span class=\"line\">        time.sleep(.001)</span><br><span class=\"line\">    mconn.zrem(&apos;sync:wait&apos;, identifier)</span><br><span class=\"line\">    mconn.zremrangebyscore(&apos;sync:wait&apos;, 0, time.time()-900) #清理刚创建的新令牌以及之前可能留下的旧令牌,900s</span><br><span class=\"line\">    </span><br><span class=\"line\">    #zremrange的使用</span><br><span class=\"line\">    #     redis&gt; ZRANGE salary 0 -1 WITHSCORES          # 显示有序集内所有成员及其 score 值</span><br><span class=\"line\">    # 1) &quot;tom&quot;</span><br><span class=\"line\">    # 2) &quot;2000&quot;</span><br><span class=\"line\">    # 3) &quot;peter&quot;</span><br><span class=\"line\">    # 4) &quot;3500&quot;</span><br><span class=\"line\">    # 5) &quot;jack&quot;</span><br><span class=\"line\">    # 6) &quot;5000&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    # redis&gt; ZREMRANGEBYSCORE salary 1500 3500      # 移除所有薪水在 1500 到 3500 内的员工</span><br><span class=\"line\">    # (integer) 2</span><br><span class=\"line\"></span><br><span class=\"line\">    # redis&gt; ZRANGE salary 0 -1 WITHSCORES          # 剩下的有序集成员</span><br><span class=\"line\">    # 1) &quot;jack&quot;</span><br><span class=\"line\">    # 2) &quot;5000&quot;</span><br></pre></td></tr></table></figure></p>\n<p>其中info命令提供了大量与redis服务器有关的信息，比如内存占用量，，客户端连接数，每个数据库包含的键的数量，上次创建快照文件之后执行的命令的数量等等。<br>为了确保操作正确执行wait_for_sync()函数会首先确认从服务器连接上主服务器，然后检查自己添加到等待同步有序集合里面的值是否存在从服务器，在发现值已经存在于从服务器，函数会检查从服务器写入缓冲区的状态，并在1s之内，等待从服务器将缓冲区的所有数据存硬盘。孙然函数等待1s，但是大部分同步会在很短的时间内完成。最后确认数据保存到硬盘，函数会执行一些清理操作。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"持久化选项\"><a href=\"#持久化选项\" class=\"headerlink\" title=\"持久化选项\"></a>持久化选项</h3><p>redis提供了两种不同的持久化方法来将数据存储到硬盘中。一种方法叫做快照(snapshotting)，他可以将某一时刻的所有数据写入硬盘。另一种叫做只追加文件(appedn-only file,AOF),他会在执行写命令时，将被执行的写命令复制到硬盘中，这两种持久化方法即可以同时使用也可以单独使用。<br>将内存的数据存储到硬盘的主要原因是为了在之后重用数据，或是为了防止系统故障将数据备份到另一个远程位置</p>\n<h4 id=\"快照持久化\"><a href=\"#快照持久化\" class=\"headerlink\" title=\"快照持久化\"></a>快照持久化</h4><p>创建快照的方法</p>\n<ul>\n<li>客户端可以通过向redis发送BGSAVE命令来创建一个快照，对于支持BGSAVE命令的平台来说，redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程继续处理命令请求。</li>\n<li>客户端还可以通过向redis发送SAVE命令来创建一个快照，接到SAVE命令的redis服务器在快照创建完毕之前不再响应任何其他请求。SAVE命令并不常用，通常只会在没有足够内存去执行BGSAVE的命令情况下，或者等待持久化操作完毕后也无所谓的情况下，才会使用SAVE.</li>\n<li>如果用户设置了save的配置选项，比如<code>save 60 10000</code>，那么redis最近一次创建快照之后开始算起，当60s之后有10000次写入，这个条件被满足以后，redis会自动触发BGSAVE命令。如果用户设置了多个save配置，当任意一个save配置条件被满足，都会触发BGSAVE。</li>\n<li>当redis通过SHUTDOWN命令接收到关闭服务器的请求时，或者接受到标准的TERM信号时，会执行一个SAVE命令，阻塞所有客户端，不在执行刻画段发送的任何命令。并在SAVE命令之后关闭服务器。</li>\n<li>当一个redis服务器链接另一个redis服务器，并向对方发送SYNC命令来开始一次复制操作的时候，如果服务器目前没有执行BGSAVE操作，或者主服务器并非刚刚执行完BGSAVE操作，那么主服务器会执行BGSAVE。","more":"在只使用快照持久化来保存数据时，如果系统真的发生崩溃，那么用户将丢失最近一次生成快照之后的所有数据。因此快照持久化只适用于那些即使丢失一部分数据也不会造成问题的应用程序。</li>\n</ul>\n<h3 id=\"AOF持久化\"><a href=\"#AOF持久化\" class=\"headerlink\" title=\"AOF持久化\"></a>AOF持久化</h3><p>AOF持久化会将被执行的写命令写到AOF文件的末尾，以此来记录数据的变化。因此，redis只要从头到尾重新执行一次AOF文件包含的所有写命令，就可以恢复AOF文件所记录的数据集。appendfsync配置选项对AOF文件的同步频率的影响。</p>\n<ul>\n<li>always: 每个redis写命令都会同步写入硬盘，这样会严重降低redis的速度。</li>\n<li>everysec: 每秒执行一次同步，显式的将多个命令同步到硬盘</li>\n<li>no: 让操作系统决定何时同步</li>\n</ul>\n<h4 id=\"重写-压缩AOF文件\"><a href=\"#重写-压缩AOF文件\" class=\"headerlink\" title=\"重写/压缩AOF文件\"></a>重写/压缩AOF文件</h4><p>假如选择everysec，由于redis会不断的执行写命令记录到AOF文件中，随着redis的不断运行，AOF文件会不断增大，甚至用完硬盘所有空间。为了解决此问题，用户可以向redis发送BGREWRITEAOF，这个命令会移除AOF文件的冗余来重写AOF文件。<code>同快照持久化一样，重写需要用到子进程，由于快照持久化存在内存占中和性能问题，在AOF持久化同样存在</code>，如果不加以控制，AOF的文件会比快照文件大好几倍。<br>同快照持久化一样可以通设置save选项来自动执行BGSAVE一样，AOF持久化可以通过设置’auto-aof-rewrite-perventage’选项和<code>auto-aof-rewrite-min-size</code>选项来自动执行BGREWRITEAOF，例如，设置<code>auto-aof-rewrite-percentage 100</code>和<code>auto-aof-rewrite-min-size 64mb</code>，并且启用了AOF持久化，那么当AOF文件大于64mb，并且AOF文件的体积比上次重写之后体积增加了一倍，redis自动执行BGREWRITEAOF。<br>无论使用AOF持久化还是快照持久化，将数据持久化到硬盘上是十分有必要的，除此外，用户还需对持久化的文件进行备份，这样才能避免数据的丢失。但随着负载量的上升，或者数据的完整性越来越重要，用户可能需要复制特性。</p>\n<h4 id=\"复制-replication\"><a href=\"#复制-replication\" class=\"headerlink\" title=\"复制(replication)\"></a>复制(replication)</h4><p>复制可以让其他服务器拥有一个不断更新的数据副本，从而使得拥有数据副本的服务器可以处理客户端发送的请求。关系数据库通常会使用一个主服务器(master)向多个从服务器(salve)发送更新，并使用从服务器开处理所有请求。redis同理。<br>复制的过程如下:</p>\n<div style=\"width: 200px; margin: auto\"><img src=\"/images/AOF-replication.bmp\" alt=\"示例图片\"></div>\n\n<p>从服务器的设置:用户可以通过配置选项SLAVEOF host port来讲一个redis服务器设置为服务器，也可以通过向正在运行的redis服务器发送SLAVEOF命令来将其设置为从服务器。</p>\n<ul>\n<li>如果使用SALVEOF配置选项设置，那么redis启动时会载入当前可用的任何快照或者AOF文件，然后连接主服务器完成上图的复制过程。</li>\n<li>如果使用SALVEOF命令，那么redis会立即尝试连接主服务器，并在连接成功后开始上图的复制过程。</li>\n</ul>\n<p>当多个从服务器尝试链接同一个主服务器，有时候可重用已有的快照文件。</p>\n<div style=\"width: 200px; margin: auto\"><img src=\"/images/AOF-replication.bmp\" alt=\"示例图片\"></div>\n\n<h4 id=\"检验硬盘写入\"><a href=\"#检验硬盘写入\" class=\"headerlink\" title=\"检验硬盘写入\"></a>检验硬盘写入</h4><p>为了验证主服务器已经把数据发送至从服务器，用户需要再向主服务器写入一个唯一的虚构值(unique dummy value)，然后通过检查虚构值是否存在于从服务器来判断数据是否到达从服务器。但判断数据是否写入硬盘则相对困难，对于每秒同步一次的AOF文件，可通过等待一秒来确定数据是否写入硬盘。更节约时间的做法是检查INFO命令的输出结果中aof_pending_bio_fsync的属性是否为0，如果是的话，那么就表示服务器保存至硬盘。在向主服务器写入数据后，用户可以将二者的链接作为参数，然后执行检查。代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import time</span><br><span class=\"line\">import uuid</span><br><span class=\"line\"></span><br><span class=\"line\">##wait_for_sync</span><br><span class=\"line\">def wait_for_sync(mconn, sconn):</span><br><span class=\"line\">    identifier = str(uuid.uuid4()) #添加随机的令牌利用uuid生成</span><br><span class=\"line\">    #print(identifier)</span><br><span class=\"line\">    mconn.zadd(&apos;sync:wait&apos;, identifier, time.time())  #将令牌添加至主服务器</span><br><span class=\"line\">    </span><br><span class=\"line\">    while not sconn.info()[&apos;master_link_status&apos;] != &apos;up&apos;: #如果有必要，等待从服务器完成同步</span><br><span class=\"line\">        time.sleep(.001)</span><br><span class=\"line\">        </span><br><span class=\"line\">    while not sconn.zscore(&apos;sync:wait&apos;, identifier): #等待从服务器接受数据更新</span><br><span class=\"line\">        time.sleep(.001)</span><br><span class=\"line\">        </span><br><span class=\"line\">    deadline = time.time() + 1.01   #最多等待1s</span><br><span class=\"line\">    while time.time() &lt; deadline:</span><br><span class=\"line\">        if sconn.info()[&apos;aof_pending_bio_fsync&apos;] == 0: #检查数据是否存入了硬盘，等于0则存入</span><br><span class=\"line\">            break</span><br><span class=\"line\">        time.sleep(.001)</span><br><span class=\"line\">    mconn.zrem(&apos;sync:wait&apos;, identifier)</span><br><span class=\"line\">    mconn.zremrangebyscore(&apos;sync:wait&apos;, 0, time.time()-900) #清理刚创建的新令牌以及之前可能留下的旧令牌,900s</span><br><span class=\"line\">    </span><br><span class=\"line\">    #zremrange的使用</span><br><span class=\"line\">    #     redis&gt; ZRANGE salary 0 -1 WITHSCORES          # 显示有序集内所有成员及其 score 值</span><br><span class=\"line\">    # 1) &quot;tom&quot;</span><br><span class=\"line\">    # 2) &quot;2000&quot;</span><br><span class=\"line\">    # 3) &quot;peter&quot;</span><br><span class=\"line\">    # 4) &quot;3500&quot;</span><br><span class=\"line\">    # 5) &quot;jack&quot;</span><br><span class=\"line\">    # 6) &quot;5000&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    # redis&gt; ZREMRANGEBYSCORE salary 1500 3500      # 移除所有薪水在 1500 到 3500 内的员工</span><br><span class=\"line\">    # (integer) 2</span><br><span class=\"line\"></span><br><span class=\"line\">    # redis&gt; ZRANGE salary 0 -1 WITHSCORES          # 剩下的有序集成员</span><br><span class=\"line\">    # 1) &quot;jack&quot;</span><br><span class=\"line\">    # 2) &quot;5000&quot;</span><br></pre></td></tr></table></figure></p>\n<p>其中info命令提供了大量与redis服务器有关的信息，比如内存占用量，，客户端连接数，每个数据库包含的键的数量，上次创建快照文件之后执行的命令的数量等等。<br>为了确保操作正确执行wait_for_sync()函数会首先确认从服务器连接上主服务器，然后检查自己添加到等待同步有序集合里面的值是否存在从服务器，在发现值已经存在于从服务器，函数会检查从服务器写入缓冲区的状态，并在1s之内，等待从服务器将缓冲区的所有数据存硬盘。孙然函数等待1s，但是大部分同步会在很短的时间内完成。最后确认数据保存到硬盘，函数会执行一些清理操作。</p>"},{"layout":"posts","title":"docker部署记录文件","date":"2019-04-15T15:21:05.000Z","_content":"###<center>dokcer部署</center>\n\n1. 首先把需要映射的文件放到某个固定文件夹下，如我的目录在`/opt/nginx-powerpred/`下面分别有四个文件夹,`/conf/nginx.conf`,`/log/access.log和/log/error.log`,`/sites-enabled/powerpred.cc`用来配置nginx,`/www/powerpred/*`为网页文件。\n2. 其中powerpred的内容如下:\n```\nserver {\n    charset utf-8;\n    listen 8000;\n    server_name localhost;\n    \n    location /static {\n\talias /var/www/static;\n\t}\n    location / {\n\tproxy_set_header Host $host;\n\tproxy_pass http://unix:/tmp/windystreet.cn.socket;\n\n\t}\n}\n```\n这里监听8000端口，是因为后面我们会把docker的8000端口映射到宿主机的80端口，那么在docker内监听的8000端口。\n3.映射的命令，目录位于`/opt/nginx-powerpred/`,\n```\n docker run -it -p 80:8000 \n -v $PWD/conf/nginx.conf:/ect/nginx/nginx.conf \n -v $PWD/log/access.log:/var/log/nginx/access.log \n -v $PWD/log/error.log:/var/log/nginx/error.log \n -v $PWD/sites-enabled/powerpred.cc:/etc/nginx/sites-enabled/powerpred.cc \n -v $PWD/www/powerpred:/opt/www/powerpred/ 15c /bin/bash\n\n```\n4.运行完上述命令，进入到容器内部，可以先`python3 manage.py collectstatic`收集静态文件，然后`service nginx start`,此时nginx启动了，再使用`gunicorn --bind unix:/tmp/windystreet.cn.socket ppower.wsgi:application`运行即可。\n","source":"_posts/docker部署记录文件.md","raw":"---\nlayout: posts\ntitle: docker部署记录文件\ndate: 2019-04-15 23:21:05\ntags: docker\ncategories: docker\n---\n###<center>dokcer部署</center>\n\n1. 首先把需要映射的文件放到某个固定文件夹下，如我的目录在`/opt/nginx-powerpred/`下面分别有四个文件夹,`/conf/nginx.conf`,`/log/access.log和/log/error.log`,`/sites-enabled/powerpred.cc`用来配置nginx,`/www/powerpred/*`为网页文件。\n2. 其中powerpred的内容如下:\n```\nserver {\n    charset utf-8;\n    listen 8000;\n    server_name localhost;\n    \n    location /static {\n\talias /var/www/static;\n\t}\n    location / {\n\tproxy_set_header Host $host;\n\tproxy_pass http://unix:/tmp/windystreet.cn.socket;\n\n\t}\n}\n```\n这里监听8000端口，是因为后面我们会把docker的8000端口映射到宿主机的80端口，那么在docker内监听的8000端口。\n3.映射的命令，目录位于`/opt/nginx-powerpred/`,\n```\n docker run -it -p 80:8000 \n -v $PWD/conf/nginx.conf:/ect/nginx/nginx.conf \n -v $PWD/log/access.log:/var/log/nginx/access.log \n -v $PWD/log/error.log:/var/log/nginx/error.log \n -v $PWD/sites-enabled/powerpred.cc:/etc/nginx/sites-enabled/powerpred.cc \n -v $PWD/www/powerpred:/opt/www/powerpred/ 15c /bin/bash\n\n```\n4.运行完上述命令，进入到容器内部，可以先`python3 manage.py collectstatic`收集静态文件，然后`service nginx start`,此时nginx启动了，再使用`gunicorn --bind unix:/tmp/windystreet.cn.socket ppower.wsgi:application`运行即可。\n","slug":"docker部署记录文件","published":1,"updated":"2022-05-20T02:24:20.541Z","comments":1,"photos":[],"link":"","_id":"cl3e0vh7q001tlae1g8mvb8ia","content":"<p>###<center>dokcer部署</center></p>\n<ol>\n<li>首先把需要映射的文件放到某个固定文件夹下，如我的目录在<code>/opt/nginx-powerpred/</code>下面分别有四个文件夹,<code>/conf/nginx.conf</code>,<code>/log/access.log和/log/error.log</code>,<code>/sites-enabled/powerpred.cc</code>用来配置nginx,<code>/www/powerpred/*</code>为网页文件。</li>\n<li>其中powerpred的内容如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    charset utf-8;</span><br><span class=\"line\">    listen 8000;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\">    </span><br><span class=\"line\">    location /static &#123;</span><br><span class=\"line\">\talias /var/www/static;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">\tproxy_set_header Host $host;</span><br><span class=\"line\">\tproxy_pass http://unix:/tmp/windystreet.cn.socket;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这里监听8000端口，是因为后面我们会把docker的8000端口映射到宿主机的80端口，那么在docker内监听的8000端口。<br>3.映射的命令，目录位于<code>/opt/nginx-powerpred/</code>,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -p 80:8000 </span><br><span class=\"line\">-v $PWD/conf/nginx.conf:/ect/nginx/nginx.conf </span><br><span class=\"line\">-v $PWD/log/access.log:/var/log/nginx/access.log </span><br><span class=\"line\">-v $PWD/log/error.log:/var/log/nginx/error.log </span><br><span class=\"line\">-v $PWD/sites-enabled/powerpred.cc:/etc/nginx/sites-enabled/powerpred.cc </span><br><span class=\"line\">-v $PWD/www/powerpred:/opt/www/powerpred/ 15c /bin/bash</span><br></pre></td></tr></table></figure></p>\n<p>4.运行完上述命令，进入到容器内部，可以先<code>python3 manage.py collectstatic</code>收集静态文件，然后<code>service nginx start</code>,此时nginx启动了，再使用<code>gunicorn --bind unix:/tmp/windystreet.cn.socket ppower.wsgi:application</code>运行即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>###<center>dokcer部署</center></p>\n<ol>\n<li>首先把需要映射的文件放到某个固定文件夹下，如我的目录在<code>/opt/nginx-powerpred/</code>下面分别有四个文件夹,<code>/conf/nginx.conf</code>,<code>/log/access.log和/log/error.log</code>,<code>/sites-enabled/powerpred.cc</code>用来配置nginx,<code>/www/powerpred/*</code>为网页文件。</li>\n<li>其中powerpred的内容如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    charset utf-8;</span><br><span class=\"line\">    listen 8000;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\">    </span><br><span class=\"line\">    location /static &#123;</span><br><span class=\"line\">\talias /var/www/static;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">\tproxy_set_header Host $host;</span><br><span class=\"line\">\tproxy_pass http://unix:/tmp/windystreet.cn.socket;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这里监听8000端口，是因为后面我们会把docker的8000端口映射到宿主机的80端口，那么在docker内监听的8000端口。<br>3.映射的命令，目录位于<code>/opt/nginx-powerpred/</code>,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -p 80:8000 </span><br><span class=\"line\">-v $PWD/conf/nginx.conf:/ect/nginx/nginx.conf </span><br><span class=\"line\">-v $PWD/log/access.log:/var/log/nginx/access.log </span><br><span class=\"line\">-v $PWD/log/error.log:/var/log/nginx/error.log </span><br><span class=\"line\">-v $PWD/sites-enabled/powerpred.cc:/etc/nginx/sites-enabled/powerpred.cc </span><br><span class=\"line\">-v $PWD/www/powerpred:/opt/www/powerpred/ 15c /bin/bash</span><br></pre></td></tr></table></figure></p>\n<p>4.运行完上述命令，进入到容器内部，可以先<code>python3 manage.py collectstatic</code>收集静态文件，然后<code>service nginx start</code>,此时nginx启动了，再使用<code>gunicorn --bind unix:/tmp/windystreet.cn.socket ppower.wsgi:application</code>运行即可。</p>\n"},{"layout":"posts","title":"tcp/ip-1","date":"2019-04-22T02:06:36.000Z","_content":"\n### 计算机与网络发展的七个阶段\n\n1. 批处理: 为了能让更多的人使用计算机，出现了批处理(batch processing)系统。所谓批处理，是指事先将用户程序和数据装入卡带或者磁盘，并由计算机按照一定的顺序读取。使用户所要执行的这些程序和数据能够一并得到批量处理的方式。批处理时代的计算机主要用于大规模的计算或者处理，那时的计算机上不是一个便于普通人使用的工具。wait img\n\n2. 分时系统:继批处理之后，20世纪60年代出现了分时系统(TSS, Time Sharing System)。它是指多个终端与同一台计算机相连，允许多个用户同时使用同一台计算机系统。分时系统中每个终端与计算机之间使用通信线路连接成一个星型结构。从这一世纪开始，网络通信与计算机之间的关系逐渐浮出。\n\n3. 计算机之间的通信:在分时系统中，计算机与每个终端使用通信线路相连，但并不意味着计算机计算机之间也已经相互连接。在计算机的通信技术诞生之前，想要将一台计算机的数据转移到另一台计算机，需要借助磁盘，软盘等。然而有了计算机通信技术，人们可以很方便的读取另一台计算机的数据。\n\n4. 计算机网络的产生: 20世纪70年代，人们开始实验基于分组交换技术的计算机网络，并着手研究不同厂商的计算机的通信技术。80年代，一种能够互联多种计算机的网络诞生，可以使计算机相互连接，窗口系统的诞生，也使得操作更加便捷。\n\n5. 互联网的普及 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/tcp-ip-1.md","raw":"---\nlayout: posts\ntitle: tcp/ip-1\ndate: 2019-04-22 10:06:36\ntags: Tcp\ncategories: Tcp\n---\n\n### 计算机与网络发展的七个阶段\n\n1. 批处理: 为了能让更多的人使用计算机，出现了批处理(batch processing)系统。所谓批处理，是指事先将用户程序和数据装入卡带或者磁盘，并由计算机按照一定的顺序读取。使用户所要执行的这些程序和数据能够一并得到批量处理的方式。批处理时代的计算机主要用于大规模的计算或者处理，那时的计算机上不是一个便于普通人使用的工具。wait img\n\n2. 分时系统:继批处理之后，20世纪60年代出现了分时系统(TSS, Time Sharing System)。它是指多个终端与同一台计算机相连，允许多个用户同时使用同一台计算机系统。分时系统中每个终端与计算机之间使用通信线路连接成一个星型结构。从这一世纪开始，网络通信与计算机之间的关系逐渐浮出。\n\n3. 计算机之间的通信:在分时系统中，计算机与每个终端使用通信线路相连，但并不意味着计算机计算机之间也已经相互连接。在计算机的通信技术诞生之前，想要将一台计算机的数据转移到另一台计算机，需要借助磁盘，软盘等。然而有了计算机通信技术，人们可以很方便的读取另一台计算机的数据。\n\n4. 计算机网络的产生: 20世纪70年代，人们开始实验基于分组交换技术的计算机网络，并着手研究不同厂商的计算机的通信技术。80年代，一种能够互联多种计算机的网络诞生，可以使计算机相互连接，窗口系统的诞生，也使得操作更加便捷。\n\n5. 互联网的普及 6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"tcp-ip-1","published":1,"updated":"2022-05-20T02:24:20.543Z","comments":1,"photos":[],"link":"","_id":"cl3e0vh7r001xlae15gkjdl50","content":"<h3 id=\"计算机与网络发展的七个阶段\"><a href=\"#计算机与网络发展的七个阶段\" class=\"headerlink\" title=\"计算机与网络发展的七个阶段\"></a>计算机与网络发展的七个阶段</h3><ol>\n<li><p>批处理: 为了能让更多的人使用计算机，出现了批处理(batch processing)系统。所谓批处理，是指事先将用户程序和数据装入卡带或者磁盘，并由计算机按照一定的顺序读取。使用户所要执行的这些程序和数据能够一并得到批量处理的方式。批处理时代的计算机主要用于大规模的计算或者处理，那时的计算机上不是一个便于普通人使用的工具。wait img</p>\n</li>\n<li><p>分时系统:继批处理之后，20世纪60年代出现了分时系统(TSS, Time Sharing System)。它是指多个终端与同一台计算机相连，允许多个用户同时使用同一台计算机系统。分时系统中每个终端与计算机之间使用通信线路连接成一个星型结构。从这一世纪开始，网络通信与计算机之间的关系逐渐浮出。</p>\n</li>\n<li><p>计算机之间的通信:在分时系统中，计算机与每个终端使用通信线路相连，但并不意味着计算机计算机之间也已经相互连接。在计算机的通信技术诞生之前，想要将一台计算机的数据转移到另一台计算机，需要借助磁盘，软盘等。然而有了计算机通信技术，人们可以很方便的读取另一台计算机的数据。</p>\n</li>\n<li><p>计算机网络的产生: 20世纪70年代，人们开始实验基于分组交换技术的计算机网络，并着手研究不同厂商的计算机的通信技术。80年代，一种能够互联多种计算机的网络诞生，可以使计算机相互连接，窗口系统的诞生，也使得操作更加便捷。</p>\n</li>\n<li><p>互联网的普及 6</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"计算机与网络发展的七个阶段\"><a href=\"#计算机与网络发展的七个阶段\" class=\"headerlink\" title=\"计算机与网络发展的七个阶段\"></a>计算机与网络发展的七个阶段</h3><ol>\n<li><p>批处理: 为了能让更多的人使用计算机，出现了批处理(batch processing)系统。所谓批处理，是指事先将用户程序和数据装入卡带或者磁盘，并由计算机按照一定的顺序读取。使用户所要执行的这些程序和数据能够一并得到批量处理的方式。批处理时代的计算机主要用于大规模的计算或者处理，那时的计算机上不是一个便于普通人使用的工具。wait img</p>\n</li>\n<li><p>分时系统:继批处理之后，20世纪60年代出现了分时系统(TSS, Time Sharing System)。它是指多个终端与同一台计算机相连，允许多个用户同时使用同一台计算机系统。分时系统中每个终端与计算机之间使用通信线路连接成一个星型结构。从这一世纪开始，网络通信与计算机之间的关系逐渐浮出。</p>\n</li>\n<li><p>计算机之间的通信:在分时系统中，计算机与每个终端使用通信线路相连，但并不意味着计算机计算机之间也已经相互连接。在计算机的通信技术诞生之前，想要将一台计算机的数据转移到另一台计算机，需要借助磁盘，软盘等。然而有了计算机通信技术，人们可以很方便的读取另一台计算机的数据。</p>\n</li>\n<li><p>计算机网络的产生: 20世纪70年代，人们开始实验基于分组交换技术的计算机网络，并着手研究不同厂商的计算机的通信技术。80年代，一种能够互联多种计算机的网络诞生，可以使计算机相互连接，窗口系统的诞生，也使得操作更加便捷。</p>\n</li>\n<li><p>互联网的普及 6</p>\n</li>\n</ol>\n"},{"title":"socket通信","date":"2018-12-19T02:33:09.000Z","_content":"\n### <center>socket编程</center>\n\npython提供了两个基本的socket模块:\n- Socket 它提供了标准的BSD Socket API.\n- SocketServer 它提供了服务器重心，可以简化网络服务的开发。\n<!--more -->\n### Socker类型\n - socket.AF_UNIX: 用于同一台机器上的进程通讯(即本机通讯)\n - socket.AF_INET: 用于服务器与服务器之间的网络通讯\n - socket.AF_INET6: 基于IPV6方式的服务器与服务器之间的网络通讯\n - socket.SOCK_STREAM: 基于TCP的流式socket通信\n - socket.SOCK_DGRAM: 基于UDP的数据报式socket通信\n - socket.SOCK_RAW: 原始套接字，普通的套接字无法处理ICMP,IGMP等网络报文，而SOCK_RAW可以；其次SOCK_RAW也可以处理特殊的IPV4报头;此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造ip头\n - socket.SOCK_SEQPACKET:可靠的连续数据包服务\n \n 创建TCP Socket:\n ```\n sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n ```\n 创建UDP Socket:\n ```\n sock = sock.socket(socket.AF_INET,socket.SOCK_DGRAM)\n ```\n \n ###Socket 函数\n- TCP 在发送数据时，已经建立好TCP链接，所以不需要指定地址，而UDP是面向无链接的，每次发送都需要指定法送给谁。\n- 服务器与客户端不能直接发送列表，字典，元素等带有数据类型的数据，发送的内容必须是字符串数据\n\n### 服务器段Socket函数\n\n- s.bind(address):将套接字绑定到地址，在AF_INET下，以tuple(host,port)方式传入,如s.bind((host, port))\n- s.listen(backlog):开始监听TCP传入链接，backlog指定在拒绝连接前，操作系统可以挂起的最大连接数，该值最少为1，大部分程序设定为5就够了。\n- s.accept():接受TCP链接并返回(conn, address),其中conn是新的套接字对象们可以用来发送和接收数据，address是链接客户端地址。\n\n### 客户端Socket函数\n\n- s.connect(address): 链接到address处的套接字，一般address的格式为tuple(host,port),如果链接出错，返回socket.error错误\n- s.connect_ex(address): 功能与s.connect(address)相同,但成功返回0，失败返回errno的值\n\n\n### 公共socket函数\n\n- s.recv(bufsize[,flag]): 接受TCP套接字的数据，数据以字符串的形式返回，buffsize指定要接受的最大数据量，flag提供有关消息的其他信息，通常可以忽略。\n- s.send(string[,flag]): 发送TCP数据，将字符串的数据发送到链接的套接字，返回值是要发送的字节的数量，该数量可能小鱼string的字节大小\n- s.sendall(string[,falg]): 完整发送TCP数据，将字符串的数据发送到链接的套接字，但在返回之前尝试发送所有数据，成功返回None，失败则抛出异常\n- s.recvfrom(bufsize[,flag]): 接受UDP的套接字数据u，与recv()类似，但返回值是tuple(data,address).其中data是包含接收数据的字符串，address是发送数据的地址\n- s.sendto(string[,flag],address): 发送UDP数据，将数据发送到套接字，address形式为tuple(ipaddr,port),指定远程地址发送，返回值是发送的字节数、\n- s.close(): 关闭套接字\n- s.getpeername():返回套接字的远程地址，返回值通常是一个tuple(ipaddr,port)\n- s.getsocketname():返回套接字自己的地址,返回值通常是一个tuple(ipaddr,port)\n- s.setsocketopt(level, optname[,buflen]): 设置给定套接字选项的值\n- s.getsocketopt(level, optname[,buflen]): 返回套接字选项的值\n- s.settimeout(timeout):设置套接字的超时时间，timeout是一个浮点数，单位是s，值为None则表示永远不会超时。一般超时期应在刚创建套接字时设置，因为他们可能用于连接的操作，如s.connect()\n- s.gettimeout():返回当前的超时值，单位是s，如何没有设置超时时间则返回None\n- s.fileno():返回套接字的文件描述\n- s.setblocking(flag):如果flag为0，则将套接字设为非阻塞模式(默认值)，非阻塞模式下，如果调用recv()没发现任何数据，或者send()调用无法立即发送数据，那么将引起socket.error异常\n- s.makefile(): 创建一个与该套接字相关的文件\n \n## Socket编程思想\n\n### TCP服务器\n1.创建套接字，绑定套接字到本地IP与端口\n```\ns = socket.socket(scoket.AF_INET,socket.SOCK_STREAM)\ns.bind()\n```\n2.开始监听链接\n```\ns.listen()\n```\n3.进入循环不断接受客户端连接请求\n```\nwhile True:\n    s.accept()\n```\n4.接受客户端传来的数据，并且给对方发送数据\n```\ns.recv()\ns.sendall()\n```\n5.传输完毕后，关闭套接字\n```\ns.close()\n```\n### TCP客户端\n1.创建套接字并连接至远端地址\n```\ns = socket.socket(socket.AF_INET,socket.SOCK_STREAM)\ns.connect()\n```\n2.链接后发送数据和接收数据\n```\ns.sendall();\ns.recv()\n```\n3.传输完毕后，关闭套接字\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n ","source":"_posts/socket.mkd","raw":"---\ntitle: socket通信\ndate: 2018-12-19 10:33:09\ntags: 网络编程\ncategories: socket\n---\n\n### <center>socket编程</center>\n\npython提供了两个基本的socket模块:\n- Socket 它提供了标准的BSD Socket API.\n- SocketServer 它提供了服务器重心，可以简化网络服务的开发。\n<!--more -->\n### Socker类型\n - socket.AF_UNIX: 用于同一台机器上的进程通讯(即本机通讯)\n - socket.AF_INET: 用于服务器与服务器之间的网络通讯\n - socket.AF_INET6: 基于IPV6方式的服务器与服务器之间的网络通讯\n - socket.SOCK_STREAM: 基于TCP的流式socket通信\n - socket.SOCK_DGRAM: 基于UDP的数据报式socket通信\n - socket.SOCK_RAW: 原始套接字，普通的套接字无法处理ICMP,IGMP等网络报文，而SOCK_RAW可以；其次SOCK_RAW也可以处理特殊的IPV4报头;此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造ip头\n - socket.SOCK_SEQPACKET:可靠的连续数据包服务\n \n 创建TCP Socket:\n ```\n sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n ```\n 创建UDP Socket:\n ```\n sock = sock.socket(socket.AF_INET,socket.SOCK_DGRAM)\n ```\n \n ###Socket 函数\n- TCP 在发送数据时，已经建立好TCP链接，所以不需要指定地址，而UDP是面向无链接的，每次发送都需要指定法送给谁。\n- 服务器与客户端不能直接发送列表，字典，元素等带有数据类型的数据，发送的内容必须是字符串数据\n\n### 服务器段Socket函数\n\n- s.bind(address):将套接字绑定到地址，在AF_INET下，以tuple(host,port)方式传入,如s.bind((host, port))\n- s.listen(backlog):开始监听TCP传入链接，backlog指定在拒绝连接前，操作系统可以挂起的最大连接数，该值最少为1，大部分程序设定为5就够了。\n- s.accept():接受TCP链接并返回(conn, address),其中conn是新的套接字对象们可以用来发送和接收数据，address是链接客户端地址。\n\n### 客户端Socket函数\n\n- s.connect(address): 链接到address处的套接字，一般address的格式为tuple(host,port),如果链接出错，返回socket.error错误\n- s.connect_ex(address): 功能与s.connect(address)相同,但成功返回0，失败返回errno的值\n\n\n### 公共socket函数\n\n- s.recv(bufsize[,flag]): 接受TCP套接字的数据，数据以字符串的形式返回，buffsize指定要接受的最大数据量，flag提供有关消息的其他信息，通常可以忽略。\n- s.send(string[,flag]): 发送TCP数据，将字符串的数据发送到链接的套接字，返回值是要发送的字节的数量，该数量可能小鱼string的字节大小\n- s.sendall(string[,falg]): 完整发送TCP数据，将字符串的数据发送到链接的套接字，但在返回之前尝试发送所有数据，成功返回None，失败则抛出异常\n- s.recvfrom(bufsize[,flag]): 接受UDP的套接字数据u，与recv()类似，但返回值是tuple(data,address).其中data是包含接收数据的字符串，address是发送数据的地址\n- s.sendto(string[,flag],address): 发送UDP数据，将数据发送到套接字，address形式为tuple(ipaddr,port),指定远程地址发送，返回值是发送的字节数、\n- s.close(): 关闭套接字\n- s.getpeername():返回套接字的远程地址，返回值通常是一个tuple(ipaddr,port)\n- s.getsocketname():返回套接字自己的地址,返回值通常是一个tuple(ipaddr,port)\n- s.setsocketopt(level, optname[,buflen]): 设置给定套接字选项的值\n- s.getsocketopt(level, optname[,buflen]): 返回套接字选项的值\n- s.settimeout(timeout):设置套接字的超时时间，timeout是一个浮点数，单位是s，值为None则表示永远不会超时。一般超时期应在刚创建套接字时设置，因为他们可能用于连接的操作，如s.connect()\n- s.gettimeout():返回当前的超时值，单位是s，如何没有设置超时时间则返回None\n- s.fileno():返回套接字的文件描述\n- s.setblocking(flag):如果flag为0，则将套接字设为非阻塞模式(默认值)，非阻塞模式下，如果调用recv()没发现任何数据，或者send()调用无法立即发送数据，那么将引起socket.error异常\n- s.makefile(): 创建一个与该套接字相关的文件\n \n## Socket编程思想\n\n### TCP服务器\n1.创建套接字，绑定套接字到本地IP与端口\n```\ns = socket.socket(scoket.AF_INET,socket.SOCK_STREAM)\ns.bind()\n```\n2.开始监听链接\n```\ns.listen()\n```\n3.进入循环不断接受客户端连接请求\n```\nwhile True:\n    s.accept()\n```\n4.接受客户端传来的数据，并且给对方发送数据\n```\ns.recv()\ns.sendall()\n```\n5.传输完毕后，关闭套接字\n```\ns.close()\n```\n### TCP客户端\n1.创建套接字并连接至远端地址\n```\ns = socket.socket(socket.AF_INET,socket.SOCK_STREAM)\ns.connect()\n```\n2.链接后发送数据和接收数据\n```\ns.sendall();\ns.recv()\n```\n3.传输完毕后，关闭套接字\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n ","slug":"socket","published":1,"updated":"2022-05-20T02:24:20.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7s001zlae1mke69nl0","content":"<h3 id=\"socket编程\"><a href=\"#socket编程\" class=\"headerlink\" title=\"socket编程\"></a><center>socket编程</center></h3><p>python提供了两个基本的socket模块:</p>\n<ul>\n<li>Socket 它提供了标准的BSD Socket API.</li>\n<li><p>SocketServer 它提供了服务器重心，可以简化网络服务的开发。</p>\n<a id=\"more\"></a>\n<h3 id=\"Socker类型\"><a href=\"#Socker类型\" class=\"headerlink\" title=\"Socker类型\"></a>Socker类型</h3><ul>\n<li>socket.AF_UNIX: 用于同一台机器上的进程通讯(即本机通讯)</li>\n<li>socket.AF_INET: 用于服务器与服务器之间的网络通讯</li>\n<li>socket.AF_INET6: 基于IPV6方式的服务器与服务器之间的网络通讯</li>\n<li>socket.SOCK_STREAM: 基于TCP的流式socket通信</li>\n<li>socket.SOCK_DGRAM: 基于UDP的数据报式socket通信</li>\n<li>socket.SOCK_RAW: 原始套接字，普通的套接字无法处理ICMP,IGMP等网络报文，而SOCK_RAW可以；其次SOCK_RAW也可以处理特殊的IPV4报头;此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造ip头</li>\n<li>socket.SOCK_SEQPACKET:可靠的连续数据包服务</li>\n</ul>\n<p>创建TCP Socket:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br></pre></td></tr></table></figure>\n<p>创建UDP Socket:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sock = sock.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p> ###Socket 函数</p>\n<ul>\n<li>TCP 在发送数据时，已经建立好TCP链接，所以不需要指定地址，而UDP是面向无链接的，每次发送都需要指定法送给谁。</li>\n<li>服务器与客户端不能直接发送列表，字典，元素等带有数据类型的数据，发送的内容必须是字符串数据</li>\n</ul>\n<h3 id=\"服务器段Socket函数\"><a href=\"#服务器段Socket函数\" class=\"headerlink\" title=\"服务器段Socket函数\"></a>服务器段Socket函数</h3><ul>\n<li>s.bind(address):将套接字绑定到地址，在AF_INET下，以tuple(host,port)方式传入,如s.bind((host, port))</li>\n<li>s.listen(backlog):开始监听TCP传入链接，backlog指定在拒绝连接前，操作系统可以挂起的最大连接数，该值最少为1，大部分程序设定为5就够了。</li>\n<li>s.accept():接受TCP链接并返回(conn, address),其中conn是新的套接字对象们可以用来发送和接收数据，address是链接客户端地址。</li>\n</ul>\n<h3 id=\"客户端Socket函数\"><a href=\"#客户端Socket函数\" class=\"headerlink\" title=\"客户端Socket函数\"></a>客户端Socket函数</h3><ul>\n<li>s.connect(address): 链接到address处的套接字，一般address的格式为tuple(host,port),如果链接出错，返回socket.error错误</li>\n<li>s.connect_ex(address): 功能与s.connect(address)相同,但成功返回0，失败返回errno的值</li>\n</ul>\n<h3 id=\"公共socket函数\"><a href=\"#公共socket函数\" class=\"headerlink\" title=\"公共socket函数\"></a>公共socket函数</h3><ul>\n<li>s.recv(bufsize[,flag]): 接受TCP套接字的数据，数据以字符串的形式返回，buffsize指定要接受的最大数据量，flag提供有关消息的其他信息，通常可以忽略。</li>\n<li>s.send(string[,flag]): 发送TCP数据，将字符串的数据发送到链接的套接字，返回值是要发送的字节的数量，该数量可能小鱼string的字节大小</li>\n<li>s.sendall(string[,falg]): 完整发送TCP数据，将字符串的数据发送到链接的套接字，但在返回之前尝试发送所有数据，成功返回None，失败则抛出异常</li>\n<li>s.recvfrom(bufsize[,flag]): 接受UDP的套接字数据u，与recv()类似，但返回值是tuple(data,address).其中data是包含接收数据的字符串，address是发送数据的地址</li>\n<li>s.sendto(string[,flag],address): 发送UDP数据，将数据发送到套接字，address形式为tuple(ipaddr,port),指定远程地址发送，返回值是发送的字节数、</li>\n<li>s.close(): 关闭套接字</li>\n<li>s.getpeername():返回套接字的远程地址，返回值通常是一个tuple(ipaddr,port)</li>\n<li>s.getsocketname():返回套接字自己的地址,返回值通常是一个tuple(ipaddr,port)</li>\n<li>s.setsocketopt(level, optname[,buflen]): 设置给定套接字选项的值</li>\n<li>s.getsocketopt(level, optname[,buflen]): 返回套接字选项的值</li>\n<li>s.settimeout(timeout):设置套接字的超时时间，timeout是一个浮点数，单位是s，值为None则表示永远不会超时。一般超时期应在刚创建套接字时设置，因为他们可能用于连接的操作，如s.connect()</li>\n<li>s.gettimeout():返回当前的超时值，单位是s，如何没有设置超时时间则返回None</li>\n<li>s.fileno():返回套接字的文件描述</li>\n<li>s.setblocking(flag):如果flag为0，则将套接字设为非阻塞模式(默认值)，非阻塞模式下，如果调用recv()没发现任何数据，或者send()调用无法立即发送数据，那么将引起socket.error异常</li>\n<li>s.makefile(): 创建一个与该套接字相关的文件</li>\n</ul>\n<h2 id=\"Socket编程思想\"><a href=\"#Socket编程思想\" class=\"headerlink\" title=\"Socket编程思想\"></a>Socket编程思想</h2><h3 id=\"TCP服务器\"><a href=\"#TCP服务器\" class=\"headerlink\" title=\"TCP服务器\"></a>TCP服务器</h3><p>1.创建套接字，绑定套接字到本地IP与端口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = socket.socket(scoket.AF_INET,socket.SOCK_STREAM)</span><br><span class=\"line\">s.bind()</span><br></pre></td></tr></table></figure></p>\n<p>2.开始监听链接<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.listen()</span><br></pre></td></tr></table></figure></p>\n<p>3.进入循环不断接受客户端连接请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while True:</span><br><span class=\"line\">    s.accept()</span><br></pre></td></tr></table></figure></p>\n<p>4.接受客户端传来的数据，并且给对方发送数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.recv()</span><br><span class=\"line\">s.sendall()</span><br></pre></td></tr></table></figure></p>\n<p>5.传输完毕后，关闭套接字<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.close()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"TCP客户端\"><a href=\"#TCP客户端\" class=\"headerlink\" title=\"TCP客户端\"></a>TCP客户端</h3><p>1.创建套接字并连接至远端地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class=\"line\">s.connect()</span><br></pre></td></tr></table></figure></p>\n<p>2.链接后发送数据和接收数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.sendall();</span><br><span class=\"line\">s.recv()</span><br></pre></td></tr></table></figure></p>\n<p>3.传输完毕后，关闭套接字</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"socket编程\"><a href=\"#socket编程\" class=\"headerlink\" title=\"socket编程\"></a><center>socket编程</center></h3><p>python提供了两个基本的socket模块:</p>\n<ul>\n<li>Socket 它提供了标准的BSD Socket API.</li>\n<li><p>SocketServer 它提供了服务器重心，可以简化网络服务的开发。</p>","more":"<h3 id=\"Socker类型\"><a href=\"#Socker类型\" class=\"headerlink\" title=\"Socker类型\"></a>Socker类型</h3><ul>\n<li>socket.AF_UNIX: 用于同一台机器上的进程通讯(即本机通讯)</li>\n<li>socket.AF_INET: 用于服务器与服务器之间的网络通讯</li>\n<li>socket.AF_INET6: 基于IPV6方式的服务器与服务器之间的网络通讯</li>\n<li>socket.SOCK_STREAM: 基于TCP的流式socket通信</li>\n<li>socket.SOCK_DGRAM: 基于UDP的数据报式socket通信</li>\n<li>socket.SOCK_RAW: 原始套接字，普通的套接字无法处理ICMP,IGMP等网络报文，而SOCK_RAW可以；其次SOCK_RAW也可以处理特殊的IPV4报头;此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造ip头</li>\n<li>socket.SOCK_SEQPACKET:可靠的连续数据包服务</li>\n</ul>\n<p>创建TCP Socket:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br></pre></td></tr></table></figure>\n<p>创建UDP Socket:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sock = sock.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p> ###Socket 函数</p>\n<ul>\n<li>TCP 在发送数据时，已经建立好TCP链接，所以不需要指定地址，而UDP是面向无链接的，每次发送都需要指定法送给谁。</li>\n<li>服务器与客户端不能直接发送列表，字典，元素等带有数据类型的数据，发送的内容必须是字符串数据</li>\n</ul>\n<h3 id=\"服务器段Socket函数\"><a href=\"#服务器段Socket函数\" class=\"headerlink\" title=\"服务器段Socket函数\"></a>服务器段Socket函数</h3><ul>\n<li>s.bind(address):将套接字绑定到地址，在AF_INET下，以tuple(host,port)方式传入,如s.bind((host, port))</li>\n<li>s.listen(backlog):开始监听TCP传入链接，backlog指定在拒绝连接前，操作系统可以挂起的最大连接数，该值最少为1，大部分程序设定为5就够了。</li>\n<li>s.accept():接受TCP链接并返回(conn, address),其中conn是新的套接字对象们可以用来发送和接收数据，address是链接客户端地址。</li>\n</ul>\n<h3 id=\"客户端Socket函数\"><a href=\"#客户端Socket函数\" class=\"headerlink\" title=\"客户端Socket函数\"></a>客户端Socket函数</h3><ul>\n<li>s.connect(address): 链接到address处的套接字，一般address的格式为tuple(host,port),如果链接出错，返回socket.error错误</li>\n<li>s.connect_ex(address): 功能与s.connect(address)相同,但成功返回0，失败返回errno的值</li>\n</ul>\n<h3 id=\"公共socket函数\"><a href=\"#公共socket函数\" class=\"headerlink\" title=\"公共socket函数\"></a>公共socket函数</h3><ul>\n<li>s.recv(bufsize[,flag]): 接受TCP套接字的数据，数据以字符串的形式返回，buffsize指定要接受的最大数据量，flag提供有关消息的其他信息，通常可以忽略。</li>\n<li>s.send(string[,flag]): 发送TCP数据，将字符串的数据发送到链接的套接字，返回值是要发送的字节的数量，该数量可能小鱼string的字节大小</li>\n<li>s.sendall(string[,falg]): 完整发送TCP数据，将字符串的数据发送到链接的套接字，但在返回之前尝试发送所有数据，成功返回None，失败则抛出异常</li>\n<li>s.recvfrom(bufsize[,flag]): 接受UDP的套接字数据u，与recv()类似，但返回值是tuple(data,address).其中data是包含接收数据的字符串，address是发送数据的地址</li>\n<li>s.sendto(string[,flag],address): 发送UDP数据，将数据发送到套接字，address形式为tuple(ipaddr,port),指定远程地址发送，返回值是发送的字节数、</li>\n<li>s.close(): 关闭套接字</li>\n<li>s.getpeername():返回套接字的远程地址，返回值通常是一个tuple(ipaddr,port)</li>\n<li>s.getsocketname():返回套接字自己的地址,返回值通常是一个tuple(ipaddr,port)</li>\n<li>s.setsocketopt(level, optname[,buflen]): 设置给定套接字选项的值</li>\n<li>s.getsocketopt(level, optname[,buflen]): 返回套接字选项的值</li>\n<li>s.settimeout(timeout):设置套接字的超时时间，timeout是一个浮点数，单位是s，值为None则表示永远不会超时。一般超时期应在刚创建套接字时设置，因为他们可能用于连接的操作，如s.connect()</li>\n<li>s.gettimeout():返回当前的超时值，单位是s，如何没有设置超时时间则返回None</li>\n<li>s.fileno():返回套接字的文件描述</li>\n<li>s.setblocking(flag):如果flag为0，则将套接字设为非阻塞模式(默认值)，非阻塞模式下，如果调用recv()没发现任何数据，或者send()调用无法立即发送数据，那么将引起socket.error异常</li>\n<li>s.makefile(): 创建一个与该套接字相关的文件</li>\n</ul>\n<h2 id=\"Socket编程思想\"><a href=\"#Socket编程思想\" class=\"headerlink\" title=\"Socket编程思想\"></a>Socket编程思想</h2><h3 id=\"TCP服务器\"><a href=\"#TCP服务器\" class=\"headerlink\" title=\"TCP服务器\"></a>TCP服务器</h3><p>1.创建套接字，绑定套接字到本地IP与端口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = socket.socket(scoket.AF_INET,socket.SOCK_STREAM)</span><br><span class=\"line\">s.bind()</span><br></pre></td></tr></table></figure></p>\n<p>2.开始监听链接<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.listen()</span><br></pre></td></tr></table></figure></p>\n<p>3.进入循环不断接受客户端连接请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while True:</span><br><span class=\"line\">    s.accept()</span><br></pre></td></tr></table></figure></p>\n<p>4.接受客户端传来的数据，并且给对方发送数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.recv()</span><br><span class=\"line\">s.sendall()</span><br></pre></td></tr></table></figure></p>\n<p>5.传输完毕后，关闭套接字<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.close()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"TCP客户端\"><a href=\"#TCP客户端\" class=\"headerlink\" title=\"TCP客户端\"></a>TCP客户端</h3><p>1.创建套接字并连接至远端地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class=\"line\">s.connect()</span><br></pre></td></tr></table></figure></p>\n<p>2.链接后发送数据和接收数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.sendall();</span><br><span class=\"line\">s.recv()</span><br></pre></td></tr></table></figure></p>\n<p>3.传输完毕后，关闭套接字</p>"},{"title":"vue","date":"2018-12-20T15:11:06.000Z","_content":"### Vue 父子组建的通信\n\n**父组件对子组件进行传递参数**\n\n&nbsp;&nbsp;&nbsp;&nbsp;例子如下\n```\n<div id=\"app\">\n\t<my-component message=\"来自父组件的消息\"></my-component>\n</div>\n<script>\n\tVue.component('my-component',{\n\t\tporps:['message'],\n\t\ttemplate: `<div>{{ message }}</div>`,\n\t});\n\tvar vm = new Vue({\n\t\tel: \"#app\"\n\t})\n</script>\n```\n<!--more -->\n\n&nbsp;&nbsp;&nbsp;&nbsp;当我们从父组件向子组件传递参数时候，子组件需要在props定义接收的参数，例如本例中的message需要在子组件中定义好。此外，由于HTML不去分大小写，我们的组件名称不可以写成驼峰，要用-分割。使用v-bind指令可以传递数组，数字，布尔值等。如果不用的话，默认为字符串。\n\n**单项数据流**\n\n&nbsp;&nbsp;&nbsp;&nbsp;例子如下\n```\n<div id=\"app\">\n\t<my-component :init-count=\"1\"></my-component>\n<div>\n<script>\n\tVue.component('my-component',{\n\t\tprops:['initCount'],\n\t\ttemplate:`<div>{{ count }}</div>`,\n\t\tdata: function (){\n\t\t\treturn {\n\t\t\t\tcount: this.initCount\n\t\t\t}\n\t\t}\n\t});\n\tvar vm = new Vue({\n\t\tel: \"#app\"\t\n\t})\n</script>\n```\n&nbsp;&nbsp;&nbsp;&nbsp;在这里我们在子组件的template中声明了一个count数据，而我们子组件的data定义这个count使用的是父组件传递的initCount值，当我们从父组件获取到initCount的值的时候，就与之无关了，我们维护count即可，无需在操作父组件传递的initCount。\n\n**子组件对父组件进行传递参数**\n\n&nbsp;&nbsp;&nbsp;&nbsp;例子如下\n```\n<div id=\"app\">\n\t<p>总数:{{ total }}</p>\n\t<my-component @increase=\"handleGetTotal\" @reduce=\"handleGetTotal\"></my-component>\n</div>\n<script>\n\tVue.component('my-component',{\n\t\ttemplate:`\n\t\t<div>\n\t\t\t<button @click=\"handleIncrease\">+1</button>\n\t\t\t<button @click=\"handleReduce\">-1<button>\n\t\t</div>`,\n\t\tdata: function (){\n\t\t\treturn {\n\t\t\t\tcounter: 0\t\n\t\t\t}\n\t\t},\n\t\tmethods: {\n\t\t\thandleIncrease: function (){\n\t\t\t\tthis.counter++;\n\t\t\t\tthis.$emit('increase', this.counter)\n\t\t\t},\n\t\t\thandleReduce: function (){\n\t\t\t\tthis.counter--;\n\t\t\t\tthis.$emit('reduce', this.counter)\n\t\n\t        }\n\t\t}\n\t});\n\tvar vm = new Vue({\n\t\tel: \"#app\",\n\t\tdata: {\n\t\t\ttotal: 0\n\t\t},\n\t\tmethods: {\n\t\t\thandleGetTotal: function (total){\n\t\t\t\tthis.total = total\n\t\t}\n\t}\n});\n</script>\n```\n&nbsp;&nbsp;&nbsp;&nbsp;从上面的例子可以发现，子组件向父组件传递参数通过``$emit``的方式，通过``$emit``将子组件的值传入了increase和reduce的方法之中,然后父组件的方法在调用传递的值。\n","source":"_posts/vue.md","raw":"---\ntitle: vue\ndate: 2018-12-20 23:11:06\ntags: vue\ncategories: vue\n---\n### Vue 父子组建的通信\n\n**父组件对子组件进行传递参数**\n\n&nbsp;&nbsp;&nbsp;&nbsp;例子如下\n```\n<div id=\"app\">\n\t<my-component message=\"来自父组件的消息\"></my-component>\n</div>\n<script>\n\tVue.component('my-component',{\n\t\tporps:['message'],\n\t\ttemplate: `<div>{{ message }}</div>`,\n\t});\n\tvar vm = new Vue({\n\t\tel: \"#app\"\n\t})\n</script>\n```\n<!--more -->\n\n&nbsp;&nbsp;&nbsp;&nbsp;当我们从父组件向子组件传递参数时候，子组件需要在props定义接收的参数，例如本例中的message需要在子组件中定义好。此外，由于HTML不去分大小写，我们的组件名称不可以写成驼峰，要用-分割。使用v-bind指令可以传递数组，数字，布尔值等。如果不用的话，默认为字符串。\n\n**单项数据流**\n\n&nbsp;&nbsp;&nbsp;&nbsp;例子如下\n```\n<div id=\"app\">\n\t<my-component :init-count=\"1\"></my-component>\n<div>\n<script>\n\tVue.component('my-component',{\n\t\tprops:['initCount'],\n\t\ttemplate:`<div>{{ count }}</div>`,\n\t\tdata: function (){\n\t\t\treturn {\n\t\t\t\tcount: this.initCount\n\t\t\t}\n\t\t}\n\t});\n\tvar vm = new Vue({\n\t\tel: \"#app\"\t\n\t})\n</script>\n```\n&nbsp;&nbsp;&nbsp;&nbsp;在这里我们在子组件的template中声明了一个count数据，而我们子组件的data定义这个count使用的是父组件传递的initCount值，当我们从父组件获取到initCount的值的时候，就与之无关了，我们维护count即可，无需在操作父组件传递的initCount。\n\n**子组件对父组件进行传递参数**\n\n&nbsp;&nbsp;&nbsp;&nbsp;例子如下\n```\n<div id=\"app\">\n\t<p>总数:{{ total }}</p>\n\t<my-component @increase=\"handleGetTotal\" @reduce=\"handleGetTotal\"></my-component>\n</div>\n<script>\n\tVue.component('my-component',{\n\t\ttemplate:`\n\t\t<div>\n\t\t\t<button @click=\"handleIncrease\">+1</button>\n\t\t\t<button @click=\"handleReduce\">-1<button>\n\t\t</div>`,\n\t\tdata: function (){\n\t\t\treturn {\n\t\t\t\tcounter: 0\t\n\t\t\t}\n\t\t},\n\t\tmethods: {\n\t\t\thandleIncrease: function (){\n\t\t\t\tthis.counter++;\n\t\t\t\tthis.$emit('increase', this.counter)\n\t\t\t},\n\t\t\thandleReduce: function (){\n\t\t\t\tthis.counter--;\n\t\t\t\tthis.$emit('reduce', this.counter)\n\t\n\t        }\n\t\t}\n\t});\n\tvar vm = new Vue({\n\t\tel: \"#app\",\n\t\tdata: {\n\t\t\ttotal: 0\n\t\t},\n\t\tmethods: {\n\t\t\thandleGetTotal: function (total){\n\t\t\t\tthis.total = total\n\t\t}\n\t}\n});\n</script>\n```\n&nbsp;&nbsp;&nbsp;&nbsp;从上面的例子可以发现，子组件向父组件传递参数通过``$emit``的方式，通过``$emit``将子组件的值传入了increase和reduce的方法之中,然后父组件的方法在调用传递的值。\n","slug":"vue","published":1,"updated":"2022-05-20T02:24:20.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7t0024lae1lr26eh0v","content":"<h3 id=\"Vue-父子组建的通信\"><a href=\"#Vue-父子组建的通信\" class=\"headerlink\" title=\"Vue 父子组建的通信\"></a>Vue 父子组建的通信</h3><p><strong>父组件对子组件进行传递参数</strong></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;例子如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">\t&lt;my-component message=&quot;来自父组件的消息&quot;&gt;&lt;/my-component&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\tVue.component(&apos;my-component&apos;,&#123;</span><br><span class=\"line\">\t\tporps:[&apos;message&apos;],</span><br><span class=\"line\">\t\ttemplate: `&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;`,</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tvar vm = new Vue(&#123;</span><br><span class=\"line\">\t\tel: &quot;#app&quot;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;当我们从父组件向子组件传递参数时候，子组件需要在props定义接收的参数，例如本例中的message需要在子组件中定义好。此外，由于HTML不去分大小写，我们的组件名称不可以写成驼峰，要用-分割。使用v-bind指令可以传递数组，数字，布尔值等。如果不用的话，默认为字符串。</p>\n<p><strong>单项数据流</strong></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;例子如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">\t&lt;my-component :init-count=&quot;1&quot;&gt;&lt;/my-component&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\tVue.component(&apos;my-component&apos;,&#123;</span><br><span class=\"line\">\t\tprops:[&apos;initCount&apos;],</span><br><span class=\"line\">\t\ttemplate:`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class=\"line\">\t\tdata: function ()&#123;</span><br><span class=\"line\">\t\t\treturn &#123;</span><br><span class=\"line\">\t\t\t\tcount: this.initCount</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tvar vm = new Vue(&#123;</span><br><span class=\"line\">\t\tel: &quot;#app&quot;\t</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;在这里我们在子组件的template中声明了一个count数据，而我们子组件的data定义这个count使用的是父组件传递的initCount值，当我们从父组件获取到initCount的值的时候，就与之无关了，我们维护count即可，无需在操作父组件传递的initCount。</p>\n<p><strong>子组件对父组件进行传递参数</strong></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;例子如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">\t&lt;p&gt;总数:&#123;&#123; total &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">\t&lt;my-component @increase=&quot;handleGetTotal&quot; @reduce=&quot;handleGetTotal&quot;&gt;&lt;/my-component&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\tVue.component(&apos;my-component&apos;,&#123;</span><br><span class=\"line\">\t\ttemplate:`</span><br><span class=\"line\">\t\t&lt;div&gt;</span><br><span class=\"line\">\t\t\t&lt;button @click=&quot;handleIncrease&quot;&gt;+1&lt;/button&gt;</span><br><span class=\"line\">\t\t\t&lt;button @click=&quot;handleReduce&quot;&gt;-1&lt;button&gt;</span><br><span class=\"line\">\t\t&lt;/div&gt;`,</span><br><span class=\"line\">\t\tdata: function ()&#123;</span><br><span class=\"line\">\t\t\treturn &#123;</span><br><span class=\"line\">\t\t\t\tcounter: 0\t</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tmethods: &#123;</span><br><span class=\"line\">\t\t\thandleIncrease: function ()&#123;</span><br><span class=\"line\">\t\t\t\tthis.counter++;</span><br><span class=\"line\">\t\t\t\tthis.$emit(&apos;increase&apos;, this.counter)</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\thandleReduce: function ()&#123;</span><br><span class=\"line\">\t\t\t\tthis.counter--;</span><br><span class=\"line\">\t\t\t\tthis.$emit(&apos;reduce&apos;, this.counter)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tvar vm = new Vue(&#123;</span><br><span class=\"line\">\t\tel: &quot;#app&quot;,</span><br><span class=\"line\">\t\tdata: &#123;</span><br><span class=\"line\">\t\t\ttotal: 0</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tmethods: &#123;</span><br><span class=\"line\">\t\t\thandleGetTotal: function (total)&#123;</span><br><span class=\"line\">\t\t\t\tthis.total = total</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;从上面的例子可以发现，子组件向父组件传递参数通过<code>$emit</code>的方式，通过<code>$emit</code>将子组件的值传入了increase和reduce的方法之中,然后父组件的方法在调用传递的值。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Vue-父子组建的通信\"><a href=\"#Vue-父子组建的通信\" class=\"headerlink\" title=\"Vue 父子组建的通信\"></a>Vue 父子组建的通信</h3><p><strong>父组件对子组件进行传递参数</strong></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;例子如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">\t&lt;my-component message=&quot;来自父组件的消息&quot;&gt;&lt;/my-component&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\tVue.component(&apos;my-component&apos;,&#123;</span><br><span class=\"line\">\t\tporps:[&apos;message&apos;],</span><br><span class=\"line\">\t\ttemplate: `&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;`,</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tvar vm = new Vue(&#123;</span><br><span class=\"line\">\t\tel: &quot;#app&quot;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>","more":"<p>&nbsp;&nbsp;&nbsp;&nbsp;当我们从父组件向子组件传递参数时候，子组件需要在props定义接收的参数，例如本例中的message需要在子组件中定义好。此外，由于HTML不去分大小写，我们的组件名称不可以写成驼峰，要用-分割。使用v-bind指令可以传递数组，数字，布尔值等。如果不用的话，默认为字符串。</p>\n<p><strong>单项数据流</strong></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;例子如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">\t&lt;my-component :init-count=&quot;1&quot;&gt;&lt;/my-component&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\tVue.component(&apos;my-component&apos;,&#123;</span><br><span class=\"line\">\t\tprops:[&apos;initCount&apos;],</span><br><span class=\"line\">\t\ttemplate:`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class=\"line\">\t\tdata: function ()&#123;</span><br><span class=\"line\">\t\t\treturn &#123;</span><br><span class=\"line\">\t\t\t\tcount: this.initCount</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tvar vm = new Vue(&#123;</span><br><span class=\"line\">\t\tel: &quot;#app&quot;\t</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;在这里我们在子组件的template中声明了一个count数据，而我们子组件的data定义这个count使用的是父组件传递的initCount值，当我们从父组件获取到initCount的值的时候，就与之无关了，我们维护count即可，无需在操作父组件传递的initCount。</p>\n<p><strong>子组件对父组件进行传递参数</strong></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;例子如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">\t&lt;p&gt;总数:&#123;&#123; total &#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">\t&lt;my-component @increase=&quot;handleGetTotal&quot; @reduce=&quot;handleGetTotal&quot;&gt;&lt;/my-component&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\tVue.component(&apos;my-component&apos;,&#123;</span><br><span class=\"line\">\t\ttemplate:`</span><br><span class=\"line\">\t\t&lt;div&gt;</span><br><span class=\"line\">\t\t\t&lt;button @click=&quot;handleIncrease&quot;&gt;+1&lt;/button&gt;</span><br><span class=\"line\">\t\t\t&lt;button @click=&quot;handleReduce&quot;&gt;-1&lt;button&gt;</span><br><span class=\"line\">\t\t&lt;/div&gt;`,</span><br><span class=\"line\">\t\tdata: function ()&#123;</span><br><span class=\"line\">\t\t\treturn &#123;</span><br><span class=\"line\">\t\t\t\tcounter: 0\t</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tmethods: &#123;</span><br><span class=\"line\">\t\t\thandleIncrease: function ()&#123;</span><br><span class=\"line\">\t\t\t\tthis.counter++;</span><br><span class=\"line\">\t\t\t\tthis.$emit(&apos;increase&apos;, this.counter)</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\thandleReduce: function ()&#123;</span><br><span class=\"line\">\t\t\t\tthis.counter--;</span><br><span class=\"line\">\t\t\t\tthis.$emit(&apos;reduce&apos;, this.counter)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tvar vm = new Vue(&#123;</span><br><span class=\"line\">\t\tel: &quot;#app&quot;,</span><br><span class=\"line\">\t\tdata: &#123;</span><br><span class=\"line\">\t\t\ttotal: 0</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tmethods: &#123;</span><br><span class=\"line\">\t\t\thandleGetTotal: function (total)&#123;</span><br><span class=\"line\">\t\t\t\tthis.total = total</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;从上面的例子可以发现，子组件向父组件传递参数通过<code>$emit</code>的方式，通过<code>$emit</code>将子组件的值传入了increase和reduce的方法之中,然后父组件的方法在调用传递的值。</p>"},{"layout":"posts","title":"前端跨域","date":"2019-05-08T03:50:30.000Z","_content":"\n### 什么是跨域，简单来说就三个\n - 端口: 例如一个80端口，一个8080端口，用ajax从80端口向8080端口获取数据，那么就会跨域。\n - 协议: 就是http协议还是https协议，file协议，ftp等等。\n - 域名: baidu.com, a.baidu.com\n\n### 解决跨域的几个实现的方法:\n\n1.jsonp\n\n由于用ajax的方法从其他域名获取资源涉及到跨域，那么回想一下，当我们在网页中加载`script`标签的时候，也并不是在本域名下，而是使用`<script src=\"xxxx\"></script>`这种方式，可以理解为这种方式会把相应的js代码插入到相应的位置，那么我们可以使用这种方式来解决跨域问题。从代码来看\n<!-- more -->\n客户端(html端):假如我们当前的页面是`a.jrg.com`\n```\n  \n  $('.change').addEventListener('click', function(){\n    var script = document.createElement('script');\n    script.src = 'http://b.jrg.com:8080/getNews?callback=appendHtml'; //客户端请求的网址，在请求的资源网址上加上了callback=appendHtml，\n    document.head.appendChild(script); //将其放在head标签内\n    document.head.removeChild(script);  //加载完进行移除\n  })\n\n  function appendHtml(news){\n    var html = '';\n    for( var i=0; i<news.length; i++){\n      html += '<li>' + news[i] + '</li>';\n    }\n    $('.news').innerHTML = html;\n  }\n\n\n  function $(id){\n    return document.querySelector(id);\n  }\n```\n加载完`script`标签，获取到的资源如下:\n```\nappendHtml(\n[\n\"正直播柴飚/洪炜出战 男双力争会师决赛\",\n\"博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多\",\n\"第11日前瞻：中国冲击4金 博尔特再战200米羽球\"\n]\n)\n```\n由于客户端有`appendHtml`这个函数,那么就会执行这个函数。也就完成了数据的获取和解析方式。\n\n\n服务端:\n```\napp.get('/getNews', function(req, res){\n\n\tvar news = [\n\t\t\"第11日前瞻：中国冲击4金 博尔特再战200米羽球\",\n\t\t\"正直播柴飚/洪炜出战 男双力争会师决赛\",\n\t\t\"女排将死磕巴西！郎平安排男陪练模仿对方核心\",\n\t\t\"没有中国选手和巨星的110米栏 我们还看吗？\",\n\t\t\"中英上演奥运金牌大战\",\n\t\t\"博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多\",\n\t\t\"最“出柜”奥运？同性之爱闪耀里约\",\n\t\t\"下跪拜谢与洪荒之力一样 都是真情流露\"\n\t]\n\tvar data = [];\n\tfor(var i=0; i<3; i++){\n\t\tvar index = parseInt(Math.random()*news.length);\n\t\tdata.push(news[index]);\n\t\tnews.splice(index, 1);\n\t}\n\tvar cb = req.query.callback; //这里获取回调函数的名称为appendHtml，这个名称是可以和前端进行约定的\n\tif(cb){\n\t\tres.send(cb + '('+ JSON.stringify(data) + ')'); //这里要把原始的数据进行封装，即appendHtml(xxx)，前端相当于执行个appendHtml函数。xxx即为数据。\n\t}else{\n\t\tres.send(data);\n\t}\n})\n```\n\n2. cors:\n\n当我们跨域，会给我们提示`No 'Access-Control-Allow-Origin' header is present on the requested resource.`,说明头部没有允许这个源获取数据，所以我们需要在服务端的head中加入。\n\n```\napp.get('/getNews', function(req, res){\n\n\tvar news = [\n\t\t\"第11日前瞻：中国冲击4金 博尔特再战200米羽球\",\n\t\t\"正直播柴飚/洪炜出战 男双力争会师决赛\",\n\t\t\"女排将死磕巴西！郎平安排男陪练模仿对方核心\",\n\t\t\"没有中国选手和巨星的110米栏 我们还看吗？\",\n\t\t\"中英上演奥运金牌大战\",\n\t\t\"博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多\",\n\t\t\"最“出柜”奥运？同性之爱闪耀里约\",\n\t\t\"下跪拜谢与洪荒之力一样 都是真情流露\"\n\t]\n\tvar data = [];\n\tfor(var i=0; i<3; i++){\n\t\tvar index = parseInt(Math.random()*news.length);\n\t\tdata.push(news[index]);\n\t\tnews.splice(index, 1);\n\t}\n\tres.header(\"Access-Control-Allow-Origin\", \"http://a.jrg.com:8080\"); //这里是在返回头加上了允许获取的数据的源，即允许获取数据的往网址，为'*'代表所有 \n\t//res.header(\"Access-Control-Allow-Origin\", \"*\"); \n\tres.send(data);\n})\n```\n客户端：\n```\n  $('.change').addEventListener('click', function(){\n\n    var xhr = new XMLHttpRequest();\n    xhr.open('get', 'http://b.jrg.com:8080/getNews', true);\n    xhr.send();\n    xhr.onreadystatechange = function(){\n      if(xhr.readyState === 4 && xhr.status === 200){\n        appendHtml( JSON.parse(xhr.responseText) )\n      }\n    }\n    window.xhr = xhr\n\n  })\n\n  function appendHtml(news){\n    var html = '';\n    for( var i=0; i<news.length; i++){\n      html += '<li>' + news[i] + '</li>';\n    }\n    console.log(html);\n    $('.news').innerHTML = html;\n\n  }\n\n\n  function $(id){\n    return document.querySelector(id);\n  }\n```\ncors只需要我们在服务端加上允许请求的网址即可。\n\n3. 降域\n\n主要涉及两个页面之间，无需服务器端参与    \n例如`a.jrg.com`页面下面有一个iframe，为`b.jrg.com`，那么操作这个iframe的内容涉及到跨域，在`script`的标签中加入`document.domain='jrg.com'`即可。    \na.html如下\n\n```\n<div class=\"ct\">\n  <h1>使用降域实现跨域</h1>\n  <div class=\"main\">\n    <input type=\"text\" placeholder=\"http://a.jrg.com:8080/a.html\">\n  </div>\n\n  <iframe src=\"http://b.jrg.com:8080/b.html\" frameborder=\"0\" ></iframe>\n\n</div>\n\n\n<script>\n//URL: http://a.jrg.com:8080/a.html\n\ndocument.querySelector('.main input').addEventListener('input', function(){\n  console.log(this.value);\n  window.frames[0].document.querySelector('input').value = this.value;\n})\n\ndocument.domain = \"jrg.com\"\n</script>\n```\nb.html如下,也要写上`document.domian='jrg.com'`\n```\n<input id=\"input\" type=\"text\"  placeholder=\"http://b.jrg.com:8080/b.html\">\n<script>\n\n// URL: http://b.jrg.com:8080/b.html\n \ndocument.querySelector('#input').addEventListener('input', function(){\n\twindow.parent.document.querySelector('input').value = this.value;\n})\n\ndocument.domain = 'jrg.com';\n\n</script>\n```\n4. postMessage\n\n这里主要涉及`window`对象，也无需服务器端参与\n\na.html的页面内容如下\n```\n<div class=\"ct\">\n\t<h1>使用postMessage实现跨域</h1>\n\t<div class=\"main\">\n\t\t<input type=\"text\" placeholder=\"http://a.jrg.com:8080/a.html\">\n\t</div>\n\n\t<iframe src=\"http://localhost:8080/b.html\" frameborder=\"0\" ></iframe>\n\n</div>\n\n\n<script>\n//URL: http://a.jrg.com:8080/a.html\n\n$('.main input').addEventListener('input', function(){\n\tconsole.log(this.value);\n\twindow.frames[0].postMessage(this.value,'*');\n})\n\nwindow.addEventListener('message',function(e) {\n\t\t$('.main input').value = e.data\n    console.log(e.data);\n});\n\nfunction $(id){\n\treturn document.querySelector(id);\n}\n</script>\n```\n\nb.html的内容如下\n```\n<input id=\"input\" type=\"text\"  placeholder=\"http://b.jrg.com:8080/b.html\">\n<script>\n\n// URL: http://b.jrg.com:8080/b.html\n \n$('#input').addEventListener('input', function(){\n\twindow.parent.postMessage(this.value, '*');\n})\n\nwindow.addEventListener('message',function(e) { //添加监听a.html传过来的数据\n\t\t$('#input').value = e.data\n    console.log(e.data);\n});\n\nfunction $(id){\n\treturn document.querySelector(id);\n}\t\n</script>\n```\n\n总结下，主要jsonp和cors需要服务器端配合，用的也多一些。其余两种用的少，基本用语iframe。","source":"_posts/前端跨域.md","raw":"---\nlayout: posts\ntitle: 前端跨域\ndate: 2019-05-08 11:50:30\ntags: 前端\ncategories: 前端\n---\n\n### 什么是跨域，简单来说就三个\n - 端口: 例如一个80端口，一个8080端口，用ajax从80端口向8080端口获取数据，那么就会跨域。\n - 协议: 就是http协议还是https协议，file协议，ftp等等。\n - 域名: baidu.com, a.baidu.com\n\n### 解决跨域的几个实现的方法:\n\n1.jsonp\n\n由于用ajax的方法从其他域名获取资源涉及到跨域，那么回想一下，当我们在网页中加载`script`标签的时候，也并不是在本域名下，而是使用`<script src=\"xxxx\"></script>`这种方式，可以理解为这种方式会把相应的js代码插入到相应的位置，那么我们可以使用这种方式来解决跨域问题。从代码来看\n<!-- more -->\n客户端(html端):假如我们当前的页面是`a.jrg.com`\n```\n  \n  $('.change').addEventListener('click', function(){\n    var script = document.createElement('script');\n    script.src = 'http://b.jrg.com:8080/getNews?callback=appendHtml'; //客户端请求的网址，在请求的资源网址上加上了callback=appendHtml，\n    document.head.appendChild(script); //将其放在head标签内\n    document.head.removeChild(script);  //加载完进行移除\n  })\n\n  function appendHtml(news){\n    var html = '';\n    for( var i=0; i<news.length; i++){\n      html += '<li>' + news[i] + '</li>';\n    }\n    $('.news').innerHTML = html;\n  }\n\n\n  function $(id){\n    return document.querySelector(id);\n  }\n```\n加载完`script`标签，获取到的资源如下:\n```\nappendHtml(\n[\n\"正直播柴飚/洪炜出战 男双力争会师决赛\",\n\"博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多\",\n\"第11日前瞻：中国冲击4金 博尔特再战200米羽球\"\n]\n)\n```\n由于客户端有`appendHtml`这个函数,那么就会执行这个函数。也就完成了数据的获取和解析方式。\n\n\n服务端:\n```\napp.get('/getNews', function(req, res){\n\n\tvar news = [\n\t\t\"第11日前瞻：中国冲击4金 博尔特再战200米羽球\",\n\t\t\"正直播柴飚/洪炜出战 男双力争会师决赛\",\n\t\t\"女排将死磕巴西！郎平安排男陪练模仿对方核心\",\n\t\t\"没有中国选手和巨星的110米栏 我们还看吗？\",\n\t\t\"中英上演奥运金牌大战\",\n\t\t\"博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多\",\n\t\t\"最“出柜”奥运？同性之爱闪耀里约\",\n\t\t\"下跪拜谢与洪荒之力一样 都是真情流露\"\n\t]\n\tvar data = [];\n\tfor(var i=0; i<3; i++){\n\t\tvar index = parseInt(Math.random()*news.length);\n\t\tdata.push(news[index]);\n\t\tnews.splice(index, 1);\n\t}\n\tvar cb = req.query.callback; //这里获取回调函数的名称为appendHtml，这个名称是可以和前端进行约定的\n\tif(cb){\n\t\tres.send(cb + '('+ JSON.stringify(data) + ')'); //这里要把原始的数据进行封装，即appendHtml(xxx)，前端相当于执行个appendHtml函数。xxx即为数据。\n\t}else{\n\t\tres.send(data);\n\t}\n})\n```\n\n2. cors:\n\n当我们跨域，会给我们提示`No 'Access-Control-Allow-Origin' header is present on the requested resource.`,说明头部没有允许这个源获取数据，所以我们需要在服务端的head中加入。\n\n```\napp.get('/getNews', function(req, res){\n\n\tvar news = [\n\t\t\"第11日前瞻：中国冲击4金 博尔特再战200米羽球\",\n\t\t\"正直播柴飚/洪炜出战 男双力争会师决赛\",\n\t\t\"女排将死磕巴西！郎平安排男陪练模仿对方核心\",\n\t\t\"没有中国选手和巨星的110米栏 我们还看吗？\",\n\t\t\"中英上演奥运金牌大战\",\n\t\t\"博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多\",\n\t\t\"最“出柜”奥运？同性之爱闪耀里约\",\n\t\t\"下跪拜谢与洪荒之力一样 都是真情流露\"\n\t]\n\tvar data = [];\n\tfor(var i=0; i<3; i++){\n\t\tvar index = parseInt(Math.random()*news.length);\n\t\tdata.push(news[index]);\n\t\tnews.splice(index, 1);\n\t}\n\tres.header(\"Access-Control-Allow-Origin\", \"http://a.jrg.com:8080\"); //这里是在返回头加上了允许获取的数据的源，即允许获取数据的往网址，为'*'代表所有 \n\t//res.header(\"Access-Control-Allow-Origin\", \"*\"); \n\tres.send(data);\n})\n```\n客户端：\n```\n  $('.change').addEventListener('click', function(){\n\n    var xhr = new XMLHttpRequest();\n    xhr.open('get', 'http://b.jrg.com:8080/getNews', true);\n    xhr.send();\n    xhr.onreadystatechange = function(){\n      if(xhr.readyState === 4 && xhr.status === 200){\n        appendHtml( JSON.parse(xhr.responseText) )\n      }\n    }\n    window.xhr = xhr\n\n  })\n\n  function appendHtml(news){\n    var html = '';\n    for( var i=0; i<news.length; i++){\n      html += '<li>' + news[i] + '</li>';\n    }\n    console.log(html);\n    $('.news').innerHTML = html;\n\n  }\n\n\n  function $(id){\n    return document.querySelector(id);\n  }\n```\ncors只需要我们在服务端加上允许请求的网址即可。\n\n3. 降域\n\n主要涉及两个页面之间，无需服务器端参与    \n例如`a.jrg.com`页面下面有一个iframe，为`b.jrg.com`，那么操作这个iframe的内容涉及到跨域，在`script`的标签中加入`document.domain='jrg.com'`即可。    \na.html如下\n\n```\n<div class=\"ct\">\n  <h1>使用降域实现跨域</h1>\n  <div class=\"main\">\n    <input type=\"text\" placeholder=\"http://a.jrg.com:8080/a.html\">\n  </div>\n\n  <iframe src=\"http://b.jrg.com:8080/b.html\" frameborder=\"0\" ></iframe>\n\n</div>\n\n\n<script>\n//URL: http://a.jrg.com:8080/a.html\n\ndocument.querySelector('.main input').addEventListener('input', function(){\n  console.log(this.value);\n  window.frames[0].document.querySelector('input').value = this.value;\n})\n\ndocument.domain = \"jrg.com\"\n</script>\n```\nb.html如下,也要写上`document.domian='jrg.com'`\n```\n<input id=\"input\" type=\"text\"  placeholder=\"http://b.jrg.com:8080/b.html\">\n<script>\n\n// URL: http://b.jrg.com:8080/b.html\n \ndocument.querySelector('#input').addEventListener('input', function(){\n\twindow.parent.document.querySelector('input').value = this.value;\n})\n\ndocument.domain = 'jrg.com';\n\n</script>\n```\n4. postMessage\n\n这里主要涉及`window`对象，也无需服务器端参与\n\na.html的页面内容如下\n```\n<div class=\"ct\">\n\t<h1>使用postMessage实现跨域</h1>\n\t<div class=\"main\">\n\t\t<input type=\"text\" placeholder=\"http://a.jrg.com:8080/a.html\">\n\t</div>\n\n\t<iframe src=\"http://localhost:8080/b.html\" frameborder=\"0\" ></iframe>\n\n</div>\n\n\n<script>\n//URL: http://a.jrg.com:8080/a.html\n\n$('.main input').addEventListener('input', function(){\n\tconsole.log(this.value);\n\twindow.frames[0].postMessage(this.value,'*');\n})\n\nwindow.addEventListener('message',function(e) {\n\t\t$('.main input').value = e.data\n    console.log(e.data);\n});\n\nfunction $(id){\n\treturn document.querySelector(id);\n}\n</script>\n```\n\nb.html的内容如下\n```\n<input id=\"input\" type=\"text\"  placeholder=\"http://b.jrg.com:8080/b.html\">\n<script>\n\n// URL: http://b.jrg.com:8080/b.html\n \n$('#input').addEventListener('input', function(){\n\twindow.parent.postMessage(this.value, '*');\n})\n\nwindow.addEventListener('message',function(e) { //添加监听a.html传过来的数据\n\t\t$('#input').value = e.data\n    console.log(e.data);\n});\n\nfunction $(id){\n\treturn document.querySelector(id);\n}\t\n</script>\n```\n\n总结下，主要jsonp和cors需要服务器端配合，用的也多一些。其余两种用的少，基本用语iframe。","slug":"前端跨域","published":1,"updated":"2022-05-20T02:24:20.543Z","comments":1,"photos":[],"link":"","_id":"cl3e0vh7t0027lae1hnmkajbm","content":"<h3 id=\"什么是跨域，简单来说就三个\"><a href=\"#什么是跨域，简单来说就三个\" class=\"headerlink\" title=\"什么是跨域，简单来说就三个\"></a>什么是跨域，简单来说就三个</h3><ul>\n<li>端口: 例如一个80端口，一个8080端口，用ajax从80端口向8080端口获取数据，那么就会跨域。</li>\n<li>协议: 就是http协议还是https协议，file协议，ftp等等。</li>\n<li>域名: baidu.com, a.baidu.com</li>\n</ul>\n<h3 id=\"解决跨域的几个实现的方法\"><a href=\"#解决跨域的几个实现的方法\" class=\"headerlink\" title=\"解决跨域的几个实现的方法:\"></a>解决跨域的几个实现的方法:</h3><p>1.jsonp</p>\n<p>由于用ajax的方法从其他域名获取资源涉及到跨域，那么回想一下，当我们在网页中加载<code>script</code>标签的时候，也并不是在本域名下，而是使用<code>&lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</code>这种方式，可以理解为这种方式会把相应的js代码插入到相应的位置，那么我们可以使用这种方式来解决跨域问题。从代码来看<br><a id=\"more\"></a><br>客户端(html端):假如我们当前的页面是<code>a.jrg.com</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$(&apos;.change&apos;).addEventListener(&apos;click&apos;, function()&#123;</span><br><span class=\"line\">  var script = document.createElement(&apos;script&apos;);</span><br><span class=\"line\">  script.src = &apos;http://b.jrg.com:8080/getNews?callback=appendHtml&apos;; //客户端请求的网址，在请求的资源网址上加上了callback=appendHtml，</span><br><span class=\"line\">  document.head.appendChild(script); //将其放在head标签内</span><br><span class=\"line\">  document.head.removeChild(script);  //加载完进行移除</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">function appendHtml(news)&#123;</span><br><span class=\"line\">  var html = &apos;&apos;;</span><br><span class=\"line\">  for( var i=0; i&lt;news.length; i++)&#123;</span><br><span class=\"line\">    html += &apos;&lt;li&gt;&apos; + news[i] + &apos;&lt;/li&gt;&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  $(&apos;.news&apos;).innerHTML = html;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function $(id)&#123;</span><br><span class=\"line\">  return document.querySelector(id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>加载完<code>script</code>标签，获取到的资源如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendHtml(</span><br><span class=\"line\">[</span><br><span class=\"line\">&quot;正直播柴飚/洪炜出战 男双力争会师决赛&quot;,</span><br><span class=\"line\">&quot;博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多&quot;,</span><br><span class=\"line\">&quot;第11日前瞻：中国冲击4金 博尔特再战200米羽球&quot;</span><br><span class=\"line\">]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>由于客户端有<code>appendHtml</code>这个函数,那么就会执行这个函数。也就完成了数据的获取和解析方式。</p>\n<p>服务端:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(&apos;/getNews&apos;, function(req, res)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar news = [</span><br><span class=\"line\">\t\t&quot;第11日前瞻：中国冲击4金 博尔特再战200米羽球&quot;,</span><br><span class=\"line\">\t\t&quot;正直播柴飚/洪炜出战 男双力争会师决赛&quot;,</span><br><span class=\"line\">\t\t&quot;女排将死磕巴西！郎平安排男陪练模仿对方核心&quot;,</span><br><span class=\"line\">\t\t&quot;没有中国选手和巨星的110米栏 我们还看吗？&quot;,</span><br><span class=\"line\">\t\t&quot;中英上演奥运金牌大战&quot;,</span><br><span class=\"line\">\t\t&quot;博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多&quot;,</span><br><span class=\"line\">\t\t&quot;最“出柜”奥运？同性之爱闪耀里约&quot;,</span><br><span class=\"line\">\t\t&quot;下跪拜谢与洪荒之力一样 都是真情流露&quot;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">\tvar data = [];</span><br><span class=\"line\">\tfor(var i=0; i&lt;3; i++)&#123;</span><br><span class=\"line\">\t\tvar index = parseInt(Math.random()*news.length);</span><br><span class=\"line\">\t\tdata.push(news[index]);</span><br><span class=\"line\">\t\tnews.splice(index, 1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvar cb = req.query.callback; //这里获取回调函数的名称为appendHtml，这个名称是可以和前端进行约定的</span><br><span class=\"line\">\tif(cb)&#123;</span><br><span class=\"line\">\t\tres.send(cb + &apos;(&apos;+ JSON.stringify(data) + &apos;)&apos;); //这里要把原始的数据进行封装，即appendHtml(xxx)，前端相当于执行个appendHtml函数。xxx即为数据。</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tres.send(data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>cors:</li>\n</ol>\n<p>当我们跨域，会给我们提示<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code>,说明头部没有允许这个源获取数据，所以我们需要在服务端的head中加入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(&apos;/getNews&apos;, function(req, res)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar news = [</span><br><span class=\"line\">\t\t&quot;第11日前瞻：中国冲击4金 博尔特再战200米羽球&quot;,</span><br><span class=\"line\">\t\t&quot;正直播柴飚/洪炜出战 男双力争会师决赛&quot;,</span><br><span class=\"line\">\t\t&quot;女排将死磕巴西！郎平安排男陪练模仿对方核心&quot;,</span><br><span class=\"line\">\t\t&quot;没有中国选手和巨星的110米栏 我们还看吗？&quot;,</span><br><span class=\"line\">\t\t&quot;中英上演奥运金牌大战&quot;,</span><br><span class=\"line\">\t\t&quot;博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多&quot;,</span><br><span class=\"line\">\t\t&quot;最“出柜”奥运？同性之爱闪耀里约&quot;,</span><br><span class=\"line\">\t\t&quot;下跪拜谢与洪荒之力一样 都是真情流露&quot;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">\tvar data = [];</span><br><span class=\"line\">\tfor(var i=0; i&lt;3; i++)&#123;</span><br><span class=\"line\">\t\tvar index = parseInt(Math.random()*news.length);</span><br><span class=\"line\">\t\tdata.push(news[index]);</span><br><span class=\"line\">\t\tnews.splice(index, 1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres.header(&quot;Access-Control-Allow-Origin&quot;, &quot;http://a.jrg.com:8080&quot;); //这里是在返回头加上了允许获取的数据的源，即允许获取数据的往网址，为&apos;*&apos;代表所有 </span><br><span class=\"line\">\t//res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); </span><br><span class=\"line\">\tres.send(data);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>客户端：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;.change&apos;).addEventListener(&apos;click&apos;, function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  var xhr = new XMLHttpRequest();</span><br><span class=\"line\">  xhr.open(&apos;get&apos;, &apos;http://b.jrg.com:8080/getNews&apos;, true);</span><br><span class=\"line\">  xhr.send();</span><br><span class=\"line\">  xhr.onreadystatechange = function()&#123;</span><br><span class=\"line\">    if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123;</span><br><span class=\"line\">      appendHtml( JSON.parse(xhr.responseText) )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  window.xhr = xhr</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">function appendHtml(news)&#123;</span><br><span class=\"line\">  var html = &apos;&apos;;</span><br><span class=\"line\">  for( var i=0; i&lt;news.length; i++)&#123;</span><br><span class=\"line\">    html += &apos;&lt;li&gt;&apos; + news[i] + &apos;&lt;/li&gt;&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(html);</span><br><span class=\"line\">  $(&apos;.news&apos;).innerHTML = html;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function $(id)&#123;</span><br><span class=\"line\">  return document.querySelector(id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>cors只需要我们在服务端加上允许请求的网址即可。</p>\n<ol start=\"3\">\n<li>降域</li>\n</ol>\n<p>主要涉及两个页面之间，无需服务器端参与<br>例如<code>a.jrg.com</code>页面下面有一个iframe，为<code>b.jrg.com</code>，那么操作这个iframe的内容涉及到跨域，在<code>script</code>的标签中加入<code>document.domain=&#39;jrg.com&#39;</code>即可。<br>a.html如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;ct&quot;&gt;</span><br><span class=\"line\">  &lt;h1&gt;使用降域实现跨域&lt;/h1&gt;</span><br><span class=\"line\">  &lt;div class=&quot;main&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; placeholder=&quot;http://a.jrg.com:8080/a.html&quot;&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;iframe src=&quot;http://b.jrg.com:8080/b.html&quot; frameborder=&quot;0&quot; &gt;&lt;/iframe&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">//URL: http://a.jrg.com:8080/a.html</span><br><span class=\"line\"></span><br><span class=\"line\">document.querySelector(&apos;.main input&apos;).addEventListener(&apos;input&apos;, function()&#123;</span><br><span class=\"line\">  console.log(this.value);</span><br><span class=\"line\">  window.frames[0].document.querySelector(&apos;input&apos;).value = this.value;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">document.domain = &quot;jrg.com&quot;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>b.html如下,也要写上<code>document.domian=&#39;jrg.com&#39;</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;input&quot; type=&quot;text&quot;  placeholder=&quot;http://b.jrg.com:8080/b.html&quot;&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// URL: http://b.jrg.com:8080/b.html</span><br><span class=\"line\"> </span><br><span class=\"line\">document.querySelector(&apos;#input&apos;).addEventListener(&apos;input&apos;, function()&#123;</span><br><span class=\"line\">\twindow.parent.document.querySelector(&apos;input&apos;).value = this.value;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">document.domain = &apos;jrg.com&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"4\">\n<li>postMessage</li>\n</ol>\n<p>这里主要涉及<code>window</code>对象，也无需服务器端参与</p>\n<p>a.html的页面内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;ct&quot;&gt;</span><br><span class=\"line\">\t&lt;h1&gt;使用postMessage实现跨域&lt;/h1&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;main&quot;&gt;</span><br><span class=\"line\">\t\t&lt;input type=&quot;text&quot; placeholder=&quot;http://a.jrg.com:8080/a.html&quot;&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;iframe src=&quot;http://localhost:8080/b.html&quot; frameborder=&quot;0&quot; &gt;&lt;/iframe&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">//URL: http://a.jrg.com:8080/a.html</span><br><span class=\"line\"></span><br><span class=\"line\">$(&apos;.main input&apos;).addEventListener(&apos;input&apos;, function()&#123;</span><br><span class=\"line\">\tconsole.log(this.value);</span><br><span class=\"line\">\twindow.frames[0].postMessage(this.value,&apos;*&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">window.addEventListener(&apos;message&apos;,function(e) &#123;</span><br><span class=\"line\">\t\t$(&apos;.main input&apos;).value = e.data</span><br><span class=\"line\">    console.log(e.data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">function $(id)&#123;</span><br><span class=\"line\">\treturn document.querySelector(id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>b.html的内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;input&quot; type=&quot;text&quot;  placeholder=&quot;http://b.jrg.com:8080/b.html&quot;&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// URL: http://b.jrg.com:8080/b.html</span><br><span class=\"line\"> </span><br><span class=\"line\">$(&apos;#input&apos;).addEventListener(&apos;input&apos;, function()&#123;</span><br><span class=\"line\">\twindow.parent.postMessage(this.value, &apos;*&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">window.addEventListener(&apos;message&apos;,function(e) &#123; //添加监听a.html传过来的数据</span><br><span class=\"line\">\t\t$(&apos;#input&apos;).value = e.data</span><br><span class=\"line\">    console.log(e.data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">function $(id)&#123;</span><br><span class=\"line\">\treturn document.querySelector(id);</span><br><span class=\"line\">&#125;\t</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>总结下，主要jsonp和cors需要服务器端配合，用的也多一些。其余两种用的少，基本用语iframe。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是跨域，简单来说就三个\"><a href=\"#什么是跨域，简单来说就三个\" class=\"headerlink\" title=\"什么是跨域，简单来说就三个\"></a>什么是跨域，简单来说就三个</h3><ul>\n<li>端口: 例如一个80端口，一个8080端口，用ajax从80端口向8080端口获取数据，那么就会跨域。</li>\n<li>协议: 就是http协议还是https协议，file协议，ftp等等。</li>\n<li>域名: baidu.com, a.baidu.com</li>\n</ul>\n<h3 id=\"解决跨域的几个实现的方法\"><a href=\"#解决跨域的几个实现的方法\" class=\"headerlink\" title=\"解决跨域的几个实现的方法:\"></a>解决跨域的几个实现的方法:</h3><p>1.jsonp</p>\n<p>由于用ajax的方法从其他域名获取资源涉及到跨域，那么回想一下，当我们在网页中加载<code>script</code>标签的时候，也并不是在本域名下，而是使用<code>&lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</code>这种方式，可以理解为这种方式会把相应的js代码插入到相应的位置，那么我们可以使用这种方式来解决跨域问题。从代码来看<br>","more":"<br>客户端(html端):假如我们当前的页面是<code>a.jrg.com</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$(&apos;.change&apos;).addEventListener(&apos;click&apos;, function()&#123;</span><br><span class=\"line\">  var script = document.createElement(&apos;script&apos;);</span><br><span class=\"line\">  script.src = &apos;http://b.jrg.com:8080/getNews?callback=appendHtml&apos;; //客户端请求的网址，在请求的资源网址上加上了callback=appendHtml，</span><br><span class=\"line\">  document.head.appendChild(script); //将其放在head标签内</span><br><span class=\"line\">  document.head.removeChild(script);  //加载完进行移除</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">function appendHtml(news)&#123;</span><br><span class=\"line\">  var html = &apos;&apos;;</span><br><span class=\"line\">  for( var i=0; i&lt;news.length; i++)&#123;</span><br><span class=\"line\">    html += &apos;&lt;li&gt;&apos; + news[i] + &apos;&lt;/li&gt;&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  $(&apos;.news&apos;).innerHTML = html;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function $(id)&#123;</span><br><span class=\"line\">  return document.querySelector(id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>加载完<code>script</code>标签，获取到的资源如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendHtml(</span><br><span class=\"line\">[</span><br><span class=\"line\">&quot;正直播柴飚/洪炜出战 男双力争会师决赛&quot;,</span><br><span class=\"line\">&quot;博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多&quot;,</span><br><span class=\"line\">&quot;第11日前瞻：中国冲击4金 博尔特再战200米羽球&quot;</span><br><span class=\"line\">]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>由于客户端有<code>appendHtml</code>这个函数,那么就会执行这个函数。也就完成了数据的获取和解析方式。</p>\n<p>服务端:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(&apos;/getNews&apos;, function(req, res)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar news = [</span><br><span class=\"line\">\t\t&quot;第11日前瞻：中国冲击4金 博尔特再战200米羽球&quot;,</span><br><span class=\"line\">\t\t&quot;正直播柴飚/洪炜出战 男双力争会师决赛&quot;,</span><br><span class=\"line\">\t\t&quot;女排将死磕巴西！郎平安排男陪练模仿对方核心&quot;,</span><br><span class=\"line\">\t\t&quot;没有中国选手和巨星的110米栏 我们还看吗？&quot;,</span><br><span class=\"line\">\t\t&quot;中英上演奥运金牌大战&quot;,</span><br><span class=\"line\">\t\t&quot;博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多&quot;,</span><br><span class=\"line\">\t\t&quot;最“出柜”奥运？同性之爱闪耀里约&quot;,</span><br><span class=\"line\">\t\t&quot;下跪拜谢与洪荒之力一样 都是真情流露&quot;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">\tvar data = [];</span><br><span class=\"line\">\tfor(var i=0; i&lt;3; i++)&#123;</span><br><span class=\"line\">\t\tvar index = parseInt(Math.random()*news.length);</span><br><span class=\"line\">\t\tdata.push(news[index]);</span><br><span class=\"line\">\t\tnews.splice(index, 1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvar cb = req.query.callback; //这里获取回调函数的名称为appendHtml，这个名称是可以和前端进行约定的</span><br><span class=\"line\">\tif(cb)&#123;</span><br><span class=\"line\">\t\tres.send(cb + &apos;(&apos;+ JSON.stringify(data) + &apos;)&apos;); //这里要把原始的数据进行封装，即appendHtml(xxx)，前端相当于执行个appendHtml函数。xxx即为数据。</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">\t\tres.send(data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>cors:</li>\n</ol>\n<p>当我们跨域，会给我们提示<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code>,说明头部没有允许这个源获取数据，所以我们需要在服务端的head中加入。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(&apos;/getNews&apos;, function(req, res)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvar news = [</span><br><span class=\"line\">\t\t&quot;第11日前瞻：中国冲击4金 博尔特再战200米羽球&quot;,</span><br><span class=\"line\">\t\t&quot;正直播柴飚/洪炜出战 男双力争会师决赛&quot;,</span><br><span class=\"line\">\t\t&quot;女排将死磕巴西！郎平安排男陪练模仿对方核心&quot;,</span><br><span class=\"line\">\t\t&quot;没有中国选手和巨星的110米栏 我们还看吗？&quot;,</span><br><span class=\"line\">\t\t&quot;中英上演奥运金牌大战&quot;,</span><br><span class=\"line\">\t\t&quot;博彩赔率挺中国夺回第二纽约时报：中国因对手服禁药而丢失的奖牌最多&quot;,</span><br><span class=\"line\">\t\t&quot;最“出柜”奥运？同性之爱闪耀里约&quot;,</span><br><span class=\"line\">\t\t&quot;下跪拜谢与洪荒之力一样 都是真情流露&quot;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">\tvar data = [];</span><br><span class=\"line\">\tfor(var i=0; i&lt;3; i++)&#123;</span><br><span class=\"line\">\t\tvar index = parseInt(Math.random()*news.length);</span><br><span class=\"line\">\t\tdata.push(news[index]);</span><br><span class=\"line\">\t\tnews.splice(index, 1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres.header(&quot;Access-Control-Allow-Origin&quot;, &quot;http://a.jrg.com:8080&quot;); //这里是在返回头加上了允许获取的数据的源，即允许获取数据的往网址，为&apos;*&apos;代表所有 </span><br><span class=\"line\">\t//res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); </span><br><span class=\"line\">\tres.send(data);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>客户端：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;.change&apos;).addEventListener(&apos;click&apos;, function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  var xhr = new XMLHttpRequest();</span><br><span class=\"line\">  xhr.open(&apos;get&apos;, &apos;http://b.jrg.com:8080/getNews&apos;, true);</span><br><span class=\"line\">  xhr.send();</span><br><span class=\"line\">  xhr.onreadystatechange = function()&#123;</span><br><span class=\"line\">    if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123;</span><br><span class=\"line\">      appendHtml( JSON.parse(xhr.responseText) )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  window.xhr = xhr</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">function appendHtml(news)&#123;</span><br><span class=\"line\">  var html = &apos;&apos;;</span><br><span class=\"line\">  for( var i=0; i&lt;news.length; i++)&#123;</span><br><span class=\"line\">    html += &apos;&lt;li&gt;&apos; + news[i] + &apos;&lt;/li&gt;&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(html);</span><br><span class=\"line\">  $(&apos;.news&apos;).innerHTML = html;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function $(id)&#123;</span><br><span class=\"line\">  return document.querySelector(id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>cors只需要我们在服务端加上允许请求的网址即可。</p>\n<ol start=\"3\">\n<li>降域</li>\n</ol>\n<p>主要涉及两个页面之间，无需服务器端参与<br>例如<code>a.jrg.com</code>页面下面有一个iframe，为<code>b.jrg.com</code>，那么操作这个iframe的内容涉及到跨域，在<code>script</code>的标签中加入<code>document.domain=&#39;jrg.com&#39;</code>即可。<br>a.html如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;ct&quot;&gt;</span><br><span class=\"line\">  &lt;h1&gt;使用降域实现跨域&lt;/h1&gt;</span><br><span class=\"line\">  &lt;div class=&quot;main&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; placeholder=&quot;http://a.jrg.com:8080/a.html&quot;&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;iframe src=&quot;http://b.jrg.com:8080/b.html&quot; frameborder=&quot;0&quot; &gt;&lt;/iframe&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">//URL: http://a.jrg.com:8080/a.html</span><br><span class=\"line\"></span><br><span class=\"line\">document.querySelector(&apos;.main input&apos;).addEventListener(&apos;input&apos;, function()&#123;</span><br><span class=\"line\">  console.log(this.value);</span><br><span class=\"line\">  window.frames[0].document.querySelector(&apos;input&apos;).value = this.value;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">document.domain = &quot;jrg.com&quot;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>b.html如下,也要写上<code>document.domian=&#39;jrg.com&#39;</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;input&quot; type=&quot;text&quot;  placeholder=&quot;http://b.jrg.com:8080/b.html&quot;&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// URL: http://b.jrg.com:8080/b.html</span><br><span class=\"line\"> </span><br><span class=\"line\">document.querySelector(&apos;#input&apos;).addEventListener(&apos;input&apos;, function()&#123;</span><br><span class=\"line\">\twindow.parent.document.querySelector(&apos;input&apos;).value = this.value;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">document.domain = &apos;jrg.com&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"4\">\n<li>postMessage</li>\n</ol>\n<p>这里主要涉及<code>window</code>对象，也无需服务器端参与</p>\n<p>a.html的页面内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;ct&quot;&gt;</span><br><span class=\"line\">\t&lt;h1&gt;使用postMessage实现跨域&lt;/h1&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;main&quot;&gt;</span><br><span class=\"line\">\t\t&lt;input type=&quot;text&quot; placeholder=&quot;http://a.jrg.com:8080/a.html&quot;&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;iframe src=&quot;http://localhost:8080/b.html&quot; frameborder=&quot;0&quot; &gt;&lt;/iframe&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">//URL: http://a.jrg.com:8080/a.html</span><br><span class=\"line\"></span><br><span class=\"line\">$(&apos;.main input&apos;).addEventListener(&apos;input&apos;, function()&#123;</span><br><span class=\"line\">\tconsole.log(this.value);</span><br><span class=\"line\">\twindow.frames[0].postMessage(this.value,&apos;*&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">window.addEventListener(&apos;message&apos;,function(e) &#123;</span><br><span class=\"line\">\t\t$(&apos;.main input&apos;).value = e.data</span><br><span class=\"line\">    console.log(e.data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">function $(id)&#123;</span><br><span class=\"line\">\treturn document.querySelector(id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>b.html的内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;input&quot; type=&quot;text&quot;  placeholder=&quot;http://b.jrg.com:8080/b.html&quot;&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// URL: http://b.jrg.com:8080/b.html</span><br><span class=\"line\"> </span><br><span class=\"line\">$(&apos;#input&apos;).addEventListener(&apos;input&apos;, function()&#123;</span><br><span class=\"line\">\twindow.parent.postMessage(this.value, &apos;*&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">window.addEventListener(&apos;message&apos;,function(e) &#123; //添加监听a.html传过来的数据</span><br><span class=\"line\">\t\t$(&apos;#input&apos;).value = e.data</span><br><span class=\"line\">    console.log(e.data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">function $(id)&#123;</span><br><span class=\"line\">\treturn document.querySelector(id);</span><br><span class=\"line\">&#125;\t</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>总结下，主要jsonp和cors需要服务器端配合，用的也多一些。其余两种用的少，基本用语iframe。</p>"},{"layout":"posts","title":"双向绑定的实现","date":"2019-05-22T11:47:23.000Z","_content":"\n### 双向绑定的实现\n\n#### 几种实现双向绑定的做法\n\n> 发布者-订阅者模式(backbone.js)\n\n> 脏值检查(angular.js)\n\n> 数据劫持(vue.js)\n\n1.发布者-订阅者模式: 一般通过sub，pub的方式实现数据和师徒的绑定监听，更新数据的做法通常是`vm.set('property', value)`，我们更希望使用`vm.property=value`来更新数据，同时更新视图，于是有了下面两种方式。\n\n2.脏值检查：angular.js是通过脏值检查来对比数据是否有变更，最简单的方法就是通过`setInterval`来轮询检查数据是否变动，angular只有在指定的时间触发时才会进入脏值检测，大致如下: \n- DOM事件，比如用户输入文本，点击按钮等\n- XHR响应事件\n- 浏览器的location事件\n- Timer事件\n- 执行$digest()或$apply()\n\n3.数据劫持: vue则是通过数据劫持结合发布者订阅者模式，通过`Object.defineProperty`来劫持各个属性的`setter`，`getter`,在数据变动时发布消息给订阅者，触发相应的回调。\n\n\n####大致的思路\n\n1.实现一个Observer，能够对数据的所有属性进行监听，如果有变动拿到最新值来通知订阅者。\n\n2.实现一个Complier，对每个元素节点的指令进行扫描和解析，根据指定模板替换数据，以及绑定相应的更新函数。\n\n3.实现一个Watcher，作为Observer和Complier的桥梁，能够订阅并且收到每个属性变动的通知，执行指令绑定的回调函数，实现更新视图。\n\n4.mvvm入口函数，整合上述三者。\n\n\n\n##### 实现Observer\n利用`Object.defineProperty()`来监听属性的变动，那么需要observer的数据对象进行递归遍历，包括子属性对象的属性。都加上`setter`和`getter`。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/双向绑定的实现.md","raw":"---\nlayout: posts\ntitle: 双向绑定的实现\ndate: 2019-05-22 19:47:23\ntags: 前端\ncategories: 前端\n---\n\n### 双向绑定的实现\n\n#### 几种实现双向绑定的做法\n\n> 发布者-订阅者模式(backbone.js)\n\n> 脏值检查(angular.js)\n\n> 数据劫持(vue.js)\n\n1.发布者-订阅者模式: 一般通过sub，pub的方式实现数据和师徒的绑定监听，更新数据的做法通常是`vm.set('property', value)`，我们更希望使用`vm.property=value`来更新数据，同时更新视图，于是有了下面两种方式。\n\n2.脏值检查：angular.js是通过脏值检查来对比数据是否有变更，最简单的方法就是通过`setInterval`来轮询检查数据是否变动，angular只有在指定的时间触发时才会进入脏值检测，大致如下: \n- DOM事件，比如用户输入文本，点击按钮等\n- XHR响应事件\n- 浏览器的location事件\n- Timer事件\n- 执行$digest()或$apply()\n\n3.数据劫持: vue则是通过数据劫持结合发布者订阅者模式，通过`Object.defineProperty`来劫持各个属性的`setter`，`getter`,在数据变动时发布消息给订阅者，触发相应的回调。\n\n\n####大致的思路\n\n1.实现一个Observer，能够对数据的所有属性进行监听，如果有变动拿到最新值来通知订阅者。\n\n2.实现一个Complier，对每个元素节点的指令进行扫描和解析，根据指定模板替换数据，以及绑定相应的更新函数。\n\n3.实现一个Watcher，作为Observer和Complier的桥梁，能够订阅并且收到每个属性变动的通知，执行指令绑定的回调函数，实现更新视图。\n\n4.mvvm入口函数，整合上述三者。\n\n\n\n##### 实现Observer\n利用`Object.defineProperty()`来监听属性的变动，那么需要observer的数据对象进行递归遍历，包括子属性对象的属性。都加上`setter`和`getter`。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"双向绑定的实现","published":1,"updated":"2022-05-20T02:24:20.544Z","comments":1,"photos":[],"link":"","_id":"cl3e0vh7u002blae1pxebeam7","content":"<h3 id=\"双向绑定的实现\"><a href=\"#双向绑定的实现\" class=\"headerlink\" title=\"双向绑定的实现\"></a>双向绑定的实现</h3><h4 id=\"几种实现双向绑定的做法\"><a href=\"#几种实现双向绑定的做法\" class=\"headerlink\" title=\"几种实现双向绑定的做法\"></a>几种实现双向绑定的做法</h4><blockquote>\n<p>发布者-订阅者模式(backbone.js)</p>\n</blockquote>\n<blockquote>\n<p>脏值检查(angular.js)</p>\n</blockquote>\n<blockquote>\n<p>数据劫持(vue.js)</p>\n</blockquote>\n<p>1.发布者-订阅者模式: 一般通过sub，pub的方式实现数据和师徒的绑定监听，更新数据的做法通常是<code>vm.set(&#39;property&#39;, value)</code>，我们更希望使用<code>vm.property=value</code>来更新数据，同时更新视图，于是有了下面两种方式。</p>\n<p>2.脏值检查：angular.js是通过脏值检查来对比数据是否有变更，最简单的方法就是通过<code>setInterval</code>来轮询检查数据是否变动，angular只有在指定的时间触发时才会进入脏值检测，大致如下: </p>\n<ul>\n<li>DOM事件，比如用户输入文本，点击按钮等</li>\n<li>XHR响应事件</li>\n<li>浏览器的location事件</li>\n<li>Timer事件</li>\n<li>执行$digest()或$apply()</li>\n</ul>\n<p>3.数据劫持: vue则是通过数据劫持结合发布者订阅者模式，通过<code>Object.defineProperty</code>来劫持各个属性的<code>setter</code>，<code>getter</code>,在数据变动时发布消息给订阅者，触发相应的回调。</p>\n<p>####大致的思路</p>\n<p>1.实现一个Observer，能够对数据的所有属性进行监听，如果有变动拿到最新值来通知订阅者。</p>\n<p>2.实现一个Complier，对每个元素节点的指令进行扫描和解析，根据指定模板替换数据，以及绑定相应的更新函数。</p>\n<p>3.实现一个Watcher，作为Observer和Complier的桥梁，能够订阅并且收到每个属性变动的通知，执行指令绑定的回调函数，实现更新视图。</p>\n<p>4.mvvm入口函数，整合上述三者。</p>\n<h5 id=\"实现Observer\"><a href=\"#实现Observer\" class=\"headerlink\" title=\"实现Observer\"></a>实现Observer</h5><p>利用<code>Object.defineProperty()</code>来监听属性的变动，那么需要observer的数据对象进行递归遍历，包括子属性对象的属性。都加上<code>setter</code>和<code>getter</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"双向绑定的实现\"><a href=\"#双向绑定的实现\" class=\"headerlink\" title=\"双向绑定的实现\"></a>双向绑定的实现</h3><h4 id=\"几种实现双向绑定的做法\"><a href=\"#几种实现双向绑定的做法\" class=\"headerlink\" title=\"几种实现双向绑定的做法\"></a>几种实现双向绑定的做法</h4><blockquote>\n<p>发布者-订阅者模式(backbone.js)</p>\n</blockquote>\n<blockquote>\n<p>脏值检查(angular.js)</p>\n</blockquote>\n<blockquote>\n<p>数据劫持(vue.js)</p>\n</blockquote>\n<p>1.发布者-订阅者模式: 一般通过sub，pub的方式实现数据和师徒的绑定监听，更新数据的做法通常是<code>vm.set(&#39;property&#39;, value)</code>，我们更希望使用<code>vm.property=value</code>来更新数据，同时更新视图，于是有了下面两种方式。</p>\n<p>2.脏值检查：angular.js是通过脏值检查来对比数据是否有变更，最简单的方法就是通过<code>setInterval</code>来轮询检查数据是否变动，angular只有在指定的时间触发时才会进入脏值检测，大致如下: </p>\n<ul>\n<li>DOM事件，比如用户输入文本，点击按钮等</li>\n<li>XHR响应事件</li>\n<li>浏览器的location事件</li>\n<li>Timer事件</li>\n<li>执行$digest()或$apply()</li>\n</ul>\n<p>3.数据劫持: vue则是通过数据劫持结合发布者订阅者模式，通过<code>Object.defineProperty</code>来劫持各个属性的<code>setter</code>，<code>getter</code>,在数据变动时发布消息给订阅者，触发相应的回调。</p>\n<p>####大致的思路</p>\n<p>1.实现一个Observer，能够对数据的所有属性进行监听，如果有变动拿到最新值来通知订阅者。</p>\n<p>2.实现一个Complier，对每个元素节点的指令进行扫描和解析，根据指定模板替换数据，以及绑定相应的更新函数。</p>\n<p>3.实现一个Watcher，作为Observer和Complier的桥梁，能够订阅并且收到每个属性变动的通知，执行指令绑定的回调函数，实现更新视图。</p>\n<p>4.mvvm入口函数，整合上述三者。</p>\n<h5 id=\"实现Observer\"><a href=\"#实现Observer\" class=\"headerlink\" title=\"实现Observer\"></a>实现Observer</h5><p>利用<code>Object.defineProperty()</code>来监听属性的变动，那么需要observer的数据对象进行递归遍历，包括子属性对象的属性。都加上<code>setter</code>和<code>getter</code>。</p>\n"},{"title":"广度优先搜索","date":"2018-12-24T03:20:21.000Z","_content":"#### 图是什么\n\n图是一组连接，图由节点和边构成，一个节点可能和众多节点相连，这些节点被称为邻居。\n\n#### 广度优先搜索\n\n一般用于解决两类问题：\n- 从节点A出发，有前往节点B的路径吗\n- 从节点A出发，前往节点B的哪条路径最短\n\n<!-- more -->\n#### 利用队列实现\n\n队列的工作原理与生活中队列相似。队列类似于栈，你不能随机的访问队列中的元素，队列只支持两种操作:入队和出队。队列是一种先进先出的数据结构，而栈是先进后出的数据结构。    \n利用散列表实现\n```\ngraph = {}\ngraph[you''] = ['alice', 'bob', 'clair']\n```\n你被映射到一个数组，这个数组为你所有的邻居。    \n实现一个算法检验你的朋友是否有一个以m结尾：    \n```\nfrom collections import deque\nsearch_queue = deque()  #创建一个队列\nsearch_queue += graph['you']  #将你的邻居加入到队列\nserached = []\nwhile search_queue:\n    person = search_queue.popleft()\n    if person not in searched:\n        if person[-1] == 'm':\n            print('Has found')\n        else:\n            search_queue += graph[person]\n            searched.append(person)  #标记为检查\nreturn false \n```\n如果在整个人际网中搜索以m结尾的人，意味着你将沿着每条边前进，因此运行事件至少为Ｏ(边数)，还使用了队列，入队的总人数ｎ时间复杂度Ｏ(n),故广度优先的运行时间为O(V+E),其中Ｖ是顶点数，Ｅ为边数。\n\n\n#### 狄克斯特拉算法\n\n其实就是在图的边上加上权重。狄利斯克拉算法包含的４个步骤：    \n\n- 找出`最便宜`的节点,即可在最短时间内到达的节点\n- 更近该节点的邻居开销\n- 重复这个过程，直到对图中的所有节点都这样做了，终点可不计算\n－计算最终路径    \n\n狄克斯特拉算法只适用于有向无环图(directed acyclic　graph,DAG),对于无向图来说，每条边都是一个环。　　　　\n\n对于负权重则不可以使用此算法。如果存在负权重的边，使用贝尔曼－福德算法。\n\n#### 示例\n\n<div style=\"width: 200px; margin: auto\">![示例图片](/images/search.jpeg)</div>　　　　\n\n- 先将所有的几点存储到散列表中。例如之前，但是这里还要存储权重。\n\n```\ngraph['you'] = ['aclice', 'bon', 'caler']\n```\n- 表示这些边的邻居和权重，也使用散列表\n\n```\ngraph['start'] = {}  #起点\ngraph['start']['a'] = 6\ngraph['start']['b'] = 2\n\ngraph['a'] = {}  #a\ngraph['a']['final'] = 1\n\ngraph['b'] = {}  #b\ngraph['b']['a'] = 3\ngraph['b']['final'] = 5\n\ngraph['final'] = {}\n```\n- 还需要创建一个开销的散列表\n\n```\ninfinity = float(\"inf\")\ncost = {}\ncosts['a'] = 6\ncosts['b'] = 2\ncosts['final'] = infinity\n\n```\n- 需要一个存储父节点的散列表\n\n```\nparents = {}\nparents['a'] = \"start\"\nparents['b'] = 'start'\nparents['final'] = None\n```\n\n- 需要一个列表来存储记录过的节点\n\n```\nprocess = []\n```\n总代码：node从非start的节点开始\n```\nnode = find_lowest_cost_node(costs) #在未处理的节点找出开销最少的节点\nwhile node is not None:\n    cost = costs[node]\n    neighbors = graph[node]\n    for n in neighbors.keys():\n        new_cost = cost + neighbors[n]\n        if costs[n] > new_cost:\n            costs[n] = new_cost\n            parents[n] = node\n    processed.append(node)\n    node = find_lowest_cost_node(costs)\n    \ndef find_lowest_cost_node(costs):\n    lowest_cost = float(\"inf\")\n    lowest_cost_node = None\n    for node in costs:\n        cost = costs[node]\n        if cost < lower_cost and node not in processed:\n            lower_cost = cost\n            lower_cost_node = node\n    return lower_cost_node\n```","source":"_posts/广度优先搜索.md","raw":"---\ntitle: 广度优先搜索\ndate: 2018-12-24 11:20:21\ntags: 算法\ncategories: 算法\n---\n#### 图是什么\n\n图是一组连接，图由节点和边构成，一个节点可能和众多节点相连，这些节点被称为邻居。\n\n#### 广度优先搜索\n\n一般用于解决两类问题：\n- 从节点A出发，有前往节点B的路径吗\n- 从节点A出发，前往节点B的哪条路径最短\n\n<!-- more -->\n#### 利用队列实现\n\n队列的工作原理与生活中队列相似。队列类似于栈，你不能随机的访问队列中的元素，队列只支持两种操作:入队和出队。队列是一种先进先出的数据结构，而栈是先进后出的数据结构。    \n利用散列表实现\n```\ngraph = {}\ngraph[you''] = ['alice', 'bob', 'clair']\n```\n你被映射到一个数组，这个数组为你所有的邻居。    \n实现一个算法检验你的朋友是否有一个以m结尾：    \n```\nfrom collections import deque\nsearch_queue = deque()  #创建一个队列\nsearch_queue += graph['you']  #将你的邻居加入到队列\nserached = []\nwhile search_queue:\n    person = search_queue.popleft()\n    if person not in searched:\n        if person[-1] == 'm':\n            print('Has found')\n        else:\n            search_queue += graph[person]\n            searched.append(person)  #标记为检查\nreturn false \n```\n如果在整个人际网中搜索以m结尾的人，意味着你将沿着每条边前进，因此运行事件至少为Ｏ(边数)，还使用了队列，入队的总人数ｎ时间复杂度Ｏ(n),故广度优先的运行时间为O(V+E),其中Ｖ是顶点数，Ｅ为边数。\n\n\n#### 狄克斯特拉算法\n\n其实就是在图的边上加上权重。狄利斯克拉算法包含的４个步骤：    \n\n- 找出`最便宜`的节点,即可在最短时间内到达的节点\n- 更近该节点的邻居开销\n- 重复这个过程，直到对图中的所有节点都这样做了，终点可不计算\n－计算最终路径    \n\n狄克斯特拉算法只适用于有向无环图(directed acyclic　graph,DAG),对于无向图来说，每条边都是一个环。　　　　\n\n对于负权重则不可以使用此算法。如果存在负权重的边，使用贝尔曼－福德算法。\n\n#### 示例\n\n<div style=\"width: 200px; margin: auto\">![示例图片](/images/search.jpeg)</div>　　　　\n\n- 先将所有的几点存储到散列表中。例如之前，但是这里还要存储权重。\n\n```\ngraph['you'] = ['aclice', 'bon', 'caler']\n```\n- 表示这些边的邻居和权重，也使用散列表\n\n```\ngraph['start'] = {}  #起点\ngraph['start']['a'] = 6\ngraph['start']['b'] = 2\n\ngraph['a'] = {}  #a\ngraph['a']['final'] = 1\n\ngraph['b'] = {}  #b\ngraph['b']['a'] = 3\ngraph['b']['final'] = 5\n\ngraph['final'] = {}\n```\n- 还需要创建一个开销的散列表\n\n```\ninfinity = float(\"inf\")\ncost = {}\ncosts['a'] = 6\ncosts['b'] = 2\ncosts['final'] = infinity\n\n```\n- 需要一个存储父节点的散列表\n\n```\nparents = {}\nparents['a'] = \"start\"\nparents['b'] = 'start'\nparents['final'] = None\n```\n\n- 需要一个列表来存储记录过的节点\n\n```\nprocess = []\n```\n总代码：node从非start的节点开始\n```\nnode = find_lowest_cost_node(costs) #在未处理的节点找出开销最少的节点\nwhile node is not None:\n    cost = costs[node]\n    neighbors = graph[node]\n    for n in neighbors.keys():\n        new_cost = cost + neighbors[n]\n        if costs[n] > new_cost:\n            costs[n] = new_cost\n            parents[n] = node\n    processed.append(node)\n    node = find_lowest_cost_node(costs)\n    \ndef find_lowest_cost_node(costs):\n    lowest_cost = float(\"inf\")\n    lowest_cost_node = None\n    for node in costs:\n        cost = costs[node]\n        if cost < lower_cost and node not in processed:\n            lower_cost = cost\n            lower_cost_node = node\n    return lower_cost_node\n```","slug":"广度优先搜索","published":1,"updated":"2022-05-20T02:24:20.544Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7v002dlae1ak4yommq","content":"<h4 id=\"图是什么\"><a href=\"#图是什么\" class=\"headerlink\" title=\"图是什么\"></a>图是什么</h4><p>图是一组连接，图由节点和边构成，一个节点可能和众多节点相连，这些节点被称为邻居。</p>\n<h4 id=\"广度优先搜索\"><a href=\"#广度优先搜索\" class=\"headerlink\" title=\"广度优先搜索\"></a>广度优先搜索</h4><p>一般用于解决两类问题：</p>\n<ul>\n<li>从节点A出发，有前往节点B的路径吗</li>\n<li>从节点A出发，前往节点B的哪条路径最短</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"利用队列实现\"><a href=\"#利用队列实现\" class=\"headerlink\" title=\"利用队列实现\"></a>利用队列实现</h4><p>队列的工作原理与生活中队列相似。队列类似于栈，你不能随机的访问队列中的元素，队列只支持两种操作:入队和出队。队列是一种先进先出的数据结构，而栈是先进后出的数据结构。<br>利用散列表实现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph = &#123;&#125;</span><br><span class=\"line\">graph[you&apos;&apos;] = [&apos;alice&apos;, &apos;bob&apos;, &apos;clair&apos;]</span><br></pre></td></tr></table></figure></p>\n<p>你被映射到一个数组，这个数组为你所有的邻居。<br>实现一个算法检验你的朋友是否有一个以m结尾：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from collections import deque</span><br><span class=\"line\">search_queue = deque()  #创建一个队列</span><br><span class=\"line\">search_queue += graph[&apos;you&apos;]  #将你的邻居加入到队列</span><br><span class=\"line\">serached = []</span><br><span class=\"line\">while search_queue:</span><br><span class=\"line\">    person = search_queue.popleft()</span><br><span class=\"line\">    if person not in searched:</span><br><span class=\"line\">        if person[-1] == &apos;m&apos;:</span><br><span class=\"line\">            print(&apos;Has found&apos;)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            search_queue += graph[person]</span><br><span class=\"line\">            searched.append(person)  #标记为检查</span><br><span class=\"line\">return false</span><br></pre></td></tr></table></figure></p>\n<p>如果在整个人际网中搜索以m结尾的人，意味着你将沿着每条边前进，因此运行事件至少为Ｏ(边数)，还使用了队列，入队的总人数ｎ时间复杂度Ｏ(n),故广度优先的运行时间为O(V+E),其中Ｖ是顶点数，Ｅ为边数。</p>\n<h4 id=\"狄克斯特拉算法\"><a href=\"#狄克斯特拉算法\" class=\"headerlink\" title=\"狄克斯特拉算法\"></a>狄克斯特拉算法</h4><p>其实就是在图的边上加上权重。狄利斯克拉算法包含的４个步骤：    </p>\n<ul>\n<li>找出<code>最便宜</code>的节点,即可在最短时间内到达的节点</li>\n<li>更近该节点的邻居开销</li>\n<li>重复这个过程，直到对图中的所有节点都这样做了，终点可不计算<br>－计算最终路径    </li>\n</ul>\n<p>狄克斯特拉算法只适用于有向无环图(directed acyclic　graph,DAG),对于无向图来说，每条边都是一个环。　　　　</p>\n<p>对于负权重则不可以使用此算法。如果存在负权重的边，使用贝尔曼－福德算法。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p><div style=\"width: 200px; margin: auto\"><img src=\"/images/search.jpeg\" alt=\"示例图片\"></div>　　　　</p>\n<ul>\n<li>先将所有的几点存储到散列表中。例如之前，但是这里还要存储权重。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph[&apos;you&apos;] = [&apos;aclice&apos;, &apos;bon&apos;, &apos;caler&apos;]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>表示这些边的邻居和权重，也使用散列表</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph[&apos;start&apos;] = &#123;&#125;  #起点</span><br><span class=\"line\">graph[&apos;start&apos;][&apos;a&apos;] = 6</span><br><span class=\"line\">graph[&apos;start&apos;][&apos;b&apos;] = 2</span><br><span class=\"line\"></span><br><span class=\"line\">graph[&apos;a&apos;] = &#123;&#125;  #a</span><br><span class=\"line\">graph[&apos;a&apos;][&apos;final&apos;] = 1</span><br><span class=\"line\"></span><br><span class=\"line\">graph[&apos;b&apos;] = &#123;&#125;  #b</span><br><span class=\"line\">graph[&apos;b&apos;][&apos;a&apos;] = 3</span><br><span class=\"line\">graph[&apos;b&apos;][&apos;final&apos;] = 5</span><br><span class=\"line\"></span><br><span class=\"line\">graph[&apos;final&apos;] = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>还需要创建一个开销的散列表</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">infinity = float(&quot;inf&quot;)</span><br><span class=\"line\">cost = &#123;&#125;</span><br><span class=\"line\">costs[&apos;a&apos;] = 6</span><br><span class=\"line\">costs[&apos;b&apos;] = 2</span><br><span class=\"line\">costs[&apos;final&apos;] = infinity</span><br></pre></td></tr></table></figure>\n<ul>\n<li>需要一个存储父节点的散列表</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parents = &#123;&#125;</span><br><span class=\"line\">parents[&apos;a&apos;] = &quot;start&quot;</span><br><span class=\"line\">parents[&apos;b&apos;] = &apos;start&apos;</span><br><span class=\"line\">parents[&apos;final&apos;] = None</span><br></pre></td></tr></table></figure>\n<ul>\n<li>需要一个列表来存储记录过的节点</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process = []</span><br></pre></td></tr></table></figure>\n<p>总代码：node从非start的节点开始<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node = find_lowest_cost_node(costs) #在未处理的节点找出开销最少的节点</span><br><span class=\"line\">while node is not None:</span><br><span class=\"line\">    cost = costs[node]</span><br><span class=\"line\">    neighbors = graph[node]</span><br><span class=\"line\">    for n in neighbors.keys():</span><br><span class=\"line\">        new_cost = cost + neighbors[n]</span><br><span class=\"line\">        if costs[n] &gt; new_cost:</span><br><span class=\"line\">            costs[n] = new_cost</span><br><span class=\"line\">            parents[n] = node</span><br><span class=\"line\">    processed.append(node)</span><br><span class=\"line\">    node = find_lowest_cost_node(costs)</span><br><span class=\"line\">    </span><br><span class=\"line\">def find_lowest_cost_node(costs):</span><br><span class=\"line\">    lowest_cost = float(&quot;inf&quot;)</span><br><span class=\"line\">    lowest_cost_node = None</span><br><span class=\"line\">    for node in costs:</span><br><span class=\"line\">        cost = costs[node]</span><br><span class=\"line\">        if cost &lt; lower_cost and node not in processed:</span><br><span class=\"line\">            lower_cost = cost</span><br><span class=\"line\">            lower_cost_node = node</span><br><span class=\"line\">    return lower_cost_node</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"图是什么\"><a href=\"#图是什么\" class=\"headerlink\" title=\"图是什么\"></a>图是什么</h4><p>图是一组连接，图由节点和边构成，一个节点可能和众多节点相连，这些节点被称为邻居。</p>\n<h4 id=\"广度优先搜索\"><a href=\"#广度优先搜索\" class=\"headerlink\" title=\"广度优先搜索\"></a>广度优先搜索</h4><p>一般用于解决两类问题：</p>\n<ul>\n<li>从节点A出发，有前往节点B的路径吗</li>\n<li>从节点A出发，前往节点B的哪条路径最短</li>\n</ul>","more":"<h4 id=\"利用队列实现\"><a href=\"#利用队列实现\" class=\"headerlink\" title=\"利用队列实现\"></a>利用队列实现</h4><p>队列的工作原理与生活中队列相似。队列类似于栈，你不能随机的访问队列中的元素，队列只支持两种操作:入队和出队。队列是一种先进先出的数据结构，而栈是先进后出的数据结构。<br>利用散列表实现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph = &#123;&#125;</span><br><span class=\"line\">graph[you&apos;&apos;] = [&apos;alice&apos;, &apos;bob&apos;, &apos;clair&apos;]</span><br></pre></td></tr></table></figure></p>\n<p>你被映射到一个数组，这个数组为你所有的邻居。<br>实现一个算法检验你的朋友是否有一个以m结尾：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from collections import deque</span><br><span class=\"line\">search_queue = deque()  #创建一个队列</span><br><span class=\"line\">search_queue += graph[&apos;you&apos;]  #将你的邻居加入到队列</span><br><span class=\"line\">serached = []</span><br><span class=\"line\">while search_queue:</span><br><span class=\"line\">    person = search_queue.popleft()</span><br><span class=\"line\">    if person not in searched:</span><br><span class=\"line\">        if person[-1] == &apos;m&apos;:</span><br><span class=\"line\">            print(&apos;Has found&apos;)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            search_queue += graph[person]</span><br><span class=\"line\">            searched.append(person)  #标记为检查</span><br><span class=\"line\">return false</span><br></pre></td></tr></table></figure></p>\n<p>如果在整个人际网中搜索以m结尾的人，意味着你将沿着每条边前进，因此运行事件至少为Ｏ(边数)，还使用了队列，入队的总人数ｎ时间复杂度Ｏ(n),故广度优先的运行时间为O(V+E),其中Ｖ是顶点数，Ｅ为边数。</p>\n<h4 id=\"狄克斯特拉算法\"><a href=\"#狄克斯特拉算法\" class=\"headerlink\" title=\"狄克斯特拉算法\"></a>狄克斯特拉算法</h4><p>其实就是在图的边上加上权重。狄利斯克拉算法包含的４个步骤：    </p>\n<ul>\n<li>找出<code>最便宜</code>的节点,即可在最短时间内到达的节点</li>\n<li>更近该节点的邻居开销</li>\n<li>重复这个过程，直到对图中的所有节点都这样做了，终点可不计算<br>－计算最终路径    </li>\n</ul>\n<p>狄克斯特拉算法只适用于有向无环图(directed acyclic　graph,DAG),对于无向图来说，每条边都是一个环。　　　　</p>\n<p>对于负权重则不可以使用此算法。如果存在负权重的边，使用贝尔曼－福德算法。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p><div style=\"width: 200px; margin: auto\"><img src=\"/images/search.jpeg\" alt=\"示例图片\"></div>　　　　</p>\n<ul>\n<li>先将所有的几点存储到散列表中。例如之前，但是这里还要存储权重。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph[&apos;you&apos;] = [&apos;aclice&apos;, &apos;bon&apos;, &apos;caler&apos;]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>表示这些边的邻居和权重，也使用散列表</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph[&apos;start&apos;] = &#123;&#125;  #起点</span><br><span class=\"line\">graph[&apos;start&apos;][&apos;a&apos;] = 6</span><br><span class=\"line\">graph[&apos;start&apos;][&apos;b&apos;] = 2</span><br><span class=\"line\"></span><br><span class=\"line\">graph[&apos;a&apos;] = &#123;&#125;  #a</span><br><span class=\"line\">graph[&apos;a&apos;][&apos;final&apos;] = 1</span><br><span class=\"line\"></span><br><span class=\"line\">graph[&apos;b&apos;] = &#123;&#125;  #b</span><br><span class=\"line\">graph[&apos;b&apos;][&apos;a&apos;] = 3</span><br><span class=\"line\">graph[&apos;b&apos;][&apos;final&apos;] = 5</span><br><span class=\"line\"></span><br><span class=\"line\">graph[&apos;final&apos;] = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>还需要创建一个开销的散列表</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">infinity = float(&quot;inf&quot;)</span><br><span class=\"line\">cost = &#123;&#125;</span><br><span class=\"line\">costs[&apos;a&apos;] = 6</span><br><span class=\"line\">costs[&apos;b&apos;] = 2</span><br><span class=\"line\">costs[&apos;final&apos;] = infinity</span><br></pre></td></tr></table></figure>\n<ul>\n<li>需要一个存储父节点的散列表</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parents = &#123;&#125;</span><br><span class=\"line\">parents[&apos;a&apos;] = &quot;start&quot;</span><br><span class=\"line\">parents[&apos;b&apos;] = &apos;start&apos;</span><br><span class=\"line\">parents[&apos;final&apos;] = None</span><br></pre></td></tr></table></figure>\n<ul>\n<li>需要一个列表来存储记录过的节点</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process = []</span><br></pre></td></tr></table></figure>\n<p>总代码：node从非start的节点开始<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node = find_lowest_cost_node(costs) #在未处理的节点找出开销最少的节点</span><br><span class=\"line\">while node is not None:</span><br><span class=\"line\">    cost = costs[node]</span><br><span class=\"line\">    neighbors = graph[node]</span><br><span class=\"line\">    for n in neighbors.keys():</span><br><span class=\"line\">        new_cost = cost + neighbors[n]</span><br><span class=\"line\">        if costs[n] &gt; new_cost:</span><br><span class=\"line\">            costs[n] = new_cost</span><br><span class=\"line\">            parents[n] = node</span><br><span class=\"line\">    processed.append(node)</span><br><span class=\"line\">    node = find_lowest_cost_node(costs)</span><br><span class=\"line\">    </span><br><span class=\"line\">def find_lowest_cost_node(costs):</span><br><span class=\"line\">    lowest_cost = float(&quot;inf&quot;)</span><br><span class=\"line\">    lowest_cost_node = None</span><br><span class=\"line\">    for node in costs:</span><br><span class=\"line\">        cost = costs[node]</span><br><span class=\"line\">        if cost &lt; lower_cost and node not in processed:</span><br><span class=\"line\">            lower_cost = cost</span><br><span class=\"line\">            lower_cost_node = node</span><br><span class=\"line\">    return lower_cost_node</span><br></pre></td></tr></table></figure></p>"},{"title":"散列表","date":"2018-12-24T02:22:02.000Z","_content":"散列表通过散列函数和数组来创建。\n\n#### 散列函数\n\n散列函数是这样的函数，无论你给他什么数据，他都还给你一个数字。专业的来说，散列函数“将输入映射到数字”，满足的一些要求如下：\n\n- 他必须是一致的。例如输入apple得到的是4，那么每次输入apple必须都是4.如果不是这样，散列表将毫无用处。\n- 他应将不同的输入映射到不同的数字。例如，如果一个散列函数不管输入什么都返回1，则不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。\n<!-- more -->\n#### 简单的应用\n\n- 如python的字典是利用散列表实现的。\n- 我们访问每个网站，都需要把域名解析为对应的ip，刚好对应散列表，称为DNS的解析。\n- 将散列表应用于缓存，网站的页面的url映射到对应的数据。\n\n#### 散列因子\n\n散列表是用数组来装填数据，例如长度为5的数组，在索引为2,4的位置有了数据，那么散列表的填装因子为2/5，即0.4。如果有100个数据，数组的长度为50，那么填装因子为2.一旦填装因子增大，就需要在散列表中添加位置，这被称为`调整长度(resizing)`，因此首先需要创建一个新的更长的数组，通常来说增加一倍，然后使用hash函数将所有的元素插入新的列表中。大概的经验，一旦填装因子超过0.7，就需要调整散列表的长度","source":"_posts/散列表.md","raw":"---\ntitle: 散列表\ndate: 2018-12-24 10:22:02\ntags: 算法\ncategories: 算法\n---\n散列表通过散列函数和数组来创建。\n\n#### 散列函数\n\n散列函数是这样的函数，无论你给他什么数据，他都还给你一个数字。专业的来说，散列函数“将输入映射到数字”，满足的一些要求如下：\n\n- 他必须是一致的。例如输入apple得到的是4，那么每次输入apple必须都是4.如果不是这样，散列表将毫无用处。\n- 他应将不同的输入映射到不同的数字。例如，如果一个散列函数不管输入什么都返回1，则不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。\n<!-- more -->\n#### 简单的应用\n\n- 如python的字典是利用散列表实现的。\n- 我们访问每个网站，都需要把域名解析为对应的ip，刚好对应散列表，称为DNS的解析。\n- 将散列表应用于缓存，网站的页面的url映射到对应的数据。\n\n#### 散列因子\n\n散列表是用数组来装填数据，例如长度为5的数组，在索引为2,4的位置有了数据，那么散列表的填装因子为2/5，即0.4。如果有100个数据，数组的长度为50，那么填装因子为2.一旦填装因子增大，就需要在散列表中添加位置，这被称为`调整长度(resizing)`，因此首先需要创建一个新的更长的数组，通常来说增加一倍，然后使用hash函数将所有的元素插入新的列表中。大概的经验，一旦填装因子超过0.7，就需要调整散列表的长度","slug":"散列表","published":1,"updated":"2022-05-20T02:24:20.544Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7v002hlae1zuj1lv30","content":"<p>散列表通过散列函数和数组来创建。</p>\n<h4 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h4><p>散列函数是这样的函数，无论你给他什么数据，他都还给你一个数字。专业的来说，散列函数“将输入映射到数字”，满足的一些要求如下：</p>\n<ul>\n<li>他必须是一致的。例如输入apple得到的是4，那么每次输入apple必须都是4.如果不是这样，散列表将毫无用处。</li>\n<li><p>他应将不同的输入映射到不同的数字。例如，如果一个散列函数不管输入什么都返回1，则不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。</p>\n<a id=\"more\"></a>\n<h4 id=\"简单的应用\"><a href=\"#简单的应用\" class=\"headerlink\" title=\"简单的应用\"></a>简单的应用</h4></li>\n<li><p>如python的字典是利用散列表实现的。</p>\n</li>\n<li>我们访问每个网站，都需要把域名解析为对应的ip，刚好对应散列表，称为DNS的解析。</li>\n<li>将散列表应用于缓存，网站的页面的url映射到对应的数据。</li>\n</ul>\n<h4 id=\"散列因子\"><a href=\"#散列因子\" class=\"headerlink\" title=\"散列因子\"></a>散列因子</h4><p>散列表是用数组来装填数据，例如长度为5的数组，在索引为2,4的位置有了数据，那么散列表的填装因子为2/5，即0.4。如果有100个数据，数组的长度为50，那么填装因子为2.一旦填装因子增大，就需要在散列表中添加位置，这被称为<code>调整长度(resizing)</code>，因此首先需要创建一个新的更长的数组，通常来说增加一倍，然后使用hash函数将所有的元素插入新的列表中。大概的经验，一旦填装因子超过0.7，就需要调整散列表的长度</p>\n","site":{"data":{}},"excerpt":"<p>散列表通过散列函数和数组来创建。</p>\n<h4 id=\"散列函数\"><a href=\"#散列函数\" class=\"headerlink\" title=\"散列函数\"></a>散列函数</h4><p>散列函数是这样的函数，无论你给他什么数据，他都还给你一个数字。专业的来说，散列函数“将输入映射到数字”，满足的一些要求如下：</p>\n<ul>\n<li>他必须是一致的。例如输入apple得到的是4，那么每次输入apple必须都是4.如果不是这样，散列表将毫无用处。</li>\n<li><p>他应将不同的输入映射到不同的数字。例如，如果一个散列函数不管输入什么都返回1，则不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。</p>","more":"<h4 id=\"简单的应用\"><a href=\"#简单的应用\" class=\"headerlink\" title=\"简单的应用\"></a>简单的应用</h4></li>\n<li><p>如python的字典是利用散列表实现的。</p>\n</li>\n<li>我们访问每个网站，都需要把域名解析为对应的ip，刚好对应散列表，称为DNS的解析。</li>\n<li>将散列表应用于缓存，网站的页面的url映射到对应的数据。</li>\n</ul>\n<h4 id=\"散列因子\"><a href=\"#散列因子\" class=\"headerlink\" title=\"散列因子\"></a>散列因子</h4><p>散列表是用数组来装填数据，例如长度为5的数组，在索引为2,4的位置有了数据，那么散列表的填装因子为2/5，即0.4。如果有100个数据，数组的长度为50，那么填装因子为2.一旦填装因子增大，就需要在散列表中添加位置，这被称为<code>调整长度(resizing)</code>，因此首先需要创建一个新的更长的数组，通常来说增加一倍，然后使用hash函数将所有的元素插入新的列表中。大概的经验，一旦填装因子超过0.7，就需要调整散列表的长度</p>"},{"title":"记tomcat的部署与apache的反向代理","date":"2018-12-27T10:06:39.000Z","_content":"\n### tomcat的部署\n\n首先，先说一下tomcat的部署，tomcat的部署的文件位于/conf/server.xml中，其中默认的端口为8080，一般来说http访问都是80端口，那么只需要把8080端口改成80端口即可。    \n其次，更改为https部署，首选我们可以去阿里云申请免费的的ssl证书，那么在server.xml中配置\n```\n<Connector port=\"443\"\n    protocol=\"org.apache.coyote.http11.Http11Protocol\"\n    SSLEnabled=\"true\"\n    scheme=\"https\"\n    secure=\"true\"\n    keystoreFile=\"/home/guoxy/product-sites/apache-tomcat-7.0.88/conf/cert/1616181_xuyunrui.cn.pfx\"\n    keystoreType=\"PKCS12\"\n    keystorePass=\"EClj60j3\"\n    clientAuth=\"false\"\n    SSLProtocol=\"TLSv1+TLSv1.1+TLSv1.2\"\n    ciphers=\"TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256\"/>\n\n```\n当着样部署好以后，那么就可以利用https访问了。\n\n<!-- more -->\n### 反向代理tomcat的端口\n\n先说下为什么要反向代理。首先，原来的服务起的80端口apache已经使用了，供其他的网页使用。此时如果tomcat也是用80端口，那么就会发现端口已经被占用，无法进行绑定。所以google了一下，找到的方法是利用apache来代理tomcat的端口即可。例如假如tomcat运行在8080端口，那么我们在apache下新建一个.conf文件来反代xx.com:8080即可。    \n说一下具体的操作:\n\n- 首先网上找的一堆教程都是修改httpd.conf，但是在ubuntu下的apache2下，根本没有这个文件。我们的网站的配置文件均位于\n```\n/etc/apache2/site-available/\n```\n我们在此新建tomcat.conf.配置如下\n```\n<VirtualHost *:80>\n        # The ServerName directive sets the request scheme, hostname and port that\n        # the server uses to identify itself. This is used when creating\n        # redirection URLs. In the context of virtual hosts, the ServerName\n        # specifies what hostname must appear in the request's Host: header to\n        # match this virtual host. For the default virtual host (this file) this\n        # value is not decisive as it is used as a last resort host regardless.\n        # However, you must set it for any further virtual host explicitly.\n        #ServerName www.example.com\n\n        #ServerAdmin webmaster@localhost\n        #DocumentRoot /var/www/html\n        #配置站点的域名\n        ServerName beta.steering.ai\n        #配置站点的管理员信息\n        #ServerAdmin admin@xuyunrui.com\n\n        #off表示开启反向代理，on表示开启正向代理\n        ProxyRequests Off\n        ProxyMaxForwards 100\n        ProxyPreserveHost On\n        #这里表示要将现在这个虚拟主机跳转到本机的8080端口\n        ProxyPass / http://127.0.0.1:8080/\n        ProxyPassReverse / http://127.0.0.1:8080/\n        <Proxy *>\n            Order Deny,Allow\n            Allow from all\n        </Proxy>\n        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,\n        # error, crit, alert, emerg.\n        # It is also possible to configure the loglevel for particular\n        # modules, e.g.\n        #LogLevel info ssl:warn\n\n        ErrorLog ${APACHE_LOG_DIR}/error.log\n        CustomLog ${APACHE_LOG_DIR}/access.log combined\n\n        # For most configuration files from conf-available/, which are\n        # enabled or disabled at a global level, it is possible to\n        # include a line for only one particular virtual host. For example the\n        # following line enables the CGI configuration for this host only\n        # after it has been globally disabled with \"a2disconf\".\n        #Include conf-available/serve-cgi-bin.conf\n</VirtualHost>\n\n# vim: syntax=apache ts=4 sw=4 sts=4 sr noet\n\n```\n上面的信息都已经注释了含义，首先要开一个80端口的虚拟主机。\n\n- servername即为我们的域名.\n- ProxyRequests Off #off表示开启反向代理，on表示开启正向代理\n-  ProxyPass / http://127.0.0.1:8080/ && ProxyPassReverse / http://127.0.0.1:8080/是指要代理的网址以及反代的资源网址。\n-  后面的就是常规配置了。\n-  但是一般来说我们为了安全性，都是把网站配置成https的访问形式，所以需要重新配置tomcat.conf文件\n```\n<VirtualHost *:443>\n        # The ServerName directive sets the request scheme, hostname and port that\n        # the server uses to identify itself. This is used when creating\n        # redirection URLs. In the context of virtual hosts, the ServerName\n        # specifies what hostname must appear in the request's Host: header to\n        # match this virtual host. For the default virtual host (this file) this\n        # value is not decisive as it is used as a last resort host regardless.\n        # However, you must set it for any further virtual host explicitly.\n        #ServerName www.example.com\n\n        #ServerAdmin webmaster@localhost\n        #DocumentRoot /var/www/html\n        #配置站点的域名\n        ServerName beta.steering.ai\n        #配置站点的管理员信息\n        #ServerAdmin admin@xuyunrui.com\n        #ssl 这里写ssl证书的位置文件\n        SSLEngine on\n        SSLCertificateFile \"/etc/steering.ai/STAR_steering_ai.crt\"\n        SSLCertificateKeyFile \"/etc/steering.ai/STAR_steering_ai.key\"\n\n        #off表示开启反向代理，on表示开启正向代理\n        ProxyRequests Off\n        ProxyMaxForwards 100\n        ProxyPreserveHost On\n        #这里表示要将现在这个虚拟主机跳转到本机的8080端口\n        ProxyPass / http://127.0.0.1:8080/\n        ProxyPassReverse / http://127.0.0.1:8080/\n        <Proxy *>\n            Order Deny,Allow\n            Allow from all\n        </Proxy>\n        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,\n        # error, crit, alert, emerg.\n        # It is also possible to configure the loglevel for particular\n        # modules, e.g.\n        #LogLevel info ssl:warn\n\n        ErrorLog ${APACHE_LOG_DIR}/error.log\n        CustomLog ${APACHE_LOG_DIR}/access.log combined\n\n        # For most configuration files from conf-available/, which are\n        # enabled or disabled at a global level, it is possible to\n        # include a line for only one particular virtual host. For example the\n        # following line enables the CGI configuration for this host only\n        # after it has been globally disabled with \"a2disconf\".\n        #Include conf-available/serve-cgi-bin.conf\n</VirtualHost>\n```\n也就是加上了ssl的证书，所以配置反代还是代理原来的8080端口，而不是配置tomcat的8443端口进行https访问。\n\n#### docker的部署\n\n这里我把tomcat的文件部署到docker中，Dockerfile如下\n```\nFROM ubuntu:16.04\nCOPY [\"jdk-6u45-linux-x64.bin\", \".\"]\nRUN  apt-get update && apt-get install -y vim\nRUN  cp jdk-6u45-linux-x64.bin /usr/local\nRUN  cd /usr/local && chmod +x jdk-6u45-linux-x64.bin\nRUN  cd /usr/local && ./jdk-6u45-linux-x64.bin\nENV JAVA_HOME=/usr/local/jdk1.6.0_45\nENV CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nENV PATH=$PATH:$JAVA_HOME/bin\nRUN cd /home && mkdir -p /guoxy/product-sites/apache-tomcat-7.0.88\nCOPY apache-tomcat-7.0.88 /home/guoxy/product-sites/apache-tomcat-7.0.88\nWORKDIR /home/guoxy/product-sites/apache-tomcat-7.0.88/bin\nCMD ./start.sh\n```\n相应的文件都有，这里主要是java的jdk和tomcat的文件。执行\n```\ndocker build -t tomcat:v1 .\n```\n这时候吧镜像上传到自己dockerhub，需要给自己的镜像打上tag\n```\ndocker login #先登录\ndocker tag tomcat:company guoxy/tomcat:company  #其中guoxy为自己的仓库名\ndocker push guoxy/tomcat:company\n```\n此时镜像上传到自己的dockerhub。运行映射一下端口\n```\ndocker run -it -p 8080:8080 tomcat:company /bin/bash\n```\n按下Ctrl+P+Q使容器在后台运行。再次进入\n```\ndocker exec -it tomcat:company /bin/bash 进入如果没启动在bin目录下./startup.sh\n```","source":"_posts/记tomcat的部署与apache的反向代理.md","raw":"---\ntitle: 记tomcat的部署与apache的反向代理\ndate: 2018-12-27 18:06:39\ntags: 服务器\ncategories: 服务器\n---\n\n### tomcat的部署\n\n首先，先说一下tomcat的部署，tomcat的部署的文件位于/conf/server.xml中，其中默认的端口为8080，一般来说http访问都是80端口，那么只需要把8080端口改成80端口即可。    \n其次，更改为https部署，首选我们可以去阿里云申请免费的的ssl证书，那么在server.xml中配置\n```\n<Connector port=\"443\"\n    protocol=\"org.apache.coyote.http11.Http11Protocol\"\n    SSLEnabled=\"true\"\n    scheme=\"https\"\n    secure=\"true\"\n    keystoreFile=\"/home/guoxy/product-sites/apache-tomcat-7.0.88/conf/cert/1616181_xuyunrui.cn.pfx\"\n    keystoreType=\"PKCS12\"\n    keystorePass=\"EClj60j3\"\n    clientAuth=\"false\"\n    SSLProtocol=\"TLSv1+TLSv1.1+TLSv1.2\"\n    ciphers=\"TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256\"/>\n\n```\n当着样部署好以后，那么就可以利用https访问了。\n\n<!-- more -->\n### 反向代理tomcat的端口\n\n先说下为什么要反向代理。首先，原来的服务起的80端口apache已经使用了，供其他的网页使用。此时如果tomcat也是用80端口，那么就会发现端口已经被占用，无法进行绑定。所以google了一下，找到的方法是利用apache来代理tomcat的端口即可。例如假如tomcat运行在8080端口，那么我们在apache下新建一个.conf文件来反代xx.com:8080即可。    \n说一下具体的操作:\n\n- 首先网上找的一堆教程都是修改httpd.conf，但是在ubuntu下的apache2下，根本没有这个文件。我们的网站的配置文件均位于\n```\n/etc/apache2/site-available/\n```\n我们在此新建tomcat.conf.配置如下\n```\n<VirtualHost *:80>\n        # The ServerName directive sets the request scheme, hostname and port that\n        # the server uses to identify itself. This is used when creating\n        # redirection URLs. In the context of virtual hosts, the ServerName\n        # specifies what hostname must appear in the request's Host: header to\n        # match this virtual host. For the default virtual host (this file) this\n        # value is not decisive as it is used as a last resort host regardless.\n        # However, you must set it for any further virtual host explicitly.\n        #ServerName www.example.com\n\n        #ServerAdmin webmaster@localhost\n        #DocumentRoot /var/www/html\n        #配置站点的域名\n        ServerName beta.steering.ai\n        #配置站点的管理员信息\n        #ServerAdmin admin@xuyunrui.com\n\n        #off表示开启反向代理，on表示开启正向代理\n        ProxyRequests Off\n        ProxyMaxForwards 100\n        ProxyPreserveHost On\n        #这里表示要将现在这个虚拟主机跳转到本机的8080端口\n        ProxyPass / http://127.0.0.1:8080/\n        ProxyPassReverse / http://127.0.0.1:8080/\n        <Proxy *>\n            Order Deny,Allow\n            Allow from all\n        </Proxy>\n        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,\n        # error, crit, alert, emerg.\n        # It is also possible to configure the loglevel for particular\n        # modules, e.g.\n        #LogLevel info ssl:warn\n\n        ErrorLog ${APACHE_LOG_DIR}/error.log\n        CustomLog ${APACHE_LOG_DIR}/access.log combined\n\n        # For most configuration files from conf-available/, which are\n        # enabled or disabled at a global level, it is possible to\n        # include a line for only one particular virtual host. For example the\n        # following line enables the CGI configuration for this host only\n        # after it has been globally disabled with \"a2disconf\".\n        #Include conf-available/serve-cgi-bin.conf\n</VirtualHost>\n\n# vim: syntax=apache ts=4 sw=4 sts=4 sr noet\n\n```\n上面的信息都已经注释了含义，首先要开一个80端口的虚拟主机。\n\n- servername即为我们的域名.\n- ProxyRequests Off #off表示开启反向代理，on表示开启正向代理\n-  ProxyPass / http://127.0.0.1:8080/ && ProxyPassReverse / http://127.0.0.1:8080/是指要代理的网址以及反代的资源网址。\n-  后面的就是常规配置了。\n-  但是一般来说我们为了安全性，都是把网站配置成https的访问形式，所以需要重新配置tomcat.conf文件\n```\n<VirtualHost *:443>\n        # The ServerName directive sets the request scheme, hostname and port that\n        # the server uses to identify itself. This is used when creating\n        # redirection URLs. In the context of virtual hosts, the ServerName\n        # specifies what hostname must appear in the request's Host: header to\n        # match this virtual host. For the default virtual host (this file) this\n        # value is not decisive as it is used as a last resort host regardless.\n        # However, you must set it for any further virtual host explicitly.\n        #ServerName www.example.com\n\n        #ServerAdmin webmaster@localhost\n        #DocumentRoot /var/www/html\n        #配置站点的域名\n        ServerName beta.steering.ai\n        #配置站点的管理员信息\n        #ServerAdmin admin@xuyunrui.com\n        #ssl 这里写ssl证书的位置文件\n        SSLEngine on\n        SSLCertificateFile \"/etc/steering.ai/STAR_steering_ai.crt\"\n        SSLCertificateKeyFile \"/etc/steering.ai/STAR_steering_ai.key\"\n\n        #off表示开启反向代理，on表示开启正向代理\n        ProxyRequests Off\n        ProxyMaxForwards 100\n        ProxyPreserveHost On\n        #这里表示要将现在这个虚拟主机跳转到本机的8080端口\n        ProxyPass / http://127.0.0.1:8080/\n        ProxyPassReverse / http://127.0.0.1:8080/\n        <Proxy *>\n            Order Deny,Allow\n            Allow from all\n        </Proxy>\n        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,\n        # error, crit, alert, emerg.\n        # It is also possible to configure the loglevel for particular\n        # modules, e.g.\n        #LogLevel info ssl:warn\n\n        ErrorLog ${APACHE_LOG_DIR}/error.log\n        CustomLog ${APACHE_LOG_DIR}/access.log combined\n\n        # For most configuration files from conf-available/, which are\n        # enabled or disabled at a global level, it is possible to\n        # include a line for only one particular virtual host. For example the\n        # following line enables the CGI configuration for this host only\n        # after it has been globally disabled with \"a2disconf\".\n        #Include conf-available/serve-cgi-bin.conf\n</VirtualHost>\n```\n也就是加上了ssl的证书，所以配置反代还是代理原来的8080端口，而不是配置tomcat的8443端口进行https访问。\n\n#### docker的部署\n\n这里我把tomcat的文件部署到docker中，Dockerfile如下\n```\nFROM ubuntu:16.04\nCOPY [\"jdk-6u45-linux-x64.bin\", \".\"]\nRUN  apt-get update && apt-get install -y vim\nRUN  cp jdk-6u45-linux-x64.bin /usr/local\nRUN  cd /usr/local && chmod +x jdk-6u45-linux-x64.bin\nRUN  cd /usr/local && ./jdk-6u45-linux-x64.bin\nENV JAVA_HOME=/usr/local/jdk1.6.0_45\nENV CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nENV PATH=$PATH:$JAVA_HOME/bin\nRUN cd /home && mkdir -p /guoxy/product-sites/apache-tomcat-7.0.88\nCOPY apache-tomcat-7.0.88 /home/guoxy/product-sites/apache-tomcat-7.0.88\nWORKDIR /home/guoxy/product-sites/apache-tomcat-7.0.88/bin\nCMD ./start.sh\n```\n相应的文件都有，这里主要是java的jdk和tomcat的文件。执行\n```\ndocker build -t tomcat:v1 .\n```\n这时候吧镜像上传到自己dockerhub，需要给自己的镜像打上tag\n```\ndocker login #先登录\ndocker tag tomcat:company guoxy/tomcat:company  #其中guoxy为自己的仓库名\ndocker push guoxy/tomcat:company\n```\n此时镜像上传到自己的dockerhub。运行映射一下端口\n```\ndocker run -it -p 8080:8080 tomcat:company /bin/bash\n```\n按下Ctrl+P+Q使容器在后台运行。再次进入\n```\ndocker exec -it tomcat:company /bin/bash 进入如果没启动在bin目录下./startup.sh\n```","slug":"记tomcat的部署与apache的反向代理","published":1,"updated":"2022-05-20T02:24:20.544Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7w002jlae1v3mvvo1b","content":"<h3 id=\"tomcat的部署\"><a href=\"#tomcat的部署\" class=\"headerlink\" title=\"tomcat的部署\"></a>tomcat的部署</h3><p>首先，先说一下tomcat的部署，tomcat的部署的文件位于/conf/server.xml中，其中默认的端口为8080，一般来说http访问都是80端口，那么只需要把8080端口改成80端口即可。<br>其次，更改为https部署，首选我们可以去阿里云申请免费的的ssl证书，那么在server.xml中配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Connector port=&quot;443&quot;</span><br><span class=\"line\">    protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;</span><br><span class=\"line\">    SSLEnabled=&quot;true&quot;</span><br><span class=\"line\">    scheme=&quot;https&quot;</span><br><span class=\"line\">    secure=&quot;true&quot;</span><br><span class=\"line\">    keystoreFile=&quot;/home/guoxy/product-sites/apache-tomcat-7.0.88/conf/cert/1616181_xuyunrui.cn.pfx&quot;</span><br><span class=\"line\">    keystoreType=&quot;PKCS12&quot;</span><br><span class=\"line\">    keystorePass=&quot;EClj60j3&quot;</span><br><span class=\"line\">    clientAuth=&quot;false&quot;</span><br><span class=\"line\">    SSLProtocol=&quot;TLSv1+TLSv1.1+TLSv1.2&quot;</span><br><span class=\"line\">    ciphers=&quot;TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<p>当着样部署好以后，那么就可以利用https访问了。</p>\n<a id=\"more\"></a>\n<h3 id=\"反向代理tomcat的端口\"><a href=\"#反向代理tomcat的端口\" class=\"headerlink\" title=\"反向代理tomcat的端口\"></a>反向代理tomcat的端口</h3><p>先说下为什么要反向代理。首先，原来的服务起的80端口apache已经使用了，供其他的网页使用。此时如果tomcat也是用80端口，那么就会发现端口已经被占用，无法进行绑定。所以google了一下，找到的方法是利用apache来代理tomcat的端口即可。例如假如tomcat运行在8080端口，那么我们在apache下新建一个.conf文件来反代xx.com:8080即可。<br>说一下具体的操作:</p>\n<ul>\n<li>首先网上找的一堆教程都是修改httpd.conf，但是在ubuntu下的apache2下，根本没有这个文件。我们的网站的配置文件均位于<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/apache2/site-available/</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们在此新建tomcat.conf.配置如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;VirtualHost *:80&gt;</span><br><span class=\"line\">        # The ServerName directive sets the request scheme, hostname and port that</span><br><span class=\"line\">        # the server uses to identify itself. This is used when creating</span><br><span class=\"line\">        # redirection URLs. In the context of virtual hosts, the ServerName</span><br><span class=\"line\">        # specifies what hostname must appear in the request&apos;s Host: header to</span><br><span class=\"line\">        # match this virtual host. For the default virtual host (this file) this</span><br><span class=\"line\">        # value is not decisive as it is used as a last resort host regardless.</span><br><span class=\"line\">        # However, you must set it for any further virtual host explicitly.</span><br><span class=\"line\">        #ServerName www.example.com</span><br><span class=\"line\"></span><br><span class=\"line\">        #ServerAdmin webmaster@localhost</span><br><span class=\"line\">        #DocumentRoot /var/www/html</span><br><span class=\"line\">        #配置站点的域名</span><br><span class=\"line\">        ServerName beta.steering.ai</span><br><span class=\"line\">        #配置站点的管理员信息</span><br><span class=\"line\">        #ServerAdmin admin@xuyunrui.com</span><br><span class=\"line\"></span><br><span class=\"line\">        #off表示开启反向代理，on表示开启正向代理</span><br><span class=\"line\">        ProxyRequests Off</span><br><span class=\"line\">        ProxyMaxForwards 100</span><br><span class=\"line\">        ProxyPreserveHost On</span><br><span class=\"line\">        #这里表示要将现在这个虚拟主机跳转到本机的8080端口</span><br><span class=\"line\">        ProxyPass / http://127.0.0.1:8080/</span><br><span class=\"line\">        ProxyPassReverse / http://127.0.0.1:8080/</span><br><span class=\"line\">        &lt;Proxy *&gt;</span><br><span class=\"line\">            Order Deny,Allow</span><br><span class=\"line\">            Allow from all</span><br><span class=\"line\">        &lt;/Proxy&gt;</span><br><span class=\"line\">        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,</span><br><span class=\"line\">        # error, crit, alert, emerg.</span><br><span class=\"line\">        # It is also possible to configure the loglevel for particular</span><br><span class=\"line\">        # modules, e.g.</span><br><span class=\"line\">        #LogLevel info ssl:warn</span><br><span class=\"line\"></span><br><span class=\"line\">        ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br><span class=\"line\">        CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined</span><br><span class=\"line\"></span><br><span class=\"line\">        # For most configuration files from conf-available/, which are</span><br><span class=\"line\">        # enabled or disabled at a global level, it is possible to</span><br><span class=\"line\">        # include a line for only one particular virtual host. For example the</span><br><span class=\"line\">        # following line enables the CGI configuration for this host only</span><br><span class=\"line\">        # after it has been globally disabled with &quot;a2disconf&quot;.</span><br><span class=\"line\">        #Include conf-available/serve-cgi-bin.conf</span><br><span class=\"line\">&lt;/VirtualHost&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># vim: syntax=apache ts=4 sw=4 sts=4 sr noet</span><br></pre></td></tr></table></figure></p>\n<p>上面的信息都已经注释了含义，首先要开一个80端口的虚拟主机。</p>\n<ul>\n<li>servername即为我们的域名.</li>\n<li>ProxyRequests Off #off表示开启反向代理，on表示开启正向代理</li>\n<li>ProxyPass / <a href=\"http://127.0.0.1:8080/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/</a> &amp;&amp; ProxyPassReverse / <a href=\"http://127.0.0.1:8080/是指要代理的网址以及反代的资源网址。\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/是指要代理的网址以及反代的资源网址。</a></li>\n<li>后面的就是常规配置了。</li>\n<li>但是一般来说我们为了安全性，都是把网站配置成https的访问形式，所以需要重新配置tomcat.conf文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;VirtualHost *:443&gt;</span><br><span class=\"line\">        # The ServerName directive sets the request scheme, hostname and port that</span><br><span class=\"line\">        # the server uses to identify itself. This is used when creating</span><br><span class=\"line\">        # redirection URLs. In the context of virtual hosts, the ServerName</span><br><span class=\"line\">        # specifies what hostname must appear in the request&apos;s Host: header to</span><br><span class=\"line\">        # match this virtual host. For the default virtual host (this file) this</span><br><span class=\"line\">        # value is not decisive as it is used as a last resort host regardless.</span><br><span class=\"line\">        # However, you must set it for any further virtual host explicitly.</span><br><span class=\"line\">        #ServerName www.example.com</span><br><span class=\"line\"></span><br><span class=\"line\">        #ServerAdmin webmaster@localhost</span><br><span class=\"line\">        #DocumentRoot /var/www/html</span><br><span class=\"line\">        #配置站点的域名</span><br><span class=\"line\">        ServerName beta.steering.ai</span><br><span class=\"line\">        #配置站点的管理员信息</span><br><span class=\"line\">        #ServerAdmin admin@xuyunrui.com</span><br><span class=\"line\">        #ssl 这里写ssl证书的位置文件</span><br><span class=\"line\">        SSLEngine on</span><br><span class=\"line\">        SSLCertificateFile &quot;/etc/steering.ai/STAR_steering_ai.crt&quot;</span><br><span class=\"line\">        SSLCertificateKeyFile &quot;/etc/steering.ai/STAR_steering_ai.key&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        #off表示开启反向代理，on表示开启正向代理</span><br><span class=\"line\">        ProxyRequests Off</span><br><span class=\"line\">        ProxyMaxForwards 100</span><br><span class=\"line\">        ProxyPreserveHost On</span><br><span class=\"line\">        #这里表示要将现在这个虚拟主机跳转到本机的8080端口</span><br><span class=\"line\">        ProxyPass / http://127.0.0.1:8080/</span><br><span class=\"line\">        ProxyPassReverse / http://127.0.0.1:8080/</span><br><span class=\"line\">        &lt;Proxy *&gt;</span><br><span class=\"line\">            Order Deny,Allow</span><br><span class=\"line\">            Allow from all</span><br><span class=\"line\">        &lt;/Proxy&gt;</span><br><span class=\"line\">        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,</span><br><span class=\"line\">        # error, crit, alert, emerg.</span><br><span class=\"line\">        # It is also possible to configure the loglevel for particular</span><br><span class=\"line\">        # modules, e.g.</span><br><span class=\"line\">        #LogLevel info ssl:warn</span><br><span class=\"line\"></span><br><span class=\"line\">        ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br><span class=\"line\">        CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined</span><br><span class=\"line\"></span><br><span class=\"line\">        # For most configuration files from conf-available/, which are</span><br><span class=\"line\">        # enabled or disabled at a global level, it is possible to</span><br><span class=\"line\">        # include a line for only one particular virtual host. For example the</span><br><span class=\"line\">        # following line enables the CGI configuration for this host only</span><br><span class=\"line\">        # after it has been globally disabled with &quot;a2disconf&quot;.</span><br><span class=\"line\">        #Include conf-available/serve-cgi-bin.conf</span><br><span class=\"line\">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>也就是加上了ssl的证书，所以配置反代还是代理原来的8080端口，而不是配置tomcat的8443端口进行https访问。</p>\n<h4 id=\"docker的部署\"><a href=\"#docker的部署\" class=\"headerlink\" title=\"docker的部署\"></a>docker的部署</h4><p>这里我把tomcat的文件部署到docker中，Dockerfile如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM ubuntu:16.04</span><br><span class=\"line\">COPY [&quot;jdk-6u45-linux-x64.bin&quot;, &quot;.&quot;]</span><br><span class=\"line\">RUN  apt-get update &amp;&amp; apt-get install -y vim</span><br><span class=\"line\">RUN  cp jdk-6u45-linux-x64.bin /usr/local</span><br><span class=\"line\">RUN  cd /usr/local &amp;&amp; chmod +x jdk-6u45-linux-x64.bin</span><br><span class=\"line\">RUN  cd /usr/local &amp;&amp; ./jdk-6u45-linux-x64.bin</span><br><span class=\"line\">ENV JAVA_HOME=/usr/local/jdk1.6.0_45</span><br><span class=\"line\">ENV CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class=\"line\">ENV PATH=$PATH:$JAVA_HOME/bin</span><br><span class=\"line\">RUN cd /home &amp;&amp; mkdir -p /guoxy/product-sites/apache-tomcat-7.0.88</span><br><span class=\"line\">COPY apache-tomcat-7.0.88 /home/guoxy/product-sites/apache-tomcat-7.0.88</span><br><span class=\"line\">WORKDIR /home/guoxy/product-sites/apache-tomcat-7.0.88/bin</span><br><span class=\"line\">CMD ./start.sh</span><br></pre></td></tr></table></figure></p>\n<p>相应的文件都有，这里主要是java的jdk和tomcat的文件。执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t tomcat:v1 .</span><br></pre></td></tr></table></figure></p>\n<p>这时候吧镜像上传到自己dockerhub，需要给自己的镜像打上tag<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker login #先登录</span><br><span class=\"line\">docker tag tomcat:company guoxy/tomcat:company  #其中guoxy为自己的仓库名</span><br><span class=\"line\">docker push guoxy/tomcat:company</span><br></pre></td></tr></table></figure></p>\n<p>此时镜像上传到自己的dockerhub。运行映射一下端口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -p 8080:8080 tomcat:company /bin/bash</span><br></pre></td></tr></table></figure></p>\n<p>按下Ctrl+P+Q使容器在后台运行。再次进入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it tomcat:company /bin/bash 进入如果没启动在bin目录下./startup.sh</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"tomcat的部署\"><a href=\"#tomcat的部署\" class=\"headerlink\" title=\"tomcat的部署\"></a>tomcat的部署</h3><p>首先，先说一下tomcat的部署，tomcat的部署的文件位于/conf/server.xml中，其中默认的端口为8080，一般来说http访问都是80端口，那么只需要把8080端口改成80端口即可。<br>其次，更改为https部署，首选我们可以去阿里云申请免费的的ssl证书，那么在server.xml中配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Connector port=&quot;443&quot;</span><br><span class=\"line\">    protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;</span><br><span class=\"line\">    SSLEnabled=&quot;true&quot;</span><br><span class=\"line\">    scheme=&quot;https&quot;</span><br><span class=\"line\">    secure=&quot;true&quot;</span><br><span class=\"line\">    keystoreFile=&quot;/home/guoxy/product-sites/apache-tomcat-7.0.88/conf/cert/1616181_xuyunrui.cn.pfx&quot;</span><br><span class=\"line\">    keystoreType=&quot;PKCS12&quot;</span><br><span class=\"line\">    keystorePass=&quot;EClj60j3&quot;</span><br><span class=\"line\">    clientAuth=&quot;false&quot;</span><br><span class=\"line\">    SSLProtocol=&quot;TLSv1+TLSv1.1+TLSv1.2&quot;</span><br><span class=\"line\">    ciphers=&quot;TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<p>当着样部署好以后，那么就可以利用https访问了。</p>","more":"<h3 id=\"反向代理tomcat的端口\"><a href=\"#反向代理tomcat的端口\" class=\"headerlink\" title=\"反向代理tomcat的端口\"></a>反向代理tomcat的端口</h3><p>先说下为什么要反向代理。首先，原来的服务起的80端口apache已经使用了，供其他的网页使用。此时如果tomcat也是用80端口，那么就会发现端口已经被占用，无法进行绑定。所以google了一下，找到的方法是利用apache来代理tomcat的端口即可。例如假如tomcat运行在8080端口，那么我们在apache下新建一个.conf文件来反代xx.com:8080即可。<br>说一下具体的操作:</p>\n<ul>\n<li>首先网上找的一堆教程都是修改httpd.conf，但是在ubuntu下的apache2下，根本没有这个文件。我们的网站的配置文件均位于<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/apache2/site-available/</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们在此新建tomcat.conf.配置如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;VirtualHost *:80&gt;</span><br><span class=\"line\">        # The ServerName directive sets the request scheme, hostname and port that</span><br><span class=\"line\">        # the server uses to identify itself. This is used when creating</span><br><span class=\"line\">        # redirection URLs. In the context of virtual hosts, the ServerName</span><br><span class=\"line\">        # specifies what hostname must appear in the request&apos;s Host: header to</span><br><span class=\"line\">        # match this virtual host. For the default virtual host (this file) this</span><br><span class=\"line\">        # value is not decisive as it is used as a last resort host regardless.</span><br><span class=\"line\">        # However, you must set it for any further virtual host explicitly.</span><br><span class=\"line\">        #ServerName www.example.com</span><br><span class=\"line\"></span><br><span class=\"line\">        #ServerAdmin webmaster@localhost</span><br><span class=\"line\">        #DocumentRoot /var/www/html</span><br><span class=\"line\">        #配置站点的域名</span><br><span class=\"line\">        ServerName beta.steering.ai</span><br><span class=\"line\">        #配置站点的管理员信息</span><br><span class=\"line\">        #ServerAdmin admin@xuyunrui.com</span><br><span class=\"line\"></span><br><span class=\"line\">        #off表示开启反向代理，on表示开启正向代理</span><br><span class=\"line\">        ProxyRequests Off</span><br><span class=\"line\">        ProxyMaxForwards 100</span><br><span class=\"line\">        ProxyPreserveHost On</span><br><span class=\"line\">        #这里表示要将现在这个虚拟主机跳转到本机的8080端口</span><br><span class=\"line\">        ProxyPass / http://127.0.0.1:8080/</span><br><span class=\"line\">        ProxyPassReverse / http://127.0.0.1:8080/</span><br><span class=\"line\">        &lt;Proxy *&gt;</span><br><span class=\"line\">            Order Deny,Allow</span><br><span class=\"line\">            Allow from all</span><br><span class=\"line\">        &lt;/Proxy&gt;</span><br><span class=\"line\">        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,</span><br><span class=\"line\">        # error, crit, alert, emerg.</span><br><span class=\"line\">        # It is also possible to configure the loglevel for particular</span><br><span class=\"line\">        # modules, e.g.</span><br><span class=\"line\">        #LogLevel info ssl:warn</span><br><span class=\"line\"></span><br><span class=\"line\">        ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br><span class=\"line\">        CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined</span><br><span class=\"line\"></span><br><span class=\"line\">        # For most configuration files from conf-available/, which are</span><br><span class=\"line\">        # enabled or disabled at a global level, it is possible to</span><br><span class=\"line\">        # include a line for only one particular virtual host. For example the</span><br><span class=\"line\">        # following line enables the CGI configuration for this host only</span><br><span class=\"line\">        # after it has been globally disabled with &quot;a2disconf&quot;.</span><br><span class=\"line\">        #Include conf-available/serve-cgi-bin.conf</span><br><span class=\"line\">&lt;/VirtualHost&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># vim: syntax=apache ts=4 sw=4 sts=4 sr noet</span><br></pre></td></tr></table></figure></p>\n<p>上面的信息都已经注释了含义，首先要开一个80端口的虚拟主机。</p>\n<ul>\n<li>servername即为我们的域名.</li>\n<li>ProxyRequests Off #off表示开启反向代理，on表示开启正向代理</li>\n<li>ProxyPass / <a href=\"http://127.0.0.1:8080/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/</a> &amp;&amp; ProxyPassReverse / <a href=\"http://127.0.0.1:8080/是指要代理的网址以及反代的资源网址。\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/是指要代理的网址以及反代的资源网址。</a></li>\n<li>后面的就是常规配置了。</li>\n<li>但是一般来说我们为了安全性，都是把网站配置成https的访问形式，所以需要重新配置tomcat.conf文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;VirtualHost *:443&gt;</span><br><span class=\"line\">        # The ServerName directive sets the request scheme, hostname and port that</span><br><span class=\"line\">        # the server uses to identify itself. This is used when creating</span><br><span class=\"line\">        # redirection URLs. In the context of virtual hosts, the ServerName</span><br><span class=\"line\">        # specifies what hostname must appear in the request&apos;s Host: header to</span><br><span class=\"line\">        # match this virtual host. For the default virtual host (this file) this</span><br><span class=\"line\">        # value is not decisive as it is used as a last resort host regardless.</span><br><span class=\"line\">        # However, you must set it for any further virtual host explicitly.</span><br><span class=\"line\">        #ServerName www.example.com</span><br><span class=\"line\"></span><br><span class=\"line\">        #ServerAdmin webmaster@localhost</span><br><span class=\"line\">        #DocumentRoot /var/www/html</span><br><span class=\"line\">        #配置站点的域名</span><br><span class=\"line\">        ServerName beta.steering.ai</span><br><span class=\"line\">        #配置站点的管理员信息</span><br><span class=\"line\">        #ServerAdmin admin@xuyunrui.com</span><br><span class=\"line\">        #ssl 这里写ssl证书的位置文件</span><br><span class=\"line\">        SSLEngine on</span><br><span class=\"line\">        SSLCertificateFile &quot;/etc/steering.ai/STAR_steering_ai.crt&quot;</span><br><span class=\"line\">        SSLCertificateKeyFile &quot;/etc/steering.ai/STAR_steering_ai.key&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">        #off表示开启反向代理，on表示开启正向代理</span><br><span class=\"line\">        ProxyRequests Off</span><br><span class=\"line\">        ProxyMaxForwards 100</span><br><span class=\"line\">        ProxyPreserveHost On</span><br><span class=\"line\">        #这里表示要将现在这个虚拟主机跳转到本机的8080端口</span><br><span class=\"line\">        ProxyPass / http://127.0.0.1:8080/</span><br><span class=\"line\">        ProxyPassReverse / http://127.0.0.1:8080/</span><br><span class=\"line\">        &lt;Proxy *&gt;</span><br><span class=\"line\">            Order Deny,Allow</span><br><span class=\"line\">            Allow from all</span><br><span class=\"line\">        &lt;/Proxy&gt;</span><br><span class=\"line\">        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,</span><br><span class=\"line\">        # error, crit, alert, emerg.</span><br><span class=\"line\">        # It is also possible to configure the loglevel for particular</span><br><span class=\"line\">        # modules, e.g.</span><br><span class=\"line\">        #LogLevel info ssl:warn</span><br><span class=\"line\"></span><br><span class=\"line\">        ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br><span class=\"line\">        CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined</span><br><span class=\"line\"></span><br><span class=\"line\">        # For most configuration files from conf-available/, which are</span><br><span class=\"line\">        # enabled or disabled at a global level, it is possible to</span><br><span class=\"line\">        # include a line for only one particular virtual host. For example the</span><br><span class=\"line\">        # following line enables the CGI configuration for this host only</span><br><span class=\"line\">        # after it has been globally disabled with &quot;a2disconf&quot;.</span><br><span class=\"line\">        #Include conf-available/serve-cgi-bin.conf</span><br><span class=\"line\">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>也就是加上了ssl的证书，所以配置反代还是代理原来的8080端口，而不是配置tomcat的8443端口进行https访问。</p>\n<h4 id=\"docker的部署\"><a href=\"#docker的部署\" class=\"headerlink\" title=\"docker的部署\"></a>docker的部署</h4><p>这里我把tomcat的文件部署到docker中，Dockerfile如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM ubuntu:16.04</span><br><span class=\"line\">COPY [&quot;jdk-6u45-linux-x64.bin&quot;, &quot;.&quot;]</span><br><span class=\"line\">RUN  apt-get update &amp;&amp; apt-get install -y vim</span><br><span class=\"line\">RUN  cp jdk-6u45-linux-x64.bin /usr/local</span><br><span class=\"line\">RUN  cd /usr/local &amp;&amp; chmod +x jdk-6u45-linux-x64.bin</span><br><span class=\"line\">RUN  cd /usr/local &amp;&amp; ./jdk-6u45-linux-x64.bin</span><br><span class=\"line\">ENV JAVA_HOME=/usr/local/jdk1.6.0_45</span><br><span class=\"line\">ENV CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class=\"line\">ENV PATH=$PATH:$JAVA_HOME/bin</span><br><span class=\"line\">RUN cd /home &amp;&amp; mkdir -p /guoxy/product-sites/apache-tomcat-7.0.88</span><br><span class=\"line\">COPY apache-tomcat-7.0.88 /home/guoxy/product-sites/apache-tomcat-7.0.88</span><br><span class=\"line\">WORKDIR /home/guoxy/product-sites/apache-tomcat-7.0.88/bin</span><br><span class=\"line\">CMD ./start.sh</span><br></pre></td></tr></table></figure></p>\n<p>相应的文件都有，这里主要是java的jdk和tomcat的文件。执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t tomcat:v1 .</span><br></pre></td></tr></table></figure></p>\n<p>这时候吧镜像上传到自己dockerhub，需要给自己的镜像打上tag<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker login #先登录</span><br><span class=\"line\">docker tag tomcat:company guoxy/tomcat:company  #其中guoxy为自己的仓库名</span><br><span class=\"line\">docker push guoxy/tomcat:company</span><br></pre></td></tr></table></figure></p>\n<p>此时镜像上传到自己的dockerhub。运行映射一下端口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -p 8080:8080 tomcat:company /bin/bash</span><br></pre></td></tr></table></figure></p>\n<p>按下Ctrl+P+Q使容器在后台运行。再次进入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it tomcat:company /bin/bash 进入如果没启动在bin目录下./startup.sh</span><br></pre></td></tr></table></figure></p>"},{"title":"选择排序和快速排序","date":"2018-12-21T13:39:10.000Z","_content":"\n\n### 二分查找\n\n&nsbp&nsbp二分查找是一种算法，输入是一个有序的列表，例如1-100的数字，找75，先从50找，然后判断大于还是小鱼，每次分一半。当n个元素的列表，用二分查找最多需要`logn`步，而简单查找最多需要n步。仅当列表有序，二分查找才管用。\n\n#### 常见的大O运行时间\n\n- O(logn): 对数时间，例如二分查找\n- O(n): 线性时间，例如简单查找\n- O(n*logn): 快速排序，速度较快的排序算法\n- O(n^2): 选择排序，速度较慢的排序算法\n- O(n!): 旅行商问题。\n\n<!-- more -->\n#### 数组和链表\n\n- 数组意味着其中元素在内存是相连的。\n- 链表中的元素可存储在内存的任意地方，链表的每个元素存储了下一个元素的地址，从而使一系列的随机的内存地址串联在一起。\n- 链表存在的问题是，当需要读取链表的最后一个元素时，你不可以直接读取，因为你不知道他的地址，必须先访问第一个元素。\n\n比较：\n\n|       |  数组  |  链表  |\n|  :--:  |  :--:  | :--:  |\n|  读取  |  O(1)  |  O(N)  |\n|  插入  |  O(N)  |  O(1)  |\n|  删除  |  O(N)  |  O(1)  |\n\n对于链表来说插入元素很简单，只需要修改他前一个元素的指向址，而对于列表来说，需要将后面的元素都往后移。    \n对于删除元素，链表也是更好的选择，只需要修改前一个元素的指向地址，而对于数组来说，删除一个元素，后面的元素都要向前移。\n\n\n#### 选择排序\n\n每次从n个数字里面选取最大的一个，然后在从n-1个数字里面选取最大的，检查的元素为n,n-1,...,1。平均每次检查1/2*n,因此运行时间为O(n*1/2*n),记为O(n^2).\n```\ndef findsmallest(arr):\n    smallest = arr[0]\n    smallest_index = 0\n    for i in range(len(arr):\n        if arr[i] < smallest:\n            smallest = arr[i]\n            smallest_index = i\n    return small_index\n```\n\n#### 快速排序\n\n采取的分而治之的思想，对于一个数组选择一个基准值，然后分为小于基准值的数组和大于基准值的数组，对于这两个数分别再选基准值，递归的思想。事件复杂度为O(nlogn)，快排并不检查数组是否有序。有序仍然会排序。\n\n```\ndef quicksort(array):\n    if len(array) < 2:\n        return array\n    else:\n        pivot = array[0]\n        less = [i for i in array[1:] if i < pivot]\n        greater = [i for i in array[1:] if i > pivot]\n        return quicksort(less) + [pivot] + quicksort[greater]\n```\n\n对于快速排序，最坏的情况，每次基准值都是第一个，此时每一层的排序都是n个元素，但是调用的栈的长度也为n，事件复杂度为O(n*n).如果每次都去中间的作为基准值，栈的长度却为logn,时间复杂度为O(n*logn)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/选择排序和快速排序.md","raw":"---\ntitle: 选择排序和快速排序\ndate: 2018-12-21 21:39:10\ntags: 算法\ncategories: 算法\n---\n\n\n### 二分查找\n\n&nsbp&nsbp二分查找是一种算法，输入是一个有序的列表，例如1-100的数字，找75，先从50找，然后判断大于还是小鱼，每次分一半。当n个元素的列表，用二分查找最多需要`logn`步，而简单查找最多需要n步。仅当列表有序，二分查找才管用。\n\n#### 常见的大O运行时间\n\n- O(logn): 对数时间，例如二分查找\n- O(n): 线性时间，例如简单查找\n- O(n*logn): 快速排序，速度较快的排序算法\n- O(n^2): 选择排序，速度较慢的排序算法\n- O(n!): 旅行商问题。\n\n<!-- more -->\n#### 数组和链表\n\n- 数组意味着其中元素在内存是相连的。\n- 链表中的元素可存储在内存的任意地方，链表的每个元素存储了下一个元素的地址，从而使一系列的随机的内存地址串联在一起。\n- 链表存在的问题是，当需要读取链表的最后一个元素时，你不可以直接读取，因为你不知道他的地址，必须先访问第一个元素。\n\n比较：\n\n|       |  数组  |  链表  |\n|  :--:  |  :--:  | :--:  |\n|  读取  |  O(1)  |  O(N)  |\n|  插入  |  O(N)  |  O(1)  |\n|  删除  |  O(N)  |  O(1)  |\n\n对于链表来说插入元素很简单，只需要修改他前一个元素的指向址，而对于列表来说，需要将后面的元素都往后移。    \n对于删除元素，链表也是更好的选择，只需要修改前一个元素的指向地址，而对于数组来说，删除一个元素，后面的元素都要向前移。\n\n\n#### 选择排序\n\n每次从n个数字里面选取最大的一个，然后在从n-1个数字里面选取最大的，检查的元素为n,n-1,...,1。平均每次检查1/2*n,因此运行时间为O(n*1/2*n),记为O(n^2).\n```\ndef findsmallest(arr):\n    smallest = arr[0]\n    smallest_index = 0\n    for i in range(len(arr):\n        if arr[i] < smallest:\n            smallest = arr[i]\n            smallest_index = i\n    return small_index\n```\n\n#### 快速排序\n\n采取的分而治之的思想，对于一个数组选择一个基准值，然后分为小于基准值的数组和大于基准值的数组，对于这两个数分别再选基准值，递归的思想。事件复杂度为O(nlogn)，快排并不检查数组是否有序。有序仍然会排序。\n\n```\ndef quicksort(array):\n    if len(array) < 2:\n        return array\n    else:\n        pivot = array[0]\n        less = [i for i in array[1:] if i < pivot]\n        greater = [i for i in array[1:] if i > pivot]\n        return quicksort(less) + [pivot] + quicksort[greater]\n```\n\n对于快速排序，最坏的情况，每次基准值都是第一个，此时每一层的排序都是n个元素，但是调用的栈的长度也为n，事件复杂度为O(n*n).如果每次都去中间的作为基准值，栈的长度却为logn,时间复杂度为O(n*logn)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"选择排序和快速排序","published":1,"updated":"2022-05-20T02:24:20.544Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3e0vh7w002nlae1dls84v9n","content":"<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><p>&amp;nsbp&amp;nsbp二分查找是一种算法，输入是一个有序的列表，例如1-100的数字，找75，先从50找，然后判断大于还是小鱼，每次分一半。当n个元素的列表，用二分查找最多需要<code>logn</code>步，而简单查找最多需要n步。仅当列表有序，二分查找才管用。</p>\n<h4 id=\"常见的大O运行时间\"><a href=\"#常见的大O运行时间\" class=\"headerlink\" title=\"常见的大O运行时间\"></a>常见的大O运行时间</h4><ul>\n<li>O(logn): 对数时间，例如二分查找</li>\n<li>O(n): 线性时间，例如简单查找</li>\n<li>O(n*logn): 快速排序，速度较快的排序算法</li>\n<li>O(n^2): 选择排序，速度较慢的排序算法</li>\n<li>O(n!): 旅行商问题。</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"数组和链表\"><a href=\"#数组和链表\" class=\"headerlink\" title=\"数组和链表\"></a>数组和链表</h4><ul>\n<li>数组意味着其中元素在内存是相连的。</li>\n<li>链表中的元素可存储在内存的任意地方，链表的每个元素存储了下一个元素的地址，从而使一系列的随机的内存地址串联在一起。</li>\n<li>链表存在的问题是，当需要读取链表的最后一个元素时，你不可以直接读取，因为你不知道他的地址，必须先访问第一个元素。</li>\n</ul>\n<p>比较：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">数组</th>\n<th style=\"text-align:center\">链表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">读取</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(N)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">插入</td>\n<td style=\"text-align:center\">O(N)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">删除</td>\n<td style=\"text-align:center\">O(N)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n</tbody>\n</table>\n<p>对于链表来说插入元素很简单，只需要修改他前一个元素的指向址，而对于列表来说，需要将后面的元素都往后移。<br>对于删除元素，链表也是更好的选择，只需要修改前一个元素的指向地址，而对于数组来说，删除一个元素，后面的元素都要向前移。</p>\n<h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><p>每次从n个数字里面选取最大的一个，然后在从n-1个数字里面选取最大的，检查的元素为n,n-1,…,1。平均每次检查1/2<em>n,因此运行时间为O(n</em>1/2*n),记为O(n^2).<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def findsmallest(arr):</span><br><span class=\"line\">    smallest = arr[0]</span><br><span class=\"line\">    smallest_index = 0</span><br><span class=\"line\">    for i in range(len(arr):</span><br><span class=\"line\">        if arr[i] &lt; smallest:</span><br><span class=\"line\">            smallest = arr[i]</span><br><span class=\"line\">            smallest_index = i</span><br><span class=\"line\">    return small_index</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><p>采取的分而治之的思想，对于一个数组选择一个基准值，然后分为小于基准值的数组和大于基准值的数组，对于这两个数分别再选基准值，递归的思想。事件复杂度为O(nlogn)，快排并不检查数组是否有序。有序仍然会排序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def quicksort(array):</span><br><span class=\"line\">    if len(array) &lt; 2:</span><br><span class=\"line\">        return array</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        pivot = array[0]</span><br><span class=\"line\">        less = [i for i in array[1:] if i &lt; pivot]</span><br><span class=\"line\">        greater = [i for i in array[1:] if i &gt; pivot]</span><br><span class=\"line\">        return quicksort(less) + [pivot] + quicksort[greater]</span><br></pre></td></tr></table></figure>\n<p>对于快速排序，最坏的情况，每次基准值都是第一个，此时每一层的排序都是n个元素，但是调用的栈的长度也为n，事件复杂度为O(n<em>n).如果每次都去中间的作为基准值，栈的长度却为logn,时间复杂度为O(n</em>logn)</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><p>&amp;nsbp&amp;nsbp二分查找是一种算法，输入是一个有序的列表，例如1-100的数字，找75，先从50找，然后判断大于还是小鱼，每次分一半。当n个元素的列表，用二分查找最多需要<code>logn</code>步，而简单查找最多需要n步。仅当列表有序，二分查找才管用。</p>\n<h4 id=\"常见的大O运行时间\"><a href=\"#常见的大O运行时间\" class=\"headerlink\" title=\"常见的大O运行时间\"></a>常见的大O运行时间</h4><ul>\n<li>O(logn): 对数时间，例如二分查找</li>\n<li>O(n): 线性时间，例如简单查找</li>\n<li>O(n*logn): 快速排序，速度较快的排序算法</li>\n<li>O(n^2): 选择排序，速度较慢的排序算法</li>\n<li>O(n!): 旅行商问题。</li>\n</ul>","more":"<h4 id=\"数组和链表\"><a href=\"#数组和链表\" class=\"headerlink\" title=\"数组和链表\"></a>数组和链表</h4><ul>\n<li>数组意味着其中元素在内存是相连的。</li>\n<li>链表中的元素可存储在内存的任意地方，链表的每个元素存储了下一个元素的地址，从而使一系列的随机的内存地址串联在一起。</li>\n<li>链表存在的问题是，当需要读取链表的最后一个元素时，你不可以直接读取，因为你不知道他的地址，必须先访问第一个元素。</li>\n</ul>\n<p>比较：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">数组</th>\n<th style=\"text-align:center\">链表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">读取</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(N)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">插入</td>\n<td style=\"text-align:center\">O(N)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">删除</td>\n<td style=\"text-align:center\">O(N)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n</tbody>\n</table>\n<p>对于链表来说插入元素很简单，只需要修改他前一个元素的指向址，而对于列表来说，需要将后面的元素都往后移。<br>对于删除元素，链表也是更好的选择，只需要修改前一个元素的指向地址，而对于数组来说，删除一个元素，后面的元素都要向前移。</p>\n<h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><p>每次从n个数字里面选取最大的一个，然后在从n-1个数字里面选取最大的，检查的元素为n,n-1,…,1。平均每次检查1/2<em>n,因此运行时间为O(n</em>1/2*n),记为O(n^2).<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def findsmallest(arr):</span><br><span class=\"line\">    smallest = arr[0]</span><br><span class=\"line\">    smallest_index = 0</span><br><span class=\"line\">    for i in range(len(arr):</span><br><span class=\"line\">        if arr[i] &lt; smallest:</span><br><span class=\"line\">            smallest = arr[i]</span><br><span class=\"line\">            smallest_index = i</span><br><span class=\"line\">    return small_index</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><p>采取的分而治之的思想，对于一个数组选择一个基准值，然后分为小于基准值的数组和大于基准值的数组，对于这两个数分别再选基准值，递归的思想。事件复杂度为O(nlogn)，快排并不检查数组是否有序。有序仍然会排序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def quicksort(array):</span><br><span class=\"line\">    if len(array) &lt; 2:</span><br><span class=\"line\">        return array</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        pivot = array[0]</span><br><span class=\"line\">        less = [i for i in array[1:] if i &lt; pivot]</span><br><span class=\"line\">        greater = [i for i in array[1:] if i &gt; pivot]</span><br><span class=\"line\">        return quicksort(less) + [pivot] + quicksort[greater]</span><br></pre></td></tr></table></figure>\n<p>对于快速排序，最坏的情况，每次基准值都是第一个，此时每一层的排序都是n个元素，但是调用的栈的长度也为n，事件复杂度为O(n<em>n).如果每次都去中间的作为基准值，栈的长度却为logn,时间复杂度为O(n</em>logn)</p>"},{"layout":"posts","title":"函数的防抖与节流","date":"2019-05-17T03:35:02.000Z","_content":"\n### 函数的防抖与节流\n\n`debounce`(防抖)与`throttle`(节流)是开发中常用的函数。\n\n\n#### 函数防抖(debounce)\n\n解释: 在事件被触发的n秒后在执行回调函数，如果在n秒内又被触发，则重新计时。\n举个例子:\n```\n//模拟ajax请求\nfuction ajax(content) {\n    console.log('ajax request' + content)\n}\n\nlet input = document.getElementById('unbounce')\n\ninput.addEventListener('keyup', function(e) {\n    ajax(e.target.value)\n})\n\n```\n这里相当于每次用户从键盘输入，都会触发ajax请求，从资源上来说是十分浪费的，而且在实际应用中，用户也是需要在输入完整的字符之后才会请求。\n\n如何优化呢\n```\n\nfunctuion ajax(content) {\n    console.log('ajax request' + content)\n}\n\nfunction debounce(fun, deleay) {\n    return function(args) {\n        let that = this\n        let _args = args\n        clearTimeout(fun.id)\n        fun.id = setTimeout(function() {\n            fun.call(that, _args)\n        }, delay)\n    }\n}\n\nlet input = document.getElementById('debounce')\n\nlet debounceAjax = debounce(ajax, 500)\n\ninput.addEventListener('keyup', function(e) {\n    debounceAjax(e.target.value)\n})\n```\n可以看出，在家了防抖之后，频繁的输入并不会发送请求，而是在指定间隔后，重新执行函数。    \n思路就是，执行一个延迟函数，这个延迟的函数就是keyup事件，然后如果在指定间隔内多次触发，那么先清空这个计时器也就是之前执行的函数，然后重新setTimeout即可。在指定间隔内如果重复触发，那么函数一次也不执行。\n\n#### 函数的节流(throttle)\n在规定的时间内，只能触发一次函数，如果在规定时间内多次触发，那么只会触发一次。\n```\nfunction throttle(fun, delay) {\n\t\tlet last, deferTimer;\n\t\treturn function(args) {\n\t\t\tlet that = this;\n\t\t\tlet _args = args;\n\t\t\tlet now = +new Date();\n\t\t\tif (last && now < last+delay) {\n\t\t\t\tconsole.log('<<<<')\n\t\t\t\tclearTimeout(deferTimer);\n\t\t\t\tdeferTimer = setTimeout(function() {\n\t\t\t\t\tlast = now;\n\t\t\t\t\tfun.call(that, _args);\n\t\t\t\t}, delay)\n\t\t\t} else {\n\t\t\t\tlast = now;\n\t\t\t\tfun.call(that, _args);\n\t\t\t}\n\t\t}\n\t}\n\tlet input_throttle = document.getElementById('throttle');\n\tlet throttleAjax = throttle(ajax, 1000);\n\tinput_throttle.addEventListener('keyup', function(e) {\n\t\tthrottleAjax(e.target.value);\n\t})\n```\n第一次先执行else语句，然后不到1s再次触发函数，那么清空，这时候时间now大于last+1s，则继续输出。达到了每隔1s输出一次，在1s内多次输入的话，也只会在1s后输出。\n\n总结:\n - 函数的防抖像法师的读条，需要蓄力才可以完成，而且可以被打断。\n - 函数的节流像fps射击游戏，即使一直射击，也只会在规定的射速内射出子弹。\n\n应用场景:\n 1. 防抖(debounce)\n  - search搜索联想,在用户不断进行输入，利用防抖节约资源\n  - window触发resize事件，不路段的调整浏览器窗口，利用防抖只触发一次。\n 2. 节流(throttle)\n  - 鼠标不断点击触发,mousedown(单位时间只能触发一次)\n  - 监听滚动事件，例如加载到底部加载更多，利用throttle。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/函数的防抖与节流.md","raw":"---\nlayout: posts\ntitle: 函数的防抖与节流\ndate: 2019-05-17 11:35:02\ntags: 前端\ncategories: 前端\n---\n\n### 函数的防抖与节流\n\n`debounce`(防抖)与`throttle`(节流)是开发中常用的函数。\n\n\n#### 函数防抖(debounce)\n\n解释: 在事件被触发的n秒后在执行回调函数，如果在n秒内又被触发，则重新计时。\n举个例子:\n```\n//模拟ajax请求\nfuction ajax(content) {\n    console.log('ajax request' + content)\n}\n\nlet input = document.getElementById('unbounce')\n\ninput.addEventListener('keyup', function(e) {\n    ajax(e.target.value)\n})\n\n```\n这里相当于每次用户从键盘输入，都会触发ajax请求，从资源上来说是十分浪费的，而且在实际应用中，用户也是需要在输入完整的字符之后才会请求。\n\n如何优化呢\n```\n\nfunctuion ajax(content) {\n    console.log('ajax request' + content)\n}\n\nfunction debounce(fun, deleay) {\n    return function(args) {\n        let that = this\n        let _args = args\n        clearTimeout(fun.id)\n        fun.id = setTimeout(function() {\n            fun.call(that, _args)\n        }, delay)\n    }\n}\n\nlet input = document.getElementById('debounce')\n\nlet debounceAjax = debounce(ajax, 500)\n\ninput.addEventListener('keyup', function(e) {\n    debounceAjax(e.target.value)\n})\n```\n可以看出，在家了防抖之后，频繁的输入并不会发送请求，而是在指定间隔后，重新执行函数。    \n思路就是，执行一个延迟函数，这个延迟的函数就是keyup事件，然后如果在指定间隔内多次触发，那么先清空这个计时器也就是之前执行的函数，然后重新setTimeout即可。在指定间隔内如果重复触发，那么函数一次也不执行。\n\n#### 函数的节流(throttle)\n在规定的时间内，只能触发一次函数，如果在规定时间内多次触发，那么只会触发一次。\n```\nfunction throttle(fun, delay) {\n\t\tlet last, deferTimer;\n\t\treturn function(args) {\n\t\t\tlet that = this;\n\t\t\tlet _args = args;\n\t\t\tlet now = +new Date();\n\t\t\tif (last && now < last+delay) {\n\t\t\t\tconsole.log('<<<<')\n\t\t\t\tclearTimeout(deferTimer);\n\t\t\t\tdeferTimer = setTimeout(function() {\n\t\t\t\t\tlast = now;\n\t\t\t\t\tfun.call(that, _args);\n\t\t\t\t}, delay)\n\t\t\t} else {\n\t\t\t\tlast = now;\n\t\t\t\tfun.call(that, _args);\n\t\t\t}\n\t\t}\n\t}\n\tlet input_throttle = document.getElementById('throttle');\n\tlet throttleAjax = throttle(ajax, 1000);\n\tinput_throttle.addEventListener('keyup', function(e) {\n\t\tthrottleAjax(e.target.value);\n\t})\n```\n第一次先执行else语句，然后不到1s再次触发函数，那么清空，这时候时间now大于last+1s，则继续输出。达到了每隔1s输出一次，在1s内多次输入的话，也只会在1s后输出。\n\n总结:\n - 函数的防抖像法师的读条，需要蓄力才可以完成，而且可以被打断。\n - 函数的节流像fps射击游戏，即使一直射击，也只会在规定的射速内射出子弹。\n\n应用场景:\n 1. 防抖(debounce)\n  - search搜索联想,在用户不断进行输入，利用防抖节约资源\n  - window触发resize事件，不路段的调整浏览器窗口，利用防抖只触发一次。\n 2. 节流(throttle)\n  - 鼠标不断点击触发,mousedown(单位时间只能触发一次)\n  - 监听滚动事件，例如加载到底部加载更多，利用throttle。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"函数的防抖与节流","published":1,"updated":"2022-05-20T02:24:20.543Z","comments":1,"photos":[],"link":"","_id":"cl3e0vh7x002plae1of52n2um","content":"<h3 id=\"函数的防抖与节流\"><a href=\"#函数的防抖与节流\" class=\"headerlink\" title=\"函数的防抖与节流\"></a>函数的防抖与节流</h3><p><code>debounce</code>(防抖)与<code>throttle</code>(节流)是开发中常用的函数。</p>\n<h4 id=\"函数防抖-debounce\"><a href=\"#函数防抖-debounce\" class=\"headerlink\" title=\"函数防抖(debounce)\"></a>函数防抖(debounce)</h4><p>解释: 在事件被触发的n秒后在执行回调函数，如果在n秒内又被触发，则重新计时。<br>举个例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//模拟ajax请求</span><br><span class=\"line\">fuction ajax(content) &#123;</span><br><span class=\"line\">    console.log(&apos;ajax request&apos; + content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let input = document.getElementById(&apos;unbounce&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">input.addEventListener(&apos;keyup&apos;, function(e) &#123;</span><br><span class=\"line\">    ajax(e.target.value)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这里相当于每次用户从键盘输入，都会触发ajax请求，从资源上来说是十分浪费的，而且在实际应用中，用户也是需要在输入完整的字符之后才会请求。</p>\n<p>如何优化呢<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">functuion ajax(content) &#123;</span><br><span class=\"line\">    console.log(&apos;ajax request&apos; + content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function debounce(fun, deleay) &#123;</span><br><span class=\"line\">    return function(args) &#123;</span><br><span class=\"line\">        let that = this</span><br><span class=\"line\">        let _args = args</span><br><span class=\"line\">        clearTimeout(fun.id)</span><br><span class=\"line\">        fun.id = setTimeout(function() &#123;</span><br><span class=\"line\">            fun.call(that, _args)</span><br><span class=\"line\">        &#125;, delay)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let input = document.getElementById(&apos;debounce&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">let debounceAjax = debounce(ajax, 500)</span><br><span class=\"line\"></span><br><span class=\"line\">input.addEventListener(&apos;keyup&apos;, function(e) &#123;</span><br><span class=\"line\">    debounceAjax(e.target.value)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>可以看出，在家了防抖之后，频繁的输入并不会发送请求，而是在指定间隔后，重新执行函数。<br>思路就是，执行一个延迟函数，这个延迟的函数就是keyup事件，然后如果在指定间隔内多次触发，那么先清空这个计时器也就是之前执行的函数，然后重新setTimeout即可。在指定间隔内如果重复触发，那么函数一次也不执行。</p>\n<h4 id=\"函数的节流-throttle\"><a href=\"#函数的节流-throttle\" class=\"headerlink\" title=\"函数的节流(throttle)\"></a>函数的节流(throttle)</h4><p>在规定的时间内，只能触发一次函数，如果在规定时间内多次触发，那么只会触发一次。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(fun, delay) &#123;</span><br><span class=\"line\">\t\tlet last, deferTimer;</span><br><span class=\"line\">\t\treturn function(args) &#123;</span><br><span class=\"line\">\t\t\tlet that = this;</span><br><span class=\"line\">\t\t\tlet _args = args;</span><br><span class=\"line\">\t\t\tlet now = +new Date();</span><br><span class=\"line\">\t\t\tif (last &amp;&amp; now &lt; last+delay) &#123;</span><br><span class=\"line\">\t\t\t\tconsole.log(&apos;&lt;&lt;&lt;&lt;&apos;)</span><br><span class=\"line\">\t\t\t\tclearTimeout(deferTimer);</span><br><span class=\"line\">\t\t\t\tdeferTimer = setTimeout(function() &#123;</span><br><span class=\"line\">\t\t\t\t\tlast = now;</span><br><span class=\"line\">\t\t\t\t\tfun.call(that, _args);</span><br><span class=\"line\">\t\t\t\t&#125;, delay)</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\tlast = now;</span><br><span class=\"line\">\t\t\t\tfun.call(that, _args);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlet input_throttle = document.getElementById(&apos;throttle&apos;);</span><br><span class=\"line\">\tlet throttleAjax = throttle(ajax, 1000);</span><br><span class=\"line\">\tinput_throttle.addEventListener(&apos;keyup&apos;, function(e) &#123;</span><br><span class=\"line\">\t\tthrottleAjax(e.target.value);</span><br><span class=\"line\">\t&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>第一次先执行else语句，然后不到1s再次触发函数，那么清空，这时候时间now大于last+1s，则继续输出。达到了每隔1s输出一次，在1s内多次输入的话，也只会在1s后输出。</p>\n<p>总结:</p>\n<ul>\n<li>函数的防抖像法师的读条，需要蓄力才可以完成，而且可以被打断。</li>\n<li>函数的节流像fps射击游戏，即使一直射击，也只会在规定的射速内射出子弹。</li>\n</ul>\n<p>应用场景:</p>\n<ol>\n<li>防抖(debounce)<ul>\n<li>search搜索联想,在用户不断进行输入，利用防抖节约资源</li>\n<li>window触发resize事件，不路段的调整浏览器窗口，利用防抖只触发一次。</li>\n</ul>\n</li>\n<li>节流(throttle)<ul>\n<li>鼠标不断点击触发,mousedown(单位时间只能触发一次)</li>\n<li>监听滚动事件，例如加载到底部加载更多，利用throttle。</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"函数的防抖与节流\"><a href=\"#函数的防抖与节流\" class=\"headerlink\" title=\"函数的防抖与节流\"></a>函数的防抖与节流</h3><p><code>debounce</code>(防抖)与<code>throttle</code>(节流)是开发中常用的函数。</p>\n<h4 id=\"函数防抖-debounce\"><a href=\"#函数防抖-debounce\" class=\"headerlink\" title=\"函数防抖(debounce)\"></a>函数防抖(debounce)</h4><p>解释: 在事件被触发的n秒后在执行回调函数，如果在n秒内又被触发，则重新计时。<br>举个例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//模拟ajax请求</span><br><span class=\"line\">fuction ajax(content) &#123;</span><br><span class=\"line\">    console.log(&apos;ajax request&apos; + content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let input = document.getElementById(&apos;unbounce&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">input.addEventListener(&apos;keyup&apos;, function(e) &#123;</span><br><span class=\"line\">    ajax(e.target.value)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这里相当于每次用户从键盘输入，都会触发ajax请求，从资源上来说是十分浪费的，而且在实际应用中，用户也是需要在输入完整的字符之后才会请求。</p>\n<p>如何优化呢<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">functuion ajax(content) &#123;</span><br><span class=\"line\">    console.log(&apos;ajax request&apos; + content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function debounce(fun, deleay) &#123;</span><br><span class=\"line\">    return function(args) &#123;</span><br><span class=\"line\">        let that = this</span><br><span class=\"line\">        let _args = args</span><br><span class=\"line\">        clearTimeout(fun.id)</span><br><span class=\"line\">        fun.id = setTimeout(function() &#123;</span><br><span class=\"line\">            fun.call(that, _args)</span><br><span class=\"line\">        &#125;, delay)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let input = document.getElementById(&apos;debounce&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">let debounceAjax = debounce(ajax, 500)</span><br><span class=\"line\"></span><br><span class=\"line\">input.addEventListener(&apos;keyup&apos;, function(e) &#123;</span><br><span class=\"line\">    debounceAjax(e.target.value)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>可以看出，在家了防抖之后，频繁的输入并不会发送请求，而是在指定间隔后，重新执行函数。<br>思路就是，执行一个延迟函数，这个延迟的函数就是keyup事件，然后如果在指定间隔内多次触发，那么先清空这个计时器也就是之前执行的函数，然后重新setTimeout即可。在指定间隔内如果重复触发，那么函数一次也不执行。</p>\n<h4 id=\"函数的节流-throttle\"><a href=\"#函数的节流-throttle\" class=\"headerlink\" title=\"函数的节流(throttle)\"></a>函数的节流(throttle)</h4><p>在规定的时间内，只能触发一次函数，如果在规定时间内多次触发，那么只会触发一次。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(fun, delay) &#123;</span><br><span class=\"line\">\t\tlet last, deferTimer;</span><br><span class=\"line\">\t\treturn function(args) &#123;</span><br><span class=\"line\">\t\t\tlet that = this;</span><br><span class=\"line\">\t\t\tlet _args = args;</span><br><span class=\"line\">\t\t\tlet now = +new Date();</span><br><span class=\"line\">\t\t\tif (last &amp;&amp; now &lt; last+delay) &#123;</span><br><span class=\"line\">\t\t\t\tconsole.log(&apos;&lt;&lt;&lt;&lt;&apos;)</span><br><span class=\"line\">\t\t\t\tclearTimeout(deferTimer);</span><br><span class=\"line\">\t\t\t\tdeferTimer = setTimeout(function() &#123;</span><br><span class=\"line\">\t\t\t\t\tlast = now;</span><br><span class=\"line\">\t\t\t\t\tfun.call(that, _args);</span><br><span class=\"line\">\t\t\t\t&#125;, delay)</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\tlast = now;</span><br><span class=\"line\">\t\t\t\tfun.call(that, _args);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlet input_throttle = document.getElementById(&apos;throttle&apos;);</span><br><span class=\"line\">\tlet throttleAjax = throttle(ajax, 1000);</span><br><span class=\"line\">\tinput_throttle.addEventListener(&apos;keyup&apos;, function(e) &#123;</span><br><span class=\"line\">\t\tthrottleAjax(e.target.value);</span><br><span class=\"line\">\t&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>第一次先执行else语句，然后不到1s再次触发函数，那么清空，这时候时间now大于last+1s，则继续输出。达到了每隔1s输出一次，在1s内多次输入的话，也只会在1s后输出。</p>\n<p>总结:</p>\n<ul>\n<li>函数的防抖像法师的读条，需要蓄力才可以完成，而且可以被打断。</li>\n<li>函数的节流像fps射击游戏，即使一直射击，也只会在规定的射速内射出子弹。</li>\n</ul>\n<p>应用场景:</p>\n<ol>\n<li>防抖(debounce)<ul>\n<li>search搜索联想,在用户不断进行输入，利用防抖节约资源</li>\n<li>window触发resize事件，不路段的调整浏览器窗口，利用防抖只触发一次。</li>\n</ul>\n</li>\n<li>节流(throttle)<ul>\n<li>鼠标不断点击触发,mousedown(单位时间只能触发一次)</li>\n<li>监听滚动事件，例如加载到底部加载更多，利用throttle。</li>\n</ul>\n</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl3e0vh750002lae1c5p0o81z","category_id":"cl3e0vh7a0004lae15whkwbhm","_id":"cl3e0vh7f000elae1qbazy77r"},{"post_id":"cl3e0vh7e000clae1bg2s060o","category_id":"cl3e0vh7a0004lae15whkwbhm","_id":"cl3e0vh7h000llae1k25wpq8f"},{"post_id":"cl3e0vh7a0003lae1d1jssrc9","category_id":"cl3e0vh7d0009lae1y6jf0ds7","_id":"cl3e0vh7i000qlae1airu47fq"},{"post_id":"cl3e0vh7e000dlae12hr3xkm2","category_id":"cl3e0vh7a0004lae15whkwbhm","_id":"cl3e0vh7j000tlae1bdvmsepe"},{"post_id":"cl3e0vh7g000ilae1z44pw3q8","category_id":"cl3e0vh7a0004lae15whkwbhm","_id":"cl3e0vh7k000xlae1ah2hj254"},{"post_id":"cl3e0vh7b0006lae19taj14fv","category_id":"cl3e0vh7d0009lae1y6jf0ds7","_id":"cl3e0vh7k0010lae1qduygg92"},{"post_id":"cl3e0vh7c0007lae1ppe58zsz","category_id":"cl3e0vh7i000mlae1sohi7f71","_id":"cl3e0vh7l0015lae1qcy3l6eq"},{"post_id":"cl3e0vh7k000wlae1903ajx5j","category_id":"cl3e0vh7d0009lae1y6jf0ds7","_id":"cl3e0vh7m0018lae1rnka58v0"},{"post_id":"cl3e0vh7d0008lae16nn6rlt2","category_id":"cl3e0vh7d0009lae1y6jf0ds7","_id":"cl3e0vh7n001dlae1pp4kh2af"},{"post_id":"cl3e0vh7k000zlae1f7j93k0c","category_id":"cl3e0vh7d0009lae1y6jf0ds7","_id":"cl3e0vh7n001glae11fj6jz6v"},{"post_id":"cl3e0vh7h000klae18kzuovdj","category_id":"cl3e0vh7l0011lae1rb8hreoa","_id":"cl3e0vh7o001ilae1vcg3phje"},{"post_id":"cl3e0vh7i000plae1b3zpt3r2","category_id":"cl3e0vh7m001alae1b76p2h9o","_id":"cl3e0vh7p001olae19wfl3gwu"},{"post_id":"cl3e0vh7l0014lae1av9wai81","category_id":"cl3e0vh7o001jlae1b5he07cg","_id":"cl3e0vh7q001vlae11c0uuce2"},{"post_id":"cl3e0vh7l0017lae12tegnvnr","category_id":"cl3e0vh7o001jlae1b5he07cg","_id":"cl3e0vh7s0021lae1qfdwyfg1"},{"post_id":"cl3e0vh7q001tlae1g8mvb8ia","category_id":"cl3e0vh7a0004lae15whkwbhm","_id":"cl3e0vh7t0025lae1ne5lzcer"},{"post_id":"cl3e0vh7m001clae1w22vpdon","category_id":"cl3e0vh7o001jlae1b5he07cg","_id":"cl3e0vh7u0029lae1t8g3ianf"},{"post_id":"cl3e0vh7n001flae1b8hmqk01","category_id":"cl3e0vh7o001jlae1b5he07cg","_id":"cl3e0vh7v002elae1hc1ygoeb"},{"post_id":"cl3e0vh7n001hlae1r8b45ltr","category_id":"cl3e0vh7u0028lae1ix7ff9gu","_id":"cl3e0vh7w002llae1hg39vlw9"},{"post_id":"cl3e0vh7o001nlae1q46x2afl","category_id":"cl3e0vh7u0028lae1ix7ff9gu","_id":"cl3e0vh7x002rlae19ymeld0l"},{"post_id":"cl3e0vh7p001rlae1jc1mgftt","category_id":"cl3e0vh7u0028lae1ix7ff9gu","_id":"cl3e0vh7y002ulae1j4f40vi7"},{"post_id":"cl3e0vh7r001xlae15gkjdl50","category_id":"cl3e0vh7x002qlae10znptkeb","_id":"cl3e0vh7y002ylae17w3d9zqx"},{"post_id":"cl3e0vh7s001zlae1mke69nl0","category_id":"cl3e0vh7y002vlae1bamsz0lr","_id":"cl3e0vh7z0032lae1ajxwnytr"},{"post_id":"cl3e0vh7t0024lae1lr26eh0v","category_id":"cl3e0vh7y002zlae1vl2mtfrl","_id":"cl3e0vh7z0036lae1uhtd2z3t"},{"post_id":"cl3e0vh7t0027lae1hnmkajbm","category_id":"cl3e0vh7z0034lae1ef23h0f1","_id":"cl3e0vh80003blae1oyayqnhl"},{"post_id":"cl3e0vh7u002blae1pxebeam7","category_id":"cl3e0vh7z0034lae1ef23h0f1","_id":"cl3e0vh80003elae1wzg1f74q"},{"post_id":"cl3e0vh7v002dlae1ak4yommq","category_id":"cl3e0vh7z003alae1r7h9513q","_id":"cl3e0vh80003jlae1gffep7a2"},{"post_id":"cl3e0vh7v002hlae1zuj1lv30","category_id":"cl3e0vh7z003alae1r7h9513q","_id":"cl3e0vh81003mlae12w63iixn"},{"post_id":"cl3e0vh7w002jlae1v3mvvo1b","category_id":"cl3e0vh80003ilae13izbh765","_id":"cl3e0vh81003rlae1kjuzxub3"},{"post_id":"cl3e0vh7w002nlae1dls84v9n","category_id":"cl3e0vh7z003alae1r7h9513q","_id":"cl3e0vh82003ulae1vm23epsv"},{"post_id":"cl3e0vh7x002plae1of52n2um","category_id":"cl3e0vh7z0034lae1ef23h0f1","_id":"cl3e0vh82003xlae1uz77o7s9"}],"PostTag":[{"post_id":"cl3e0vh750002lae1c5p0o81z","tag_id":"cl3e0vh7b0005lae17vu453pz","_id":"cl3e0vh7e000blae16j7nbfbj"},{"post_id":"cl3e0vh7e000clae1bg2s060o","tag_id":"cl3e0vh7b0005lae17vu453pz","_id":"cl3e0vh7g000hlae1eoivdv2n"},{"post_id":"cl3e0vh7a0003lae1d1jssrc9","tag_id":"cl3e0vh7d000alae1xuk595cp","_id":"cl3e0vh7h000jlae10kcr08yh"},{"post_id":"cl3e0vh7g000ilae1z44pw3q8","tag_id":"cl3e0vh7b0005lae17vu453pz","_id":"cl3e0vh7i000olae1geavvuif"},{"post_id":"cl3e0vh7b0006lae19taj14fv","tag_id":"cl3e0vh7d000alae1xuk595cp","_id":"cl3e0vh7i000rlae1aae9lp5q"},{"post_id":"cl3e0vh7c0007lae1ppe58zsz","tag_id":"cl3e0vh7i000nlae1uzvs1npi","_id":"cl3e0vh7k000ylae1nrsifko9"},{"post_id":"cl3e0vh7k000wlae1903ajx5j","tag_id":"cl3e0vh7d000alae1xuk595cp","_id":"cl3e0vh7l0013lae1szju8641"},{"post_id":"cl3e0vh7d0008lae16nn6rlt2","tag_id":"cl3e0vh7d000alae1xuk595cp","_id":"cl3e0vh7l0016lae1t64pre74"},{"post_id":"cl3e0vh7k000zlae1f7j93k0c","tag_id":"cl3e0vh7d000alae1xuk595cp","_id":"cl3e0vh7m0019lae16sd5u0q1"},{"post_id":"cl3e0vh7e000dlae12hr3xkm2","tag_id":"cl3e0vh7l0012lae13b925voc","_id":"cl3e0vh7n001elae1ubn7xyti"},{"post_id":"cl3e0vh7h000klae18kzuovdj","tag_id":"cl3e0vh7m001blae1sr7n851r","_id":"cl3e0vh7o001llae1b2ls05s8"},{"post_id":"cl3e0vh7i000plae1b3zpt3r2","tag_id":"cl3e0vh7o001klae16kxfgsqk","_id":"cl3e0vh7q001slae1bs8q729g"},{"post_id":"cl3e0vh7j000slae1sc7mo7lg","tag_id":"cl3e0vh7p001qlae1bti48b0v","_id":"cl3e0vh7r001ylae14kh8bi6n"},{"post_id":"cl3e0vh7q001tlae1g8mvb8ia","tag_id":"cl3e0vh7b0005lae17vu453pz","_id":"cl3e0vh7s0022lae1uh4xgsfc"},{"post_id":"cl3e0vh7l0014lae1av9wai81","tag_id":"cl3e0vh7q001wlae14dlqxz3i","_id":"cl3e0vh7t0026lae1twlh8dgu"},{"post_id":"cl3e0vh7l0017lae12tegnvnr","tag_id":"cl3e0vh7q001wlae14dlqxz3i","_id":"cl3e0vh7u002clae1hwtcf0hz"},{"post_id":"cl3e0vh7m001clae1w22vpdon","tag_id":"cl3e0vh7q001wlae14dlqxz3i","_id":"cl3e0vh7w002ilae1jiwwkest"},{"post_id":"cl3e0vh7n001flae1b8hmqk01","tag_id":"cl3e0vh7q001wlae14dlqxz3i","_id":"cl3e0vh7x002olae1krubig47"},{"post_id":"cl3e0vh7n001hlae1r8b45ltr","tag_id":"cl3e0vh7w002mlae1ail6dtq6","_id":"cl3e0vh7y002tlae1n3y7zt25"},{"post_id":"cl3e0vh7o001mlae1xwkdvj7q","tag_id":"cl3e0vh7w002mlae1ail6dtq6","_id":"cl3e0vh7y002xlae1r7kt4lad"},{"post_id":"cl3e0vh7o001nlae1q46x2afl","tag_id":"cl3e0vh7w002mlae1ail6dtq6","_id":"cl3e0vh7z0031lae140redhzd"},{"post_id":"cl3e0vh7p001rlae1jc1mgftt","tag_id":"cl3e0vh7w002mlae1ail6dtq6","_id":"cl3e0vh7z0035lae1p7bbxqs5"},{"post_id":"cl3e0vh7r001xlae15gkjdl50","tag_id":"cl3e0vh7z0033lae1cymqzheo","_id":"cl3e0vh7z0039lae1t5s4psae"},{"post_id":"cl3e0vh7s001zlae1mke69nl0","tag_id":"cl3e0vh7z0037lae1w83zhbmf","_id":"cl3e0vh80003dlae1cun6o3ul"},{"post_id":"cl3e0vh7t0024lae1lr26eh0v","tag_id":"cl3e0vh80003clae1wxkq61ag","_id":"cl3e0vh80003hlae14xw2zmc0"},{"post_id":"cl3e0vh7t0027lae1hnmkajbm","tag_id":"cl3e0vh80003glae18z381u2m","_id":"cl3e0vh81003llae1akj7gv9e"},{"post_id":"cl3e0vh7u002blae1pxebeam7","tag_id":"cl3e0vh80003glae18z381u2m","_id":"cl3e0vh81003plae1b9u16poc"},{"post_id":"cl3e0vh7v002dlae1ak4yommq","tag_id":"cl3e0vh81003olae1aoohoj1j","_id":"cl3e0vh82003tlae1321j7se3"},{"post_id":"cl3e0vh7v002hlae1zuj1lv30","tag_id":"cl3e0vh81003olae1aoohoj1j","_id":"cl3e0vh82003wlae1q4yjq1x7"},{"post_id":"cl3e0vh7w002jlae1v3mvvo1b","tag_id":"cl3e0vh82003vlae13mhkokeg","_id":"cl3e0vh82003zlae1ly0wnqz4"},{"post_id":"cl3e0vh7w002nlae1dls84v9n","tag_id":"cl3e0vh81003olae1aoohoj1j","_id":"cl3e0vh830041lae1ph08t764"},{"post_id":"cl3e0vh7x002plae1of52n2um","tag_id":"cl3e0vh80003glae18z381u2m","_id":"cl3e0vh830042lae15ugfpkda"}],"Tag":[{"name":"docker","_id":"cl3e0vh7b0005lae17vu453pz"},{"name":"javascript","_id":"cl3e0vh7d000alae1xuk595cp"},{"name":"生活","_id":"cl3e0vh7i000nlae1uzvs1npi"},{"name":"dcoker","_id":"cl3e0vh7l0012lae13b925voc"},{"name":"ES6","_id":"cl3e0vh7m001blae1sr7n851r"},{"name":"mysql","_id":"cl3e0vh7o001klae16kxfgsqk"},{"name":"服务器部署 hexo","_id":"cl3e0vh7p001qlae1bti48b0v"},{"name":"python","_id":"cl3e0vh7q001wlae14dlqxz3i"},{"name":"redis","_id":"cl3e0vh7w002mlae1ail6dtq6"},{"name":"Tcp","_id":"cl3e0vh7z0033lae1cymqzheo"},{"name":"网络编程","_id":"cl3e0vh7z0037lae1w83zhbmf"},{"name":"vue","_id":"cl3e0vh80003clae1wxkq61ag"},{"name":"前端","_id":"cl3e0vh80003glae18z381u2m"},{"name":"算法","_id":"cl3e0vh81003olae1aoohoj1j"},{"name":"服务器","_id":"cl3e0vh82003vlae13mhkokeg"}]}}